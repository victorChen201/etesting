<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Deploy manual for RP on D03]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/D03/Deploy-manual-for-RP-on-D03/</url>
      <content type="html"><![CDATA[<h3 id="PXE服务器环境"><a href="#PXE服务器环境" class="headerlink" title="PXE服务器环境"></a>PXE服务器环境</h3><p>服务器IP地址：192.168.3.100<br>TFTP根目录：/var/lib/tftpboot</p>
<h3 id="下载相应版本的RP映像文件到tftp目录"><a href="#下载相应版本的RP映像文件到tftp目录" class="headerlink" title="下载相应版本的RP映像文件到tftp目录"></a>下载相应版本的RP映像文件到tftp目录</h3><p>RP映像文件以latest版本为例，需要下载的RP映像文件包括：uefi、centos-installer。文件下载链接如下：<br>uefi:<a href="https://builds.96boards.org/snapshots/reference-platform/components/uefi/latest/debug/d03/" target="_blank" rel="external">https://builds.96boards.org/snapshots/reference-platform/components/uefi/latest/debug/d03/</a><br>centos-installer: <a href="https://builds.96boards.org/snapshots/reference-platform/components/centos-installer/latest/" target="_blank" rel="external">https://builds.96boards.org/snapshots/reference-platform/components/centos-installer/latest/</a><br>使用<a href="/etesting/Estuary/Documents/D03/Deploy-manual-for-RP-on-D03/download_files.sh" title="download_files.sh">download_files.sh</a>脚本进行文件下载。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">TFTP_ROOT=/var/lib/tftpboot</div><div class="line">mkdir <span class="variable">$&#123;TFTP_ROOT&#125;</span>/rp1612 &amp;&amp; <span class="built_in">cd</span> <span class="variable">$&#123;TFTP_ROOT&#125;</span>/rp1612</div><div class="line">mkdir -p uefi/snapshots/latest</div><div class="line">mkdir -p centos-installer/snapshots/</div><div class="line">wget http://jarsonfang.github.io/etesting/Estuary/Documents/D03/Deploy-manual-for-RP-on-D03/download_files.sh</div><div class="line">chmod +x download_files.sh</div><div class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PWD&#125;</span>:<span class="variable">$PATH</span></div><div class="line"><span class="built_in">pushd</span> uefi/snapshots/latest</div><div class="line">download_files.sh https://builds.96boards.org/snapshots/reference-platform/components/uefi/latest/debug/d03/</div><div class="line"><span class="built_in">popd</span></div><div class="line"><span class="built_in">pushd</span> centos-installer/snapshots</div><div class="line">download_files.sh https://builds.96boards.org/snapshots/reference-platform/components/centos-installer/latest/</div><div class="line"><span class="built_in">popd</span></div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="拷贝grubaa64-efi文件到tftp根目录"><a href="#拷贝grubaa64-efi文件到tftp根目录" class="headerlink" title="拷贝grubaa64.efi文件到tftp根目录"></a>拷贝<code>grubaa64.efi</code>文件到tftp根目录</h3><p>为D03单板从PXE环境启动做准备。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> <span class="variable">$&#123;TFTP_ROOT&#125;</span></div><div class="line">mv grubaa64.efi grubaa64.efi.bk</div><div class="line"><span class="built_in">pushd</span> rp1612/centos-installer/snapshots/latest</div><div class="line">cp EFI/BOOT/grubaa64.efi <span class="variable">$&#123;TFTP_ROOT&#125;</span></div><div class="line"><span class="built_in">popd</span></div></pre></td></tr></table></figure></p>
<h3 id="拷贝D03-fd到用户主目录"><a href="#拷贝D03-fd到用户主目录" class="headerlink" title="拷贝D03.fd到用户主目录"></a>拷贝<code>D03.fd</code>到用户主目录</h3><p>为升级UEFI做准备。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> <span class="variable">$&#123;TFTP_ROOT&#125;</span></div><div class="line">pusd rp1612/uefi/snapshots/latest</div><div class="line">cp d03/D03.fd ~/</div><div class="line"><span class="built_in">popd</span></div></pre></td></tr></table></figure></p>
<h3 id="准备grub-cfg和ks-cfg"><a href="#准备grub-cfg和ks-cfg" class="headerlink" title="准备grub.cfg和ks.cfg"></a>准备<code>grub.cfg</code>和<code>ks.cfg</code></h3><p>为单板从PXE环境启动做准备。(假定所使用的D03单板序号为5)<br>修改tftp根目录下以D03单板的MAC地址为结尾的grub.cfg文件，使用以下命令查看D03单板所使用的网卡MAC地址：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jarson@LAVA:~$ grep <span class="string">"BMC5"</span> /usr/<span class="built_in">local</span>/openlab/openlab_conf/boardinfo.cfg</div><div class="line">BOARD5: <span class="built_in">type</span>=D03, serno=BMC5, power=BMC5, mac=c0<span class="_">-a</span>8-03-fa-00-04</div></pre></td></tr></table></figure></p>
<p>例如本次部署的D03单板的MAC地址为<code>c0-a8-03-fa-00-04</code>，则修改<code>/var/lib/tftpboot/grub.cfg-01-c0-a8-03-fa-00-04</code>文件，在文件末尾添加以下内容：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">menuentry <span class="string">'Install CentOS Linux 7 D03 --network'</span> --class red --class gnu-linux --class gnu --class os &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.3.100)</div><div class="line">    <span class="built_in">echo</span> <span class="string">'Loading kernel...'</span></div><div class="line">    linux /rp1612/centos-installer/snapshots/latest/images/pxeboot/vmlinuz ip=eth0:dhcp \</div><div class="line">        console=ttyS0,115200 earlycon=hisilpcuart,mmio,0xa01b0000,0,0x2f8 \</div><div class="line">        pcie_aspm=off \</div><div class="line">        inst.stage2=nfs:192.168.3.100:/var/lib/tftpboot/rp1612/centos-installer/snapshots/latest \</div><div class="line">        inst.ks=nfs:192.168.3.100:/var/lib/tftpboot/rp1612/ks.cfg</div><div class="line">    <span class="built_in">echo</span> <span class="string">'Loading initrd...'</span></div><div class="line">    initrd /rp1612/centos-installer/snapshots/latest/images/pxeboot/initrd.img</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>配置NFS服务器，共享对<code>/var/lib/tftpboot</code>文件目录的访问，在<code>/etc/exports</code>文件中添加以下内容，然后重启NFS服务。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/var/lib/tftpboot *(rw,sync,no_root_squash)</div></pre></td></tr></table></figure></p>
<p>下载<a href="/etesting/Estuary/Documents/D03/Deploy-manual-for-RP-on-D03/ks.cfg" title="ks.cfg">ks.cfg</a>文件到tftp目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /var/lib/tftpboot/rp1612</div><div class="line">wget http://jarsonfang.github.io/etesting/Estuary/Documents/D03/Deploy-manual-for-RP-on-D03/ks.cfg</div></pre></td></tr></table></figure></p>
<h3 id="升级UEFI"><a href="#升级UEFI" class="headerlink" title="升级UEFI"></a>升级UEFI</h3><ol>
<li><p>重启单板至UEFI菜单，如图1所示：  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ board_reboot  5</div></pre></td></tr></table></figure>
<img src="/etesting/Estuary/Documents/D03/Deploy-manual-for-RP-on-D03/1.png" alt="图1. UEFI - Main menu" title="图1. UEFI - Main menu">
</li>
<li><p><del>在“EFI Internal Shell”中配置IP地址</del><br><del>选择“Boot Manager”-&gt;“EFI Internal Shell”进入“EFI Internal Shell”，</del><br><del>“Boot Manager”菜单界面，如图2所示：</del>  </p>
<img src="/etesting/Estuary/Documents/D03/Deploy-manual-for-RP-on-D03/2.png" alt="图2. UEFI - Boot Manager" title="图2. UEFI - Boot Manager">
<p><del>“EFI Internal Shell”界面，如图3所示：</del></p>
<img src="/etesting/Estuary/Documents/D03/Deploy-manual-for-RP-on-D03/3.png" alt="图3. UEFI - EFI Internal Shell" title="图3. UEFI - EFI Internal Shell">
<p><del>使用以下命令配置单板IP地址：</del></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifconfig <span class="_">-s</span> eth0 static &lt;IP address&gt; &lt;mask&gt; &lt;gateway&gt;</div></pre></td></tr></table></figure>
<p><del>e.g.:</del></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifconfig <span class="_">-s</span> eth0 static 192.168.3.250 255.255.255.0 192.168.1.1</div></pre></td></tr></table></figure>
<p><del>如图4所示：</del></p>
<img src="/etesting/Estuary/Documents/D03/Deploy-manual-for-RP-on-D03/4.png" alt="图4. UEFI - Config IP address" title="图4. UEFI - Config IP address">
<p><del>D03单板IP地址可使用下面的命令获取：</del></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">jarson@LAVA:~$ grep <span class="string">"BMC5"</span> /usr/<span class="built_in">local</span>/openlab/openlab_conf/bmcinfo.cfg </div><div class="line">BMC5: ip=192.168.3.250, interface=lanplus, account=root, pass=Huawei12<span class="comment">#$</span></div></pre></td></tr></table></figure>
</li>
<li><p>在“Embedded Boot Loader(EBL)”模式中烧写BIOS文件<br>在“EFI Internal Shell”中输入“exit”回到UEFI主菜单界面，然后选择“Boot Manager”-&gt;“Embedded Boot Loader(EBL)”进入“Embedded Boot Loader(EBL)”模式。如图5、图6所示：</p>
<img src="/etesting/Estuary/Documents/D03/Deploy-manual-for-RP-on-D03/5.png" alt="图5. UEFI - Boot Manager" title="图5. UEFI - Boot Manager">
<img src="/etesting/Estuary/Documents/D03/Deploy-manual-for-RP-on-D03/6.png" alt="图6. UEFI - Embedded Boot Loader(EBL)" title="图6. UEFI - Embedded Boot Loader(EBL)">
<p>在“EFI Internal Shell”中输入以下命令进行BIOS文件烧写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Download file from FTP server to board's RAM</span></div><div class="line">provision &lt;server IP&gt; -u &lt;ftp user name&gt; -p &lt;ftp password&gt; <span class="_">-f</span> &lt;UEFI binary&gt; <span class="_">-a</span> &lt;download target address&gt;</div><div class="line"><span class="comment"># Write the data into NORFLASH</span></div><div class="line">spiwfmem &lt;<span class="built_in">source</span> address&gt; &lt;target address&gt; &lt;data length&gt;</div></pre></td></tr></table></figure>
<p>e.g.:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">provision 192.168.3.100 -u jarson -p xxxxxx <span class="_">-f</span> UEFI_D03.fd <span class="_">-a</span> 0x100000</div><div class="line">spiwfmem 0x100000 0x0 0x300000</div></pre></td></tr></table></figure>
<p>1) 下载BIOS映像文件，如图7、图8所示：</p>
<img src="/etesting/Estuary/Documents/D03/Deploy-manual-for-RP-on-D03/7.png" alt="图7. UEFI - Download BIOS image" title="图7. UEFI - Download BIOS image">
<p>上图中提示选择网卡设备，通过查看网卡MAC地址进行选择。</p>
<img src="/etesting/Estuary/Documents/D03/Deploy-manual-for-RP-on-D03/8.png" alt="图8. UEFI - Download BIOS image (continue)" title="图8. UEFI - Download BIOS image (continue)">
<p>2) 写入BIOS映像文件，如图9所示</p>
<img src="/etesting/Estuary/Documents/D03/Deploy-manual-for-RP-on-D03/9.png" alt="图9. UEFI - Write BIOS image" title="图9. UEFI - Write BIOS image">
<p>写入完成后，输入“reset”命令重启单板，至此，UEFI升级完成。</p>
</li>
</ol>
<h3 id="PXE方式安装系统"><a href="#PXE方式安装系统" class="headerlink" title="PXE方式安装系统"></a>PXE方式安装系统</h3><p>重启单板至UEFI主菜单，在“Boot Manager”菜单中选择从“EFI Network 2”启动，如图10所示：<br><img src="/etesting/Estuary/Documents/D03/Deploy-manual-for-RP-on-D03/10.png" alt="图10. UEFI - Boot Manager" title="图10. UEFI - Boot Manager"><br>启动至grub菜单，选择“Install CentOS Linux 7 D03 –network”启动，如图11所示：<br><img src="/etesting/Estuary/Documents/D03/Deploy-manual-for-RP-on-D03/11.png" alt="图11. Grub menu" title="图11. Grub menu"><br>接着系统实现PXE方式自动安装，如图12、图13、图14、图15所示：<br><img src="/etesting/Estuary/Documents/D03/Deploy-manual-for-RP-on-D03/12.png" alt="图12 Installing CentOS Linux" title="图12 Installing CentOS Linux"><br><img src="/etesting/Estuary/Documents/D03/Deploy-manual-for-RP-on-D03/13.png" alt="图13 Installing CentOS Linux (Continue)" title="图13 Installing CentOS Linux (Continue)"><br><img src="/etesting/Estuary/Documents/D03/Deploy-manual-for-RP-on-D03/14.png" alt="图14 Installing CentOS Linux (Continue)" title="图14 Installing CentOS Linux (Continue)"><br><img src="/etesting/Estuary/Documents/D03/Deploy-manual-for-RP-on-D03/15.png" alt="图15 Installing CentOS Linux (Continue)" title="图15 Installing CentOS Linux (Continue)"><br>如果网络繁忙，则可能出现如图16所示的情况：<br><img src="/etesting/Estuary/Documents/D03/Deploy-manual-for-RP-on-D03/16.png" alt="图16 Installing CentOS Linux (Continue)" title="图16 Installing CentOS Linux (Continue)"><br>若出现上图所示情况，则重启单板，重复PXE方式安装系统的所有步骤。</p>
<p>系统安装完成后，按回车键退出安装并重启系统。<br>系统默认初始用户名：linaro 密码：linaro</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Armor_Manual.4ALL.md]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/All/Armor_Manual.4All/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">Information of Supported Armor Tools </a></li>
<li><a href="#3">Distributions</a></li>
<li><a href="#4">Installation</a></li>
<li><a href="#5">How to run Tool’s test scripts</a><a id="more"></a>
</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><a name="1">Introduction</a></h2><p>Armor tools supports a list of the platform tools for debug, diagnostics and monitoring and those are available in Open-Estuary Solution.</p>
<p>Current Release Version- <code>armor-v1.1</code></p>
<h2 id="Information-of-Supported-Armor-Tools"><a href="#Information-of-Supported-Armor-Tools" class="headerlink" title="Information of Supported Armor Tools"></a><a name="2">Information of Supported Armor Tools</a></h2><p>For the supported tools in Armor on different distributions, please refer  <a href="https://github.com/open-estuary/estuary/blob/master/doc/Armor_Tools_Supported.4All.md" target="_blank" rel="external">https://github.com/open-estuary/estuary/blob/master/doc/Armor_Tools_Supported.4All.md</a></p>
<p>For the basic information of all the supported Armor tools please refer <a href="https://github.com/open-estuary/estuary/blob/master/doc/Armor_Tools_Basic_Info.4All.md" target="_blank" rel="external">https://github.com/open-estuary/estuary/blob/master/doc/Armor_Tools_Basic_Info.4All.md</a></p>
<p>Documentation for L3 cache event counting support in perf <a href="https://github.com/open-estuary/estuary/blob/master/doc/README.armor.perf.md" target="_blank" rel="external">https://github.com/open-estuary/estuary/blob/master/doc/README.armor.perf.md</a></p>
<p>Documentation for using KGDB and KDB please refer <a href="https://github.com/open-estuary/estuary/blob/master/doc/README.armor.kgdb.kdb.md" target="_blank" rel="external">https://github.com/open-estuary/estuary/blob/master/doc/README.armor.kgdb.kdb.md</a></p>
<p>Documentation for LTTng user space tracing and kernel tracing, please refer <a href="https://github.com/open-estuary/estuary/blob/master/doc/README.armor.lttng.md" target="_blank" rel="external">https://github.com/open-estuary/estuary/blob/master/doc/README.armor.lttng.md</a></p>
<p>Documentation for how to verify iptables tool, please refer <a href="https://github.com/open-estuary/estuary/blob/master/doc/README.armor.iptables.md" target="_blank" rel="external">https://github.com/open-estuary/estuary/blob/master/doc/README.armor.iptables.md</a></p>
<h2 id="Distributions"><a href="#Distributions" class="headerlink" title="Distributions"></a><a name="3">Distributions</a></h2><p>Presently Armor tools are supported on the following distributions.</p>
<ul>
<li>Ubuntu 15.04 ARM64  </li>
<li>Fedora 22 ARM64  </li>
<li>OpenSuse 20150813 Tumbleweed ARM64  </li>
<li>Debian Jessie 8.2 ARM64  </li>
<li>CentOS Linux release 7.2.1511 (AltArch)  </li>
</ul>
<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a><a name="4">Installation</a></h2><ol>
<li>Default Armor tools are installed onto the rootfs during open-estuary build process.  </li>
<li><p>On first time bootup, user must run update commands before try install or run any Armor tool.</p>
<p>Ubuntu: run <code>apt-get -y update</code> command.<br>Fedora: run <code>dnf -y update</code> command.<br>OpenSuse: run <code>zypper -y update</code> command.<br>Debian: run <code>apt-get -y update</code>and <code>apt-get install -f -y</code> commands.<br>CentOS: run <code>yum -y update</code> command.  </p>
</li>
<li>On target board, Run <code>armor_utility</code>, which will provide information of the supported Armor tools, installation status and how to install on the distribution if it is not already present.</li>
</ol>
<h2 id="How-to-run-Tool’s-test-scripts"><a href="#How-to-run-Tool’s-test-scripts" class="headerlink" title="How to run Tool’s test scripts"></a><a name="5">How to run Tool’s test scripts</a></h2><ol>
<li>Go to the <code>/usr/local/armor/test_scripts</code> on the target terminal.  </li>
<li>To test individual tools please run folowing command on the shell terminal, <code>sh test_&lt;tool&#39;s name&gt;.sh</code> -&gt; to run test script of an armor tool.<br> For example, ‘sh test_strace.sh’ to run tests for strace. The test results can be seen on the console.</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Armor_Manual.4ALL.md]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/D02/Deploy_Manual.4D02/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">Preparation</a><ul>
<li><a href="#2.1">Prerequisite</a></li>
<li><a href="#2.2">Check the hardware board</a></li>
<li><a href="#2.3">Upgrade UEFI and trust firmware</a></li>
<li><a href="#2.4">Upgrade DTB file</a></li>
</ul>
</li>
<li><a href="#3">Bring up System</a><ul>
<li><a href="#3.1">Boot via ESL</a></li>
<li><a href="#3.2">Boot via NORFLASH</a></li>
<li><a href="#3.3">Boot via PXE</a></li>
<li><a href="#3.4">Boot via NFS</a></li>
<li><a href="#3.5">Boot via DISK(SAS/USB/SATA) </a></li>
<li><a href="#3.6">Boot via ACPI</a><a id="more"></a>
</li>
</ul>
</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><a name="1">Introduction</a></h2><p>This documentation describes how to get, build, deploy and bring up target system based Estuary Project, it will help you to make your Estuary Environment setup from ZERO.<br>All following sections will take the D02 board as example, other boards have the similar steps to do, for more detail difference between them, please refer to Hardware Boards sections in <a href="http://open-estuary.com/hardware-boards/" target="_blank" rel="external">http://open-estuary.com/hardware-boards/</a>.</p>
<h2 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a><a name="2">Preparation</a></h2><h3 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a><a name="2.1">Prerequisite</a></h3><p><em>Local network</em>: To connect hardware boards and host machine, so that they can communicate each other.<br><em>Serial cable</em>: To connect hardware board’s serial port to host machine, so that you can access the target board’s UART in host machine.</p>
<p>Two methods are provided to <strong>connect the board’s UART port to a host machine</strong>:<br><strong>Method 1</strong> : connect the board’s UART in openlab environment<br>Use <code>board_connect</code> command.(Details please refer to <code>board_connect --help</code>)<br><strong>Method 2</strong> : directly connect the board by UART cable<br>a. Connect the board’s UART port to a host machine with a serial cable.<br>b. Install a serial port application in host machine, e.g.: kermit or minicom.<br>c. Config serial port setting:115200/8/N/1 on host machine.<br>For more details, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/UEFI_Manual.4D02.md" target="_blank" rel="external">UEFI_Manual.md</a> “Upgrade UEFI” chapter.</p>
<h3 id="Check-the-hardware-board"><a href="#Check-the-hardware-board" class="headerlink" title="Check the hardware board"></a><a name="2.2">Check the hardware board</a></h3><p>Hardware board should be ready and checked carefully to make sure it is available, more detail information about different hardware board, please refer to <a href="http://open-estuary.com/d02-2/" target="_blank" rel="external">http://open-estuary.com/d02-2/</a>.</p>
<h3 id="Upgrade-UEFI-and-trust-firmware"><a href="#Upgrade-UEFI-and-trust-firmware" class="headerlink" title="Upgrade UEFI and trust firmware"></a><a name="2.3">Upgrade UEFI and trust firmware</a></h3><p>You can upgrade UEFI and trust firmare yourself based on FTP service, but this is not necessary. If you really want to do it, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/UEFI_Manual.4D02.md" target="_blank" rel="external">UEFI_Manual.md</a>.</p>
<h3 id="Upgrade-DTB-file-Necessary-step"><a href="#Upgrade-DTB-file-Necessary-step" class="headerlink" title="Upgrade DTB file(Necessary step)"></a><a name="2.4">Upgrade DTB file(Necessary step)</a></h3><p> Because this dtb file is important to this D02 boards, firstly you must flash this DTB file into SPI flash before any methods of bringing up systerm.</p>
<p> “EFI internal shell” mode and “Embedded Boot Loader(EBL)” mode often used to upgrade DTB file , about how to enter two modes and how to switch between them, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/UEFI_Manual.4D02.md" target="_blank" rel="external">UEFI_Manual.md</a> “Upgarde UEFI” chapter.</p>
<ol>
<li><p>IP address config at “EFI Internal Shell” mode(Optional, you can ignore this step if DHCP works well)<br>Press any key except “enter” key to enter into UEFI main menu. Select “Boot Manager”-&gt;”EFI Internal Shell”.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Config board's IP address</span></div><div class="line">ifconfig <span class="_">-s</span> eth0 static &lt;IP address&gt; &lt;mask&gt; &lt;gateway&gt;</div></pre></td></tr></table></figure>
<p>e.g. <code>ifconfig -s eth0 static 192.168.1.4 255.255.255.0 192.168.1.1</code></p>
</li>
<li><p>Download dtb file from FTP at “Embedded Boot Loader(EBL)” mode<br>Enter “exit” from “EFI Internal Shell” mode to the UEFI main menu and choose “Boot Manager”-&gt; “Embedded Boot Loader(EBL)”after setting the IP address done. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Download file from FTP server to target board's RAM</span></div><div class="line">provision &lt;server IP&gt; -u &lt;ftp user name&gt; -p &lt;ftp password&gt; <span class="_">-f</span> &lt;dtb file&gt; <span class="_">-a</span> &lt;download target address&gt;</div><div class="line"><span class="comment"># Write data into FLASH</span></div><div class="line">spiwfmem &lt;<span class="built_in">source</span> address&gt; &lt;target address&gt; &lt;data length&gt;</div></pre></td></tr></table></figure>
<p>e.g.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">provision 192.168.1.107 -u sch -p aaa <span class="_">-f</span> hip05<span class="_">-d</span>02.dtb <span class="_">-a</span> 0x100000 </div><div class="line">spiwfmem 0x100000 0x300000 0x100000</div></pre></td></tr></table></figure>
</li>
<li><p>Reboot your D02 board<br>You must reboot your D02 board after above two steps, this new DTB file will be used on booting board.<br>Note: It is necessary to flash the DTB file to SPI flash to solve a known MAC address duplicate Issue. Also it is to be noted that the DTB file should not be input in the Grub config file. So if you wish to use a modified DTB file, then you should always have it flashed to SPI flash before bootup.</p>
</li>
</ol>
<h2 id="Bring-up-System"><a href="#Bring-up-System" class="headerlink" title="Bring up System"></a><a name="3">Bring up System</a></h2><p>There are several methods to bring up system, you can select following anyone fitting you to boot up.</p>
<h3 id="Boot-via-ESL"><a href="#Boot-via-ESL" class="headerlink" title="Boot via ESL"></a><a name="3.1">Boot via ESL</a></h3><p> In this boot mode, the kernel image, dtb file and rootfs file should be downloaded into RAM at first and then start the system by ESL.<br> After reboot or power off, all downloaded data will be lost.<br> This boot mode is just used for debugging.</p>
<p> Boot D02 to UEFI main menu. Select “Boot Manager”-&gt;”Eembedded Boot Loader(EBL)” and type the follow commands in EBL:</p>
<ol>
<li><p>Download Image binary file from FTP server to target board’s RAM</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Download Image binary file from FTP server to target board's RAM</span></div><div class="line">provision &lt;server IP&gt; -u &lt;ftp user name&gt; -p &lt;ftp password&gt; <span class="_">-f</span> &lt;Image binary file&gt; <span class="_">-a</span> &lt;download target address&gt;</div></pre></td></tr></table></figure>
<p>e.g.  <code>provision 192.168.1.107 -u sch -p aaa -f Image -a 0x80000</code></p>
</li>
<li><p>Download dtb file from FTP server to target board’s RAM</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Download dtb file from FTP server to target board's RAM</span></div><div class="line">provision &lt;server IP&gt; -u &lt;ftp user name&gt; -p &lt;ftp password&gt; <span class="_">-f</span> &lt;dtb file&gt; <span class="_">-a</span> &lt;download target address&gt;</div></pre></td></tr></table></figure>
<p>e.g. <code>provision 192.168.1.107 -u sch -p aaa -f hip05-d02.dtb -a 0x06000000</code></p>
</li>
<li><p>Download rootfs file from FTP server to target board’s RAM</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Download rootfs file from FTP server to target board's RAM</span></div><div class="line">provision &lt;server IP&gt; -u &lt;ftp user name&gt; -p &lt;ftp password&gt; <span class="_">-f</span> &lt;rootfs file&gt; <span class="_">-a</span> &lt;download target address&gt;</div></pre></td></tr></table></figure>
<p>e.g. <code>provision 192.168.1.107 -u sch -p aaa -f mini-rootfs-arm64.cpio.gz -a 0x07000000</code></p>
</li>
<li><p>Start operating system<br>Type “exit” to exit EBL. Select “Boot Manager”-&gt;”ESL Start OS” menu to start operating system.</p>
</li>
</ol>
<h3 id="Boot-via-NORFLASH"><a href="#Boot-via-NORFLASH" class="headerlink" title="Boot via NORFLASH"></a><a name="3.2">Boot via NORFLASH</a></h3><p>In this boot mode, kernel image, dtb file and rootfs file will be writen into NORFLASH. Before the kernel start, the kernel image, dtb fille and rootfs file will be loaded into RAM from NORFLASH.<br>Boot D02 to UEFI main menu. Select “Boot Manager”-&gt;”Eembedded Boot Loader(EBL)” and type the follow commands in EBL:</p>
<ol>
<li><p>Download Image binary file from FTP  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Download file from FTP server to target board's RAM</span></div><div class="line">provision &lt;server IP&gt; -u &lt;ftp user name&gt; -p &lt;ftp password&gt; <span class="_">-f</span> &lt;kernel image file&gt; <span class="_">-a</span> &lt;download target address&gt;</div><div class="line"><span class="comment"># Write data into NORFLASH</span></div><div class="line">norwfmem &lt;<span class="built_in">source</span> address&gt; &lt;target address&gt; &lt;data length&gt;</div></pre></td></tr></table></figure>
<p>e.g.:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">provision 192.168.1.107 -u sch -p aaa <span class="_">-f</span> Image <span class="_">-a</span> 0x100000</div><div class="line">norwfmem 0x100000 0x100000 0x1f00000</div></pre></td></tr></table></figure>
</li>
<li><p>Download rootfs file from FTP  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Download file from FTP server to target board's RAM</span></div><div class="line">provision &lt;server IP&gt; -u &lt;ftp user name&gt; -p &lt;ftp password&gt; <span class="_">-f</span> &lt;rootfs image&gt; <span class="_">-a</span> &lt;download target address&gt;</div><div class="line"><span class="comment"># Write data into NORFLASH</span></div><div class="line">norwfmem &lt;<span class="built_in">source</span> address&gt; &lt;target address&gt; &lt;data length&gt;</div></pre></td></tr></table></figure>
<p>e.g.:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">provision 192.168.1.107 -u sch -p aaa <span class="_">-f</span> mini-rootfs-arm64.cpio.gz <span class="_">-a</span> 0x100000</div><div class="line">norwfmem 0x100000 0x2000000 0x4000000</div></pre></td></tr></table></figure>
</li>
<li><p>Reboot D02 and press anykey except “enter” to enter UEFI Boot Menu  </p>
</li>
<li><p>Select “Boot Manager”-&gt;”FLASH Start OS” boot option and press “Enter”  </p>
</li>
</ol>
<p>To get all binaries mentioned above, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Readme.4D02.md" target="_blank" rel="external">Readme.md</a>.</p>
<h3 id="Boot-via-PXE"><a href="#Boot-via-PXE" class="headerlink" title="Boot via PXE"></a><a name="3.3">Boot via PXE</a></h3><p>In this boot mode, the UEFI will get grub from PXE server.<br>The grub will get the configuration file from TFTP service configured by PXE server.  </p>
<ol>
<li>Setup PXE environment on host<br>Enable both DHCP and TFTP services on one of your host machines according to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Setup_PXE_Env_on_Host.4All.md" target="_blank" rel="external">Setup_PXE_Env_on_Host.md</a>.  </li>
<li>Reboot and press anykey except “enter” to enter UEFI main Menu  </li>
<li>Select “Boot Manager”-&gt;”EFI Network” and press “Enter”.  </li>
<li>After several seconds, D02 will boot by PXE automatically.</li>
</ol>
<p>To config the grub.cfg to support PXE boot, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Grub_Manual.4All.md" target="_blank" rel="external">Grub_Manual.md</a>.</p>
<h3 id="Boot-via-NFS"><a href="#Boot-via-NFS" class="headerlink" title="Boot via NFS"></a><a name="3.4">Boot via NFS</a></h3><p>In this boot mode, the root parameter in grub.cfg menuentry will set to /dev/nfs and nfsroot will be set to the path of rootfs on NFS server. You can use <code>&quot;showmount -e &lt;server ip address&gt;&quot;</code> to list the exported NFS directories on the NFS server. You can use “showmount -e <server ip="" address="">“ to list the exported NFS directories on the NFS server.<br>D02 supports booting via NFS, you can try it as following steps:  </server></p>
<ol>
<li>Enable DHCP, TFTP and NFS service according to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Setup_PXE_Env_on_Host.4All.md" target="_blank" rel="external">Setup_PXE_Env_on_Host.md</a>.  </li>
<li>Get and config grub file to support NFS boot according to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Grub_Manual.4All.md" target="_blank" rel="external">Grub_Manual.md</a>.  </li>
<li>Reboot D02 and press anykey except “enter” to enter UEFI main Menu  </li>
<li>Select  “Boot Manager”-&gt;”EFI Network” to and press enter key.</li>
</ol>
<h3 id="Boot-via-DISK-SAS-USB-SATA"><a href="#Boot-via-DISK-SAS-USB-SATA" class="headerlink" title="Boot via DISK(SAS/USB/SATA)"></a><a name="3.5">Boot via DISK(SAS/USB/SATA)</a></h3><p>D02 board supports booting via SAS and USB disk by default, if you want to boot via SATA, there are two different methods for you, one is to plug SATA disk into PCIE-to-SATA convert card(model:PEC-2024) which connect to D02 board, another is to connect SATA disk into SATA interface on D02 board directly. Usually the first is more stable than the second, so we suggest you to use the first method.<br>For SAS and USB, the UEFI will directly get the grub from the EFI system partition on the hard disk. The grub will load the grub configuration file from the EFI system partition. So grubaa64.efi, grub.cfg, Image and different estuary release distributions are stored on disk. But for SATA boot mode, the kernel image will be loaded from NORFLASH into RAM on target board. The root parameter passed to the kernel will be specified in hip05-d02.dts and it will point to the root partition on SATA disk.</p>
<ol>
<li><p>Boot by PXE or NORFLASH(please refer to “#Boot via PXE” or “#Boot via NORFLASH”) to part and format hardware disk before booting D02 board<br>Format hardware disk, e.g.:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo mkfs.vfat /dev/sda1</div><div class="line">sudo mkfs.ext4 /dev/sda2</div></pre></td></tr></table></figure>
<p>Part hardware disk with <code>&quot;sudo fdisk /dev/sda&quot; as follow:</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+---------+-----------+--------------+------------------+------------------+</div><div class="line">| Name    |   Size    |    Type      |   USB/SAS        |   SATA           |</div><div class="line">+---------+-----------+--------------+------------------+------------------+</div><div class="line">| sda1    |   200M    |  EFI system  |   EFI            |    NULL          |</div><div class="line">+---------+-----------+--------------+------------------+------------------+</div><div class="line">| sda2    |   10G     |    ext4      | linux filesystem | linux filesystem |</div><div class="line">+---------+-----------+--------------+------------------+------------------+</div><div class="line">| sda3    |   10G     |    ext4      | linux filesystem | linux filesystem |</div><div class="line">+---------+-----------+--------------+------------------+------------------+</div><div class="line">| sda4    |   10G     |    ext4      | linux filesystem | linux filesystem |</div><div class="line">+---------+-----------+--------------+------------------+------------------+</div><div class="line">| sda5    |rest space |    ext4      | linux swap       | linux swap       |</div><div class="line">+---------+-----------+--------------+------------------+------------------+</div></pre></td></tr></table></figure>
<p>Note: EFI partition must be a fat filesystem, so you should format sda1 with “sudo mkfs.vfat /dev/sda1″.</p>
<p><em>Preprocess when the disk can’t be identified</em><br> In case of the SATA disk is not be identified by D02, you can try the following step to process the disk. (it can be useful for some specfic disk such as seagate disk made by samsung).  </p>
<p>a. Find a PC or another board which can identify SATA disk.<br>You should find a PC or another board which can identify this disk, and the system of PC or board should be linux system. For us,we can use D01 board.<br>b. Use tool fdisk to process this disk</p>
<p>format the disk firstly: <code>sudo mkfs.ext4 /dev/sda</code></p>
<p>add a gpt to this disk :<br><code>fdisk /dev/sda</code><br><code>g</code>——-add a gpt partition</p>
<p>add some EFI partition :<br><code>n</code>——-add a partition<br><code>1</code>——-the number of partition</p>
<p>type “Enter” key —— First sector<br><code>+200M</code>———Last sector, size of partition<br><code>t</code>——-change the type of partition to  EFI system</p>
<p>add some anther partition <code>...</code><br>save the change: <code>w</code></p>
<p>format EFI partition: <code>sudo mkfs.vfat /dev/sda1</code></p>
<p>Then this disk can be identified by D02 board.</p>
</li>
<li><p>Download files and store them into hardware disk as below:<br>(SAS/USB）Related files are placed as follow:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sda1: -------EFI</div><div class="line">      |       |</div><div class="line">      |      GRUB2------grubaa64.efi  //grub binary file</div><div class="line">      |</div><div class="line">      |-------------grub.cfg           //grub config file</div><div class="line">      |</div><div class="line">      |-------------Image          //kernel binary Image</div><div class="line">sda2: Ubuntu distribution</div><div class="line">sda3: Fedora distribution</div></pre></td></tr></table></figure>
<p>NOTE: The grubaa64.efi file must be put in /EFI/GRUB2 directory of dev/sda1(gpt partition), the distributions could be uncompressed in dev/sdaX(X can be 2,3,4,etc. exclude 1).</p>
<p>(SATA)Related files are placed as follow:</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">sda1: -------NULL</div><div class="line">sda2: Ubuntu distribution</div><div class="line">sda3: OpenSUSE distribution</div></pre></td></tr></table></figure>
<p> To get kernel image and dtb file, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Readme.4D02.md" target="_blank" rel="external">Readme.md</a>.<br> To get and config grub and grub.cfg, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Grub_Manual.4All.md" target="_blank" rel="external">Grub_Manual.md</a>.<br> To get different distributions, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Distributions_Guide.4All.md" target="_blank" rel="external">Distributions_Guider.md</a>.  </p>
</li>
<li>Boot the board via SAS/USB/SATA</li>
</ol>
<p><strong>Boot via SAS/USB</strong></p>
<p>a. modify grub config file (<a href="https://github.com/open-estuary/estuary/blob/master/doc/Grub_Manual.4All.md" target="_blank" rel="external">https://github.com/open-estuary/estuary/blob/master/doc/Grub_Manual.4All.md</a>)</p>
<p>   e.g.: the context of grub.cfg file is modified as follow:<br>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Sample GRUB configuration file</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Boot automatically after 5 secs.</span></div><div class="line"><span class="built_in">set</span> timeout=5</div><div class="line"><span class="comment"># By default, boot the Estuary with Ubuntu filesystem</span></div><div class="line"><span class="built_in">set</span> default=ubuntu</div><div class="line"><span class="comment"># For booting GNU/Linux</span></div><div class="line"></div><div class="line">menuentry <span class="string">"ubuntu"</span> --id ubuntu &#123;</div><div class="line">search --no-floppy --fs-uuid --set=root &lt;UUID&gt;</div><div class="line">linux /Image rdinit=/init pcie_aspm=off root=PARTUUID=&lt;PARTUUID&gt; rootwait rootfstype=ext4 rw console=ttyS0,115200 earlycon=uart8250,mmio32,0x80300000 ip=dhcp</div><div class="line">      &#125;</div></pre></td></tr></table></figure></p>
<p>   Note:  </p>
<ol>
<li><code>&lt;UUID&gt;</code> means the UUID of that partition which your EFI System is located in.<br><code>&lt;PARTUUID&gt;</code> means the PARTUUID of that partition which your linux distribution is located in.<br>To see the values of UUID and PARTUUID, please use the command:<code>$blkid</code>.  </li>
<li>If you want to use another linux distribution, please refer above steps.</li>
</ol>
<p>b. Reboot and press any key except “enter” into enter UEFI menu.<br>c. For USB: Select “Boot Manager”-&gt; “EFI USB Device”-&gt; to enter grub selection menu.<br>   For SAS: Select “Boot Manager”-&gt; “EFI Misc Device 1” to enter grub selection menu.<br>d. Press arrow key up or down to select grub boot option to decide which distribution should boot.</p>
<p><strong>Boot via SATA</strong></p>
<p>In this boot mode, there are two different methods for you, one is to plug SATA disk into PCIE-to-SATA convert card(model:PEC-2024) which connect to D02 board,another is to connect SATA disk into SATA interface on D02 board directly.</p>
<p><strong>The first one: to plug SATA disk into PCIE-to-SATA convert card(model:PEC-2024) which connect to D02 board</strong></p>
<p>a. Build kernel(please refer to [Readme.4D02.md] (<a href="https://github.com/open-estuary/estuary/blob/master/doc/Readme.4D02.md" target="_blank" rel="external">https://github.com/open-estuary/estuary/blob/master/doc/Readme.4D02.md</a>))<br>   Modify arch/arm64/boot/dts/hisilicon/hip05-d02.dts file as follow:<br>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bootargs = <span class="string">"rdinit=/init pcie_aspm=off root=/dev/sda2 rootdelay=10 rootfstype=ext4 rw console=ttyS0,115200 earlycon=uart8250,mmio32,0x80300000 ip=dhcp"</span></div></pre></td></tr></table></figure></p>
<p>   After build the linux kernel from source, burn Image into Nor Flash and dtb file into SPI Flash. About how to burn Image and dtb file , please refer to “Boot via NORFLASH” and “Upgrade DTB file”.</p>
<p>   NOTE: according to above bootargs, it will boot ubuntu distribution in sda2, if you want to boot other different distribution, you should change “root=/dev/sdaX” item.<br>b. Reboot and press any key into enter UEFI menu.<br>c. Select “Boot Manager”-&gt;”FLASH Start OS” and then press Enter Key.</p>
<p><strong>The second one: to connect SATA disk into SATA interface on D02 board directly</strong></p>
<p>a. select sata mode for UEFI<br>   After burn BIOS file(you can refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/UEFI_Manual.4D02.md" target="_blank" rel="external">UEFI_Manual.4D02.md</a>), UEFI boot as sas mode by default.<br>   You can switch between sata and sas by adding a commandline at EBL.<br>   e.g.:<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sataenable 0      //set into sas</div><div class="line">sataenable 1      //set into sata</div><div class="line">sataenable 2      //check the current setting: sas or sata</div></pre></td></tr></table></figure></p>
<p>b. Modify arch/arm64/boot/dts/hisilicon/hip05-d02.dts file</p>
<ul>
<li><p>Find the word “bootargs” and modify the value as follow:  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bootargs = <span class="string">"rdinit=/init pcie_aspm=off root=/dev/sda2 rootdelay=10 rootfstype=ext4 rw console=ttyS0,115200 earlycon=uart8250,mmio32,0x80300000 ip=dhcp"</span></div></pre></td></tr></table></figure>
</li>
<li><p>Find the word “&amp;sas0”, “&amp;sas1” and delete as follow:<br> <del>&amp;sas0 {</del><br> <del>status = “okay”;</del>,<br> <del>};</del><br><del>&amp;sas1 {</del><br> <del>status = “okay”;</del><br> <del>};</del>  </p>
</li>
</ul>
<p>c. Modify arch/arm64/boot/dts/hisilicon/hip05.dtsi file</p>
<p>   Change the status’ value of node “ahci0: sata@b1002800” to “disabled” as follow:<br>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ahci0: sata@b1002800 &#123;</div><div class="line">         ......</div><div class="line">status = <span class="string">"disabled"</span>;      ---------&gt; status = <span class="string">"okay"</span>;</div><div class="line">     &#125;;</div></pre></td></tr></table></figure></p>
<p>d. Build the kernel (please refer to [Readme.4D02.md] (<a href="https://github.com/open-estuary/estuary/blob/master/doc/Readme.4D02.md" target="_blank" rel="external">https://github.com/open-estuary/estuary/blob/master/doc/Readme.4D02.md</a>))<br>e. Burn Image, dtb file NorFlash. About how to burn, please refer to “Boot via NORFLASH”.<br>f. Reboot and press any key except “enter” to enter UEFI menu.<br>g. Select “Boot Manager”-&gt;”FLASH Start OS” and then press Enter Key.</p>
<h3 id="Boot-via-ACPI"><a href="#Boot-via-ACPI" class="headerlink" title="Boot via ACPI"></a><a name="3.6">Boot via ACPI</a></h3><p>D02 also supports booting via ACPI, you can bring up this system which is similar with DTS mode, you must fix some point as follow:  </p>
<ul>
<li><p>Delete DTB file(comment out devicetree /<user>/hip05-d02.dtb as follow) and don’t burn DTB file<br> e.g.:  </user></p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">menuentry <span class="string">"D02 Ubuntu NFS"</span> --id d02_ubuntu_nfs &#123;</div><div class="line"><span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">linux /Image rdinit=/init pcie_aspm=off console=ttyS0,115200 earlycon=uart8250,mmio32,0x80300000 root=/dev/nfs rw nfsroot=192.168.1.107:/home/ftp/user/rootfs_ubuntu64 ip=dhcp</div><div class="line"><span class="comment"># devicetree /&lt;user&gt;/hip05-d02.dtb</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Set the parameters of booting via ACPI<br> you must add <code>&quot;acpi=force&quot;</code> property in <code>&quot;linux&quot;</code> line for “grub.cfg” file. If not, system will booted up with DTS by default.<br> e.g.:  </p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Booting from NFS with Ubuntu rootfs</span></div><div class="line">menuentry <span class="string">"D02 Ubuntu NFS(ACPI)"</span> --id d02_ubuntu_nfs_acpi &#123;</div><div class="line"><span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">linux /Image rdinit=/init pcie_aspm=off console=ttyS0,115200 earlycon=uart8250,mmio32,0x80300000 root=/dev/nfs rw nfsroot=192.168.1.107:/home/ftp/user/rootfs_ubuntu64 ip=dhcp acpi=force</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>NOTE: you can get more information about setting grub.cfg from <a href="https://github.com/open-estuary/estuary/blob/master/doc/Grub_Manual.4All.md" target="_blank" rel="external">Grub_Manual.md</a>.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Grub_Manual.4ALL]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/Grub_Manual.4All/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">Grub config file</a></li>
<li><a href="#3">files structure bootable partition</a></li>
<li><a href="#4">FAQ</a><a id="more"></a>
</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><a name="1">Introduction</a></h2><p>Grub is a kind of boot loader to load kernel into RAM and run it.</p>
<p>After rebooting board every time, the UEFI will firstly try to download the grub binary and run it firstly.</p>
<p>Then grub binary will load the kernel and start it with cmdline and dtb file according to the configurations in <code>grub.cfg</code>.</p>
<p>They include:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grubaa64.efi    <span class="comment"># The grub binary executable program for ARM64 architecture</span></div><div class="line">grubarm32.efi   <span class="comment"># The grub binary executable program for ARM32 architecture</span></div><div class="line">grub.cfg        <span class="comment"># The grub config file which will be used by grub binary</span></div></pre></td></tr></table></figure></p>
<p>Where to get them, please refer to Readme.txt.</p>
<h2 id="Grub-config-file"><a href="#Grub-config-file" class="headerlink" title="Grub config file"></a><a name="2">Grub config file</a></h2><p>You can edit a <code>grub.cfg</code> file to support various boot mode or multi boot partitions, follow is an example.</p>
<p>You should change them acoording to your real local environment.</p>
<p><strong><em>Note: D05 only supports booting system via ACPI mode with Centos.</em></strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Sample GRUB configuration file</span></div><div class="line"><span class="comment">#</span></div><div class="line"></div><div class="line"><span class="comment"># Boot automatically after 0 secs.</span></div><div class="line"><span class="built_in">set</span> timeout=5</div><div class="line"></div><div class="line"><span class="comment"># By default, boot the Euler/Linux</span></div><div class="line"><span class="built_in">set</span> default=d05_centos_nfs_acpi</div><div class="line"></div><div class="line">menuentry <span class="string">"D05 minilinux PXE(ACPI)"</span> --id d05_minilinux_pxe_acpi &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">    linux /Image acpi=force pcie_aspm=off rdinit=/init crashkernel=256M@32M console=ttyAMA0,115200 earlycon=pl011,mmio,0x602B0000 ip=dhcp</div><div class="line">    initrd /mini-rootfs-arm64.cpio.gz</div><div class="line">&#125;</div><div class="line"></div><div class="line">menuentry <span class="string">"D05 Centos NFS(ACPI)"</span> --id d05_centos_nfs_acpi &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">    linux /Image acpi=force pcie_aspm=off rdinit=/init crashkernel=256M@32M console=ttyAMA0,115200 earlycon=pl011,mmio,0x602B0000 root=/dev/nfs rw nfsroot=192.168.1.107:/home/hisilicon/ftp/centos ip=dhcp</div><div class="line">&#125;</div><div class="line"></div><div class="line">menuentry <span class="string">"D05 Centos SATA(ACPI)"</span> --id d05_centos_sata_acpi&#123;</div><div class="line">    search --no-floppy --fs-uuid --set=root &lt;UUID&gt;</div><div class="line">    linux /Image acpi=force pcie_aspm=off rdinit=/init crashkernel=256M@32M console=ttyAMA0,115200 earlycon=pl011,mmio,0x602B0000 root=PARTUUID=&lt;PARTUUID&gt; rootwait rootfstype=ext4 rw ip=dhcp</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># Booting from PXE with mini rootfs</span></div><div class="line">menuentry <span class="string">"D03 minilinux PXE"</span> --id d03_minilinux_pxe &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off crashkernel=256M@32M rdinit=/init console=ttyS0,115200 earlycon=hisilpcuart,mmio,0xa01b0000,0,0x2f8 ip=dhcp</div><div class="line">    initrd /mini-rootfs-arm64.cpio.gz</div><div class="line">&#125;</div><div class="line"></div><div class="line">menuentry <span class="string">"D03 Ubuntu NFS"</span> --id d03_ubuntu_nfs &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off console=ttyS0,115200 earlycon=hisilpcuart,mmio,0xa01b0000,0,0x2f8 root=/dev/nfs rw nfsroot=192.168.1.107:/home/ftp/user/rootfs_ubuntu64 ip=dhcp</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># Booting from SATA with Ubuntu rootfs in /dev/sda2</span></div><div class="line">menuentry <span class="string">"D03 Ubuntu SATA"</span> --id d03_ubuntu_sata &#123;</div><div class="line">    <span class="built_in">set</span> root=(hd1,gpt1)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off root=/dev/sda2 rootfstype=ext4 rw console=ttyS0,115200 earlycon=hisilpcuart,mmio,0xa01b0000,0,0x2f8 ip=dhcp</div><div class="line">&#125;</div><div class="line"></div><div class="line">menuentry <span class="string">"D03 minilinux PXE(ACPI)"</span> --id d03_minilinux_pxe_acpi &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off crashkernel=256M@32M rdinit=/init console=ttyS0,115200 earlycon=hisilpcuart,mmio,0xa01b0000,0,0x2f8 ip=dhcp acpi=force</div><div class="line">    initrd /mini-rootfs-arm64.cpio.gz</div><div class="line">&#125;</div><div class="line"></div><div class="line">menuentry <span class="string">"D03 Ubuntu NFS(ACPI)"</span> --id d03_ubuntu_nfs_acpi &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off console=ttyS0,115200 earlycon=hisilpcuart,mmio,0xa01b0000,0,0x2f8 root=/dev/nfs rw nfsroot=192.168.1.107:/home/ftp/user/rootfs_ubuntu64 ip=dhcp acpi=force</div><div class="line">&#125;</div><div class="line"></div><div class="line">menuentry <span class="string">"D03 Ubuntu SATA(ACPI)"</span> --id d03_ubuntu_sata_acpi &#123;</div><div class="line">    <span class="built_in">set</span> root=(hd1,gpt1)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off root=/dev/sda2 rootfstype=ext4 rw console=ttyS0,115200 earlycon=hisilpcuart,mmio,0xa01b0000,0,0x2f8 ip=dhcp acpi=force</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># Booting from eMMC with mini rootfs</span></div><div class="line">menuentry <span class="string">"HiKey minilinux eMMC"</span> --id HiKey_minilinux_eMMC &#123;</div><div class="line">    linux /Image_HiKey rdinit=/init console=tty0 console=ttyAMA3,115200 rootwait rw loglevel=8 efi=noruntime</div><div class="line">    initrd /mini-rootfs.cpio.gz</div><div class="line">    devicetree /hi6220-hikey.dtb</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># Booting from eMMC with Ubuntu</span></div><div class="line">menuentry <span class="string">"HiKey Ubuntu eMMC"</span> --id HiKey_Ubuntu_eMMC &#123;</div><div class="line">    linux /Image_HiKey rdinit=/init console=tty0 console=ttyAMA3,115200 root=/dev/mmcblk0p9 rootwait rw loglevel=8 efi=noruntime</div><div class="line">    devicetree /hi6220-hikey.dtb</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># Booting from SD card with Ubuntu</span></div><div class="line">menuentry <span class="string">"HiKey Ubuntu SD card"</span> --id HiKey_Ubuntu_SD &#123;</div><div class="line">    linux /Image_HiKey rdinit=/init console=tty0 console=ttyAMA3,115200 root=/dev/mmcblk1p1 rootwait rw loglevel=8 efi=noruntime</div><div class="line">    devicetree /hi6220-hikey.dtb</div><div class="line">&#125;</div><div class="line"></div><div class="line">menuentry <span class="string">'HiKey Fastboot mode'</span> &#123;</div><div class="line">    chainloader (hd0,gpt6)/fastboot.efi</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># Booting from PXE with mini rootfs</span></div><div class="line">menuentry <span class="string">"D02 minilinux PXE"</span> --id d02_minilinux_pxe &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off crashkernel=256M@32M console=ttyS0,115200 earlycon=uart8250,mmio32,0x80300000 ip=dhcp</div><div class="line">    initrd /mini-rootfs.cpio.gz</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># Booting from NFS with Ubuntu rootfs</span></div><div class="line">menuentry <span class="string">"D02 Ubuntu NFS"</span> --id d02_ubuntu_nfs &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off console=ttyS0,115200 earlycon=uart8250,mmio32,0x80300000 root=/dev/nfs rw nfsroot=192.168.1.107:/home/ftp/user/rootfs_ubuntu64 ip=dhcp</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># Booting from SATA with Ubuntu rootfs in /dev/sda2</span></div><div class="line">menuentry <span class="string">"D02 Ubuntu SATA"</span> --id d02_ubuntu_sata &#123;</div><div class="line">    <span class="built_in">set</span> root=(hd1,gpt1)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off root=/dev/sda2 rootfstype=ext4 rw console=ttyS0,115200 earlycon=uart8250,mmio32,0x80300000 ip=dhcp</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># Booting from SATA with Fedora rootfs in /dev/sda3</span></div><div class="line">menuentry <span class="string">"D02 Fedora SATA"</span> --id d02_fedora_sata &#123;</div><div class="line">    <span class="built_in">set</span> root=(hd1,gpt1)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off root=/dev/sda3 rootfstype=ext4 rw console=ttyS0,115200 earlycon=uart8250,mmio32,0x80300000 ip=dhcp</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># Booting from PXE with mini rootfs</span></div><div class="line">menuentry <span class="string">"D02 minilinux PXE(ACPI)"</span> --id d02_minilinux_pxe_acpi &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off crashkernel=256M@32M console=ttyS0,115200 earlycon=uart8250,mmio32,0x80300000 ip=dhcp acpi=force</div><div class="line">    initrd /mini-rootfs.cpio.gz</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># Booting from NFS with Ubuntu rootfs</span></div><div class="line">menuentry <span class="string">"D02 Ubuntu NFS(ACPI)"</span> --id d02_ubuntu_nfs_acpi &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off console=ttyS0,115200 earlycon=uart8250,mmio32,0x80300000 root=/dev/nfs rw nfsroot=192.168.1.107:/home/ftp/user/rootfs_ubuntu64 ip=dhcp acpi=force</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># Booting from SATA with Ubuntu rootfs in /dev/sda2</span></div><div class="line">menuentry <span class="string">"D02 Ubuntu SATA(ACPI)"</span> --id d02_ubuntu_sata_acpi &#123;</div><div class="line">    <span class="built_in">set</span> root=(hd1,gpt1)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off root=/dev/sda2 rootfstype=ext4 rw console=ttyS0,115200 earlycon=uart8250,mmio32,0x80300000 ip=dhcp acpi=force</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># Booting from Norflash with mini rootfs</span></div><div class="line">menuentry <span class="string">"D01 minilinux Norflash"</span> --id d01_minilinux_nor &#123;</div><div class="line">    devicetree (hd0,msdos1)/hip04<span class="_">-d</span>01.dtb</div><div class="line">    linux (hd0,msdos1)/zImage_D01 console=ttyS0,115200 earlyprintk initrd=0x10d00000,0x1800000 rdinit=/linuxrc ip=dhcp</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># Booting from SATA with Ubuntu rootfs in /dev/sda4</span></div><div class="line">menuentry <span class="string">"D01 Ubuntu SATA"</span> --id d01_ubuntu_sata &#123;</div><div class="line">    devicetree (hd0,msdos1)/hip04<span class="_">-d</span>01.dtb</div><div class="line">    linux (hd0,msdos1)/zImage_D01 console=ttyS0,115200 earlyprintk root=/dev/sda4 rootfstype=ext4 rw ip=dhcp</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># Booting from SATA with OpenSuse rootfs in /dev/sda5</span></div><div class="line">menuentry <span class="string">"D01 OpenSuse"</span> --id d01_opensuse_sata &#123;</div><div class="line">    devicetree (hd0,msdos1)/hip04<span class="_">-d</span>01.dtb</div><div class="line">    linux (hd0,msdos1)/zImage_D01 console=ttyS0,115200 earlyprintk root=/dev/sda5 rootfstype=ext4 rw ip=dhcp</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment"># Booting from NFS with Ubuntu rootfs</span></div><div class="line">menuentry <span class="string">"D01 Ubuntu NFS"</span> --id d01_ubuntu_nfs &#123;</div><div class="line">    devicetree (hd0,msdos1)/hip04<span class="_">-d</span>01.dtb</div><div class="line">    linux (hd0,msdos1)/zImage_D01 console=ttyS0,115200 earlyprintk rootfstype=nfsroot root=/dev/nfs rw nfsroot=192.168.1.107:/home/ftp/user/rootfs_ubuntu32 ip=dhcp</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>Note: You should only select the parts from above sample which are suitable for your real situation.</p>
<h2 id="files-structure-bootable-partition"><a href="#files-structure-bootable-partition" class="headerlink" title="files structure bootable partition"></a><a name="3">files structure bootable partition</a></h2><p>Normally they are placed into bootable partition as following structure.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-------EFI</div><div class="line">|       |</div><div class="line">|       GRUB2------grubaa64.efi   <span class="comment"># grub binary file only for ARM64 architecture</span></div><div class="line">|           |</div><div class="line">|           |</div><div class="line">|            ------grubarm32.efi  <span class="comment"># grub binary file only for ARM32 architecture</span></div><div class="line">|</div><div class="line">|-------------grub.cfg            <span class="comment"># grub config file</span></div><div class="line">|</div><div class="line">|-------------Image               <span class="comment"># kernel Image file only for D02 platform</span></div><div class="line"></div><div class="line">|-------------zImage_D01          <span class="comment"># kernel zImage file only for D01 platform</span></div><div class="line">|</div><div class="line">|-------------hip04<span class="_">-d</span>01.dtb       <span class="comment"># kernel data tree binary file only for D01 platform</span></div></pre></td></tr></table></figure></p>
<p>Note: In case of booting by PXE mode:</p>
<ol>
<li>The grub binary and <code>grub.cfg</code> files must be placed in the TFTP root directory.</li>
<li>The names and positions of kernel image and dtb must be consistent with the corresponding grub config file.</li>
<li>The grub binary name (<code>grubxxx.efi</code>) must be consistent with the “filename” in <code>/etc/dhcp/dhcpd.conf</code>, for more detail, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Setup_PXE_Env_on_Host.4All.md" target="_blank" rel="external">Setup_PXE_Env_on_Host.md</a></li>
<li>If you use D02 board, you should not input DTB in the <code>grub.cfg</code> but you must flash the DTB file into spiflash to avoid a known Mac address duplicate issue.</li>
</ol>
<p>You can get more information from the <code>Deploy_Manual.md</code> guide.</p>
<h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a><a name="4">FAQ</a></h2><p>If you want to modify <code>grub.cfg</code> command line temporarily. Type “E” key into grub modification menu. You will face problem that the “backspace” key not woking properly. You can fix backspace issue by changing terminal emulator’s configuration.</p>
<p><strong>For gnome-terminal</strong>: Open “Edit” menu, select “Profile preferences”.<br>In “Compatibility” page, select “Control-H” in “Backspace key generates” listbox.<br><strong>For Xterm</strong>: press Ctrl key and left botton of mouse, and toggle on “Backarrow key (BS/DEL)” in mainMenu.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Setup_PXE_Env_on_Host.4All.md]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/All/Setup_PXE_Env_on_Host.4All/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">Setup DHCP server on Ubuntu</a></li>
<li><a href="#3">Setup TFTP server on Ubuntu</a></li>
<li><a href="#4">Put files in the TFTP root path</a></li>
<li><a href="#5">Setup NFS server on Ubuntu</a></li>
</ul>
<a id="more"></a>
<p>This is a guide to setup a PXE environment on host machine.</p>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><a name="1">Introduction</a></h3><p>PXE boot depends on DHCP, TFTP and NFS services. So before verifing PXE, you need to setup a working DHCP, TFTP, NFS server on one of your host machine in local network. In this case, my host OS is Ubuntu 12.04.</p>
<h3 id="Setup-DHCP-server-on-Ubuntu-lt-a"><a href="#Setup-DHCP-server-on-Ubuntu-lt-a" class="headerlink" title="Setup DHCP server on Ubuntu&lt;/a"></a><a name="2">Setup DHCP server on Ubuntu&lt;/a</a></h3><p>Refer to https://help.ubuntu.com/community/isc-dhcp-server . For a simplified direction, try these steps:</p>
<ul>
<li><p>Install DHCP server package</p>
<p><code>sudo apt-get install -y isc-dhcp-server syslinux</code></p>
</li>
<li><p>Edit /etc/dhcp/dhcpd.conf to suit your needs and particular configuration.<br>Make sure filename is consistent with the file in tftp root directory.<br>Here is an example: This will enable board to load “grubaa64.efi” from TFTP root to target board and run it, when you boot from PXE in UEFI Boot Menu. </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/dhcp/dhcpd.conf</div><div class="line"><span class="comment"># Sample /etc/dhcpd.conf</span></div><div class="line"><span class="comment"># (add your comments here)</span></div><div class="line">default-lease-time 600;</div><div class="line">max-lease-time 7200;</div><div class="line">subnet 192.168.1.0 netmask 255.255.255.0 &#123;</div><div class="line">    range 192.168.1.210 192.168.1.250;</div><div class="line">    option subnet-mask 255.255.255.0;</div><div class="line">    option domain-name-servers 192.168.1.1;</div><div class="line">    option routers 192.168.1.1;</div><div class="line">    option subnet-mask 255.255.255.0;</div><div class="line">    option broadcast-address 192.168.1.255;</div><div class="line">    <span class="comment"># Change the filename according to your real local environment and target board type.</span></div><div class="line">    <span class="comment"># And make sure the file has been put in tftp root directory.</span></div><div class="line">    <span class="comment"># grubaa64.efi is for ARM64 architecture.</span></div><div class="line">    <span class="comment"># grubarm32.efi is for ARM32 architecture.</span></div><div class="line">    filename <span class="string">"grubaa64.efi"</span>;</div><div class="line">    <span class="comment">#filename "grubarm32.efi";</span></div><div class="line">    <span class="comment">#next-server 192.168.1.107</span></div><div class="line">&#125;</div><div class="line"><span class="comment">#</span></div></pre></td></tr></table></figure>
</li>
<li><p>Edit /etc/default/isc-dhcp-server to specify the interfaces dhcpd should listen to. By default it listens to eth0.<br> INTERFACES=””</p>
</li>
<li><p>Use these commands to start and check DHCP service<br><code>sudo service isc-dhcp-server restart</code><br>Check status with <code>netstat -lu</code><br>Expected output:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</div><div class="line">udp        0      0 *:bootpc                *:*</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Setup-TFTP-server-on-Ubuntu"><a href="#Setup-TFTP-server-on-Ubuntu" class="headerlink" title="Setup TFTP server on Ubuntu"></a><a name="3">Setup TFTP server on Ubuntu</a></h3><ul>
<li><p>Install TFTP server and TFTP client(optional, tftp-hpa is the client package)</p>
<p><code>sudo apt-get install -y openbsd-inetd tftpd-hpa tftp-hpa lftp</code>  </p>
</li>
<li><p>Edit /etc/inetd.conf</p>
<p>Remove “#” from the beginning of tftp line or add if it’s not there under “#:BOOT:” comment as follow.<br><code>tftp    dgram   udp wait    root    /usr/sbin/in.tftpd  /usr/sbin/in.tftpd -s /var/lib/tftpboot</code>  </p>
</li>
<li>Enable boot service for inetd<br><code>sudo update-inetd --enable BOOT</code>  </li>
<li><p>Configure the TFTP server, update /etc/default/tftpd-hpa like follows:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">TFTP_USERNAME=<span class="string">"tftp"</span></div><div class="line">TFTP_ADDRESS=<span class="string">"0.0.0.0:69"</span></div><div class="line">TFTP_DIRECTORY=<span class="string">"/var/lib/tftpboot"</span></div><div class="line">TFTP_OPTIONS=<span class="string">"-l -c -s"</span></div></pre></td></tr></table></figure>
</li>
<li><p>Set up TFTP server directory</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo mkdir /var/lib/tftpboot</div><div class="line">sudo chmod -R 777 /var/lib/tftpboot/</div></pre></td></tr></table></figure>
</li>
<li><p>Restart inet &amp; TFTP server</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo service openbsd-inetd restart</div><div class="line">sudo service tftpd-hpa restart</div></pre></td></tr></table></figure>
<p>Check status with <code>netstat -lu</code><br>Expected output:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</div><div class="line">udp        0      0 *:tftp                  *:*</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Put-files-in-the-TFTP-root-path"><a href="#Put-files-in-the-TFTP-root-path" class="headerlink" title="Put files in the TFTP root path"></a><a name="4">Put files in the TFTP root path</a></h3><p>Put the corresponding files into TFTP root directory, they are: grub binary file, grub configure file, kernel Image and dtb file.<br>In my case, they are grubaa64.efi, Image_D02 and grub.cfg-01-xx-xx-xx-xx-xx-xx, hip05-d02.dtb.</p>
<p>Note:  </p>
<ol>
<li>The name of grub binary “grubaa64.efi” or “grubarm32.efi” must be as same as the DHCP configure file in <code>/etc/dhcp/dhcpd.conf</code>.  </li>
<li>The grub configure file’s name must comply with a special format, e.g. grub.cfg-01-xx-xx-xx-xx-xx-xx, it starts with “grub.cfg-01-“ and ends with board’s MAC address.  </li>
<li>The grub binary and grub.cfg-01-xx-xx-xx-xx-xx-xx files must be placed in the TFTP root directory.  </li>
<li>The names and positions of kernel image and dtb must be consistent with the corresponding grub config file.  </li>
</ol>
<p>To get and config grub and grub config files, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Grub_Manual.4All.md" target="_blank" rel="external">Grub_Manual.md</a>.<br>To get kernel and dtb file, please refer to Readme.md.</p>
<h3 id="Setup-NFS-server-on-Ubuntu"><a href="#Setup-NFS-server-on-Ubuntu" class="headerlink" title="Setup NFS server on Ubuntu"></a><a name="5">Setup NFS server on Ubuntu</a></h3><ul>
<li>Install NFS server package<br><code>sudo apt-get install nfs-kernel-server nfs-common portmap</code>  </li>
<li><p>Modify configure file <code>/etc/exports</code> for NFS server<br>Add following contents at the end of this file.<br> *(rw,sync,no_root_squash)<br>Note: <code>&lt;/rootnfs&gt;</code> is your real shared directory of rootfs of distributions for NFS server.</p>
</li>
<li><p>Uncompress a distribution to <code>&lt;/rootnfs&gt;</code><br>  To get them, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Distributions_Guide.4All.md" target="_blank" rel="external">Distributions_Guider.md</a>  </p>
</li>
<li>Restart NFS service<br><code>sudo service nfs-kernel-server restart</code></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UEFI_Manual.4D02.md]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/D02/UEFI_Manual.4D02/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">Upgrade UEFI</a></li>
<li><a href="#3">Recover the UEFI when it broke</a></li>
</ul>
<a id="more"></a>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><a name="1">Introduction</a></h2><p>UEFI is a kind of BIOS to boot system and provide runtime service to OS which can do some basic IO operation with the runtime service, e.g.: reboot, power off and etc.<br>Normally, there are some trust firmware will be produce from UEFI building, they are responsible for trust reprogram, they include:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UEFI_D02.fd      //UEFI executable binary file.</div><div class="line">CH02TEVBC_V03.bin   // CPLD binary to control power supplier.</div></pre></td></tr></table></figure></p>
<p>Where to get them, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Readme.4D02.md" target="_blank" rel="external">Readme.md</a>.</p>
<h2 id="Upgrade-UEFI"><a href="#Upgrade-UEFI" class="headerlink" title="Upgrade UEFI"></a><a name="2">Upgrade UEFI</a></h2><p>Note: This is not necessary unless you want to upgrade UEFI really.</p>
<ol>
<li><p>Prepare files about UEFI on local computer<br>FTP protocol is used for downloading between hardware boards and local network. Aboveall, please make sure you have a working FTP server in local network, so that board can get needed files from network by FTP.<br>All files mentioned above should be ready firstly, then put them in the root directory of FTP.</p>
</li>
<li><p>Connect the board’s UART port to a host machine<br>Please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Deploy_Manual.4D02.md" target="_blank" rel="external">Deploy_Manual.4D02.md</a> “Prerequisite” chapter.</p>
</li>
</ol>
<p>If you choose Method 1, use another console window, use <code>board_reboot</code> command to reset the board.<br>If you choose Method 2, press the reset key on the board to reset the board.</p>
<p>When system showing “Press Any key in 10 seconds to stop automatical booting…”, press any key except “enter” key to enter UEFI main menu.</p>
<h3 id="UEFI-menu-introduction"><a href="#UEFI-menu-introduction" class="headerlink" title="UEFI menu introduction"></a>UEFI menu introduction</h3><p>  UEFI main menu option is showed as follow:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">continue</span> </div><div class="line">select Language            &lt;standard English&gt;</div><div class="line">&gt;Boot Manager</div><div class="line">&gt;Device Manager</div><div class="line">&gt;Boot Maintenance Manager</div></pre></td></tr></table></figure></p>
<p>  Choose “Boot Manager” and enter into Boot option menu:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">EFI Misc Device </div><div class="line">EFI Misc Device 1</div><div class="line">EFI Network</div><div class="line">EFI Internal Shell</div><div class="line">Flash Start OS</div><div class="line">ESL Start OS</div><div class="line">Embedded Boot Loader(EBL)</div></pre></td></tr></table></figure></p>
<p>  EFI Internal Shell mode is a standard command shell in UEFI. Embedded Boot Loader(EBL) mode is an embedded command shell based on boot loader specially for developers.<br>  You can switch between two modes by typing “exit” from one mode to UEFI main menu and then choose the another mode.</p>
<h3 id="Update-UEFI-files"><a href="#Update-UEFI-files" class="headerlink" title="Update UEFI files"></a>Update UEFI files</h3><ul>
<li><p>IP address config at “EFI Internal Shell” mode(Optional, you can ignore this step if DHCP works well)<br> Press any key except “enter” key to enter into UEFI main menu. Select “Boot Manager”-&gt;EFI Internal Shell.</p>
<p> <code>ifconfig -s eth0 static &lt;IP address&gt; &lt;mask&gt; &lt;gateway&gt;</code><br> e.g.: <code>ifconfig -s eth0 static 192.168.1.4 255.255.255.0 192.168.1.1</code></p>
</li>
<li><p>Burn BIOS file at “Embedded Boot Loader(EBL)” mode<br>Enter “exit” from “EFI Internet Shell” mode to UEFI main menu and choose “Boot Manager”-&gt; “Embedded Boot Loader(EBL)”after setting the IP address done.  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Download file from FTP server to board's RAM</span></div><div class="line">provision &lt;server IP&gt; -u &lt;ftp user name&gt; -p &lt;ftp password&gt; <span class="_">-f</span> &lt;UEFI binary&gt; <span class="_">-a</span> &lt;download target address&gt;</div><div class="line"><span class="comment"># Write the data into NORFLASH</span></div><div class="line">spiwfmem &lt;<span class="built_in">source</span> address&gt; &lt;target address&gt; &lt;data length&gt;</div></pre></td></tr></table></figure>
<p>e.g.:  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">provision 192.168.1.107 -u sch -p aaa <span class="_">-f</span> UEFI_D02.fd <span class="_">-a</span> 0x100000</div><div class="line">spiwfmem 0x100000 0x0000000 0x300000</div></pre></td></tr></table></figure>
</li>
<li><p>Burn CPLD file<br>Notes: This is a very dangerous operation, please don’t do it when not necessary.<br>If you really want to do it, please make sure the power can <strong>NOT</strong> be shut off suddenly during updating CPLD.  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Download file from FTP server to board's RAM</span></div><div class="line">provision &lt;server IP&gt; -u &lt;ftp user name&gt; -p &lt;ftp password&gt; <span class="_">-f</span> &lt;cpld bin&gt; <span class="_">-a</span> &lt;target address&gt;</div><div class="line"><span class="comment"># Write the data into NORFLASH</span></div><div class="line">updatecpld &lt;target address&gt;</div></pre></td></tr></table></figure>
<p>e.g.:  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">provision 192.168.1.107 -u sch -p aaa <span class="_">-f</span> CH02TEVBC_V03.bin <span class="_">-a</span> 0x100000</div><div class="line">updatecpld 0x100000</div></pre></td></tr></table></figure>
</li>
<li><p>Power off and reboot board again</p>
</li>
</ul>
<h2 id="Recover-the-UEFI-when-it-broke"><a href="#Recover-the-UEFI-when-it-broke" class="headerlink" title="Recover the UEFI when it broke"></a><a name="3">Recover the UEFI when it broke</a></h2><p>Actually the board can restore two UEFI in case of the default one breaks, then you can restore it as following way:  </p>
<ol>
<li>Power off the board and disconnect power supply.  </li>
<li>Push the dial switch ‘s3’ to ‘off’ with a ‘3’ on the board, please check the Hardware Boards to find where it is: <a href="http://open-estuary.com/d02-2/" target="_blank" rel="external">http://open-estuary.com/d02-2/</a>.  </li>
<li>Power on and enter UEFI SHELL again as above description.  </li>
<li>Push the dial swift ‘s3’ to ‘on’ with a ‘3’ on the board.  </li>
<li>Burn UEFI file for BIOS as above step3 “Update UEFI files”.  </li>
<li>Reset the system again.<br>Now you have already updated your failed BIOS, and the board will boot with new UEFI successfully.</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Setup_HiKey_WiFi_Env.4HiKey.md]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/All/Setup_HiKey_WiFi_Env.4HiKey/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">Config WiFi On mini-rootfs systerm</a></li>
<li><a href="#2">Config WiFi On Ubuntu &amp; Debian systerm</a></li>
<li><a href="#3">Fedora &amp;&amp; CentOS wifi configure</a></li>
<li><a href="#4">OpenSuse Wifi configure</a></li>
</ul>
<a id="more"></a>
<p>This is a guide to setup a WiFi environment on your HiKey board.</p>
<p>When HiKey board can boot into mini-rootfs systerm or Ubuntu systerm in Estuary project, you can config WiFi function. If you can not boot into this systerm, you can get more information from DeployManual.txt file.</p>
<h2 id="Config-WiFi-On-mini-rootfs-systerm"><a href="#Config-WiFi-On-mini-rootfs-systerm" class="headerlink" title="Config WiFi On mini-rootfs systerm"></a><a name="1">Config WiFi On mini-rootfs systerm</a></h2><p>On serial console, you should see some debug message which can show if the Hikey board have booted into mini-rootfs systerm successfully. You can config this WiFi according to this follow instruction:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">echo</span> 0 &gt; /sys/kernel/debug/ieee80211/phy0/wlcore/sleep_auth</div><div class="line">$ ifconfig wlan0 up</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## Use the following command to know if WiFi is ok ##</span></div><div class="line">$ iw wlan0 scan | grep SSID</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## to create a wpa_supplicant.conf ##</span></div><div class="line">$ wpa_passphrase &lt;ssid&gt; &lt;passphrase&gt; &gt; /etc/wpa_supplicant.conf</div></pre></td></tr></table></figure>
<p>eg: <code>wpa_passphrase admin admin &gt; /etc/wpa_supplicant.conf</code>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wpa_supplicant -B -iwlan0 -c/etc/wpa_supplicant.conf -Dnl80211</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## wait a while for wpa_supplicant to link ##</span></div><div class="line">$ iw wlan0 link</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">## config ip and route ##</span></div><div class="line">$ ifconfig wlan0 &lt;IP address&gt;</div><div class="line">$ route add default gw &lt;IP address&gt;</div><div class="line">$ <span class="built_in">echo</span> <span class="string">"nameserver &lt;IP address&gt;"</span> &gt;&gt; /etc/resolv.conf</div></pre></td></tr></table></figure>
<p>eg:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ifconfig wlan0 192.168.2.80</div><div class="line">route add default gw 192.168.2.1</div><div class="line"><span class="built_in">echo</span> <span class="string">"nameserver 192.168.2.1"</span> &gt;&gt; /etc/resolv.conf</div></pre></td></tr></table></figure></p>
<p>NOTE: In order to test this WiFi function, you can use “ping www.baidu.com” website to verify it.</p>
<h2 id="Config-WiFi-On-Ubuntu-amp-Debian-systerm"><a href="#Config-WiFi-On-Ubuntu-amp-Debian-systerm" class="headerlink" title="Config WiFi On Ubuntu &amp; Debian systerm"></a><a name="2">Config WiFi On Ubuntu &amp; Debian systerm</a></h2><p>On serial console, you should see some debug message which can show if the Hikey board have booted into ubuntu systerm successfully. You can config this WiFi according to this follow instruction:<br>Supposed the login user is peter.</p>
<ol>
<li><p>Find out the wireless device name ##<br><code>$ iw dev</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">phy<span class="comment">#0</span></div><div class="line">Interface wlan0</div><div class="line">ifindex 3</div><div class="line"><span class="built_in">type</span> managed</div></pre></td></tr></table></figure>
<p>The above output shows that the system has 1 physical WiFi card, designated as phy#0.<br>The device name is wlan0. The type specifies the operation mode of the wireless device.<br>managed means the device is a WiFi station or client that connects to an access point.</p>
</li>
<li><p>configure the wifi data for the wifi device you selected</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /etc/wpa_supplicant</div><div class="line">vi wpa_supplicant.con</div></pre></td></tr></table></figure>
<p>then you should remove all the existed entries parenthesized by’network={‘; those entries are original configures, probably not suitable for your network environment, so you can delete them.<br>Now, you can configure your own wifi data:<br><code>wpa_passphrase CTS 88888888 &gt;&gt; /etc/wpa_supplicant/wpa_supplicant.conf</code><br>Please note that you should replace the ‘CTS’, ‘88888888’ with your AP configuring parameters. If you want to more info about this command, please refer to wpa_passphrase manual.<br>To be more security, you can remove the ‘#psk=xxxx’ from the wpa_supplicant.conf;<br>If your AP is hidden SSID, add this option just following the configure line of ‘ssid=”???”‘ :<br>scan_ssid=1</p>
</li>
<li><p>configure the wifi interface</p>
<p>You must configure a corresponding wifi interface to make wifi enabled during the booting.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /etc/network/interfaces.d</div><div class="line">cp -Pp wlan0.cfg.template xxxx.cfg</div></pre></td></tr></table></figure>
<p>You should replace the ‘xxxx’ as your wifi device name, such as wlan0. Modify the new xxx.cfg, add these configurations:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">auto xxxx</div><div class="line">iface xxxx inet dhcp</div></pre></td></tr></table></figure>
<p>You also need to replace the ‘xxxx’ with your wifi device name. Here, we only use dhcp as the defualt network mode, if you want to<br>configure others, please do it yourself.<br>You also need to update the configure relevant to the sys configure file<br>of sleep_auth, just modify the file path correspond to your wifi device:<br><code>pre-up echo 0 &gt; /sys/kernel/debug/ieee80211/phy0/wlcore/sleep_auth</code>  </p>
<p>This configure matchs to wlan0. If your device is not wlan0, please check what is the right path based on the output of the above ‘iw dev xxxx’ (<br>here, xxxx is the wifi device name), you can find what is the phy index,then replace the phy0 with the correct phy index.</p>
<p>If your envinorment has not any wired network device, you can rename the eth3.cfg in <code>/etc/network/interfaces.d</code> as eth3.cfg.template;</p>
</li>
<li><p>reboot the system adn verify the wifi status</p>
<p>At first, please reboot the system.<br>After the system is ready, you can check whether the wifi is ready:</p>
<ul>
<li><p>Check whether the wireless device is up.<br><code>$ ip link show wlan0</code>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">3: wlan0: (BROADCAST,MULTICAST) mtu 1500 qdisc noop state DOWN mode DEFAULT qlen 1000</div><div class="line">link/ether 74:e5:43:a1:ce:65 brd ff:ff:ff:ff:ff:ff`</div></pre></td></tr></table></figure>
<p>Look for the word “UP” inside the brackets in the first line of the output.</p>
</li>
<li><p>Enable the wireless device<br>In the above example, wlan0 is not UP. Execute the following command to bring it up:<br><code>$ sudo ip link set wlan0 up</code><br><code>[sudo] password for peter</code>:<br>Note: you need root privilege for the above operation.</p>
<p>If you run the show link command again, you can tell that wlan0 is now UP.<br><code>$ ip link show wlan0</code>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wlan0: (NO-CARRIER,BROADCAST,MULTICAST,UP) mtu 1500 qdisc mq state DOWN mode DEFAULT</div><div class="line">qlen 1000</div><div class="line">link/ether 74:e5:43:a1:ce:65 brd ff:ff:ff:ff:ff:ff</div></pre></td></tr></table></figure>
</li>
<li><p>Check the connection status.<br><code>$ iw wlan0 link</code><br>you can found the connect is ok now.<br><code>$ ip addr show wlan0</code>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wlan0:  mtu 1500 qdisc mq state UP qlen 1000</div><div class="line">link/ether 74:e5:43:a1:ce:65 brd ff:ff:ff:ff:ff:ff</div><div class="line">inet 192.168.1.113/24 brd 192.168.1.255 scope global wlan0</div><div class="line">inet6 fe80::76e5:43ff:fea1:ce65/64 scope link</div><div class="line">valid_lft forever preferred_lft forever</div></pre></td></tr></table></figure>
</li>
</ul>
<p>NOTE: In order to test this WiFi function, you can use “ping www.baidu.com” website to verify it.</p>
</li>
</ol>
<h2 id="Fedora-amp-amp-CentOS-wifi-configure"><a href="#Fedora-amp-amp-CentOS-wifi-configure" class="headerlink" title="Fedora &amp;&amp; CentOS wifi configure"></a><a name="3">Fedora &amp;&amp; CentOS wifi configure</a></h2><p> Please run ‘iw dev’ to collect the wifi device information as the first step. You at least need to know what is the device name of your wifi.</p>
<ol>
<li><p>configure the wpa_supplicant environment</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /etc/sysconfig</div><div class="line">vi wpa_supplicant</div></pre></td></tr></table></figure>
<p>You should add your wifi device name and the relative driver in that file, such as <code>-iwlan0</code>, <code>-Dnl80211</code>;</p>
</li>
<li><p>Configure the wpa_supplicant.conf</p>
<p><code>wpa_passphrase CTS 88888888 &gt;&gt; /etc/wpa_supplicant/wpa_supplicant.conf</code><br>Then edit the wpa_supplicant.conf just as what you done in Debian or Ubuntu.</p>
</li>
<li><p>Create a wifi connection</p>
<p>You need to create a corresponding wifi connection file in <code>/etc/sysconfig/network-scripts</code>.<br>nmcli dev wifi connect CTS password 88888888 wep-key-type key ifname wlan0 name wlan0 hidden yes this command will create the wifi connection in <code>/etc/sysconfig/network-scripts</code></p>
<p>You should replace the ‘CTS’ ‘88888888’ with your own wifi AP configurations.<br>If your wifi device is not ‘wlan0’, please replace it with right name too.<br>If your AP is not hidden ssid, please remove ‘hidden yes’  </p>
<p>This command must be sucessful. It will enable the wifi link. sometimes, this command will get failed for conflicting with previous scan, you should run it again in some times.</p>
<p>Since your had configure the password in the above command, the #psk in wpa_supplicant.conf is not needed since it will disclose to the others. It is better to remove that line in /etc/wpa_supplicant/wpa_supplicant.conf. –remove that line ‘#psk=”88888888”‘i</p>
</li>
<li><p>reboot your system and verify it</p>
<p>After your system is booted, check the wifi link and the IP address:<br><code>iw wlan0 link</code><br><code>ip addr show wlan0</code>  </p>
<p>When the above are ok, you can do some pings to external website.</p>
</li>
</ol>
<h2 id="OpenSuse-Wifi-configure"><a href="#OpenSuse-Wifi-configure" class="headerlink" title="OpenSuse Wifi configure"></a><a name="4">OpenSuse Wifi configure</a></h2><ol>
<li><p>modify the wifi connection file (such as ifcfg-xxx)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">cd</span> /etc/sysconfig/network</div><div class="line">cp -Pp template-ifcfg-wlan0 ifcfg-xxx</div></pre></td></tr></table></figure>
<p>you should replace xxx with your wifi device name you pick up. Update these configure items with your local AP settings:  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">WIRELESS_ESSID=<span class="string">'xxxx'</span></div><div class="line">WIRELESS_WPA_PSK=<span class="string">'yyyyyyyy'</span></div></pre></td></tr></table></figure>
<p>The ‘xxxx’ ‘yyyyyyyy’ should be replaced with your wifi SSID and KEY.If your AP is hidden ssid, add this option: <code>WIRELESS_HIDDEN_SSID=&#39;yes&#39;</code></p>
<p>Please note that, the current configuration in ifcfg-xxx is for PSK. If your wifi AP configuration is different, please make the relevant modifications by yourself.</p>
</li>
<li><p>reboot the system and verify it</p>
<p>Same as the operation on other distributions.</p>
<p>All the above configure should be done for the first time. If you change the AP configurations, please update those configure files above with correct options. Otherwise, the wifi should be ok every booting.</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Deploy_Manual.4D05]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/D05/Deploy_Manual.4D05/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">Preparation</a><ul>
<li><a href="#2.1">Prerequisite</a></li>
<li><a href="#2.2">Check the hardware board</a></li>
<li><a href="#2.3">Upgrade UEFI and trust firmware</a></li>
</ul>
</li>
<li><a href="#3">Bring up System via ACPI mode</a><ul>
<li><a href="#3.1">Boot via PXE(ACPI)</a></li>
<li><a href="#3.2">Boot via NFS(ACPI)</a></li>
<li><a href="#3.3">Boot via DISK(SAS/USB/SATA)(ACPI)</a><a id="more"></a>
</li>
</ul>
</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><a name="1">Introduction</a></h2><p>This documentation describes how to get, build, deploy and bring up target system based Estuary Project, it will help you to make your Estuary Environment setup from ZERO.</p>
<p>All following sections will take the D05 board as example, other boards have the similar steps to do, for more detail difference between them, please refer to Hardware Boards sections in <a href="http://open-estuary.com/hardware-boards/" target="_blank" rel="external">http://open-estuary.com/hardware-boards/</a>.</p>
<h2 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a><a name="2">Preparation</a></h2><h3 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a><a name="2.1">Prerequisite</a></h3><p><em>Local network</em>: To connect hardware boards and host machine, so that they can communicate each other.<br><em>Serial cable</em>: To connect hardware board’s serial port to host machine, so that you can access the target board’s UART in host machine.</p>
<p>Two methods are provided to <strong>connect the board’s UART port to a host machine</strong>:<br><strong>Method 1</strong> : connect the board’s UART in openlab environment<br>Use <code>board_connect</code> command.(Details please refer to <code>board_connect --help</code>)<br><strong>Method 2</strong> : directly connect the board by UART cable<br>a. Connect the board’s UART port to a host machine with a serial cable.<br>b. Install a serial port application in host machine, e.g.: kermit or minicom.<br>c. Config serial port setting:115200/8/N/1 on host machine.</p>
<p>For more details, please refer to <a href="https://github.com/open-estuary/estuary/tree/estuary-d05-3.0b/doc/UEFI_Manual.4D05.md" target="_blank" rel="external">UEFI_Manual.md</a> “Upgrade UEFI” chapter.</p>
<h3 id="Check-the-hardware-board"><a href="#Check-the-hardware-board" class="headerlink" title="Check the hardware board"></a><a name="2.2">Check the hardware board</a></h3><p>Hardware board should be ready and checked carefully to make sure it is available, more detail information about different hardware board, please refer to <a href="http://open-estuary.org/d05/" target="_blank" rel="external">http://open-estuary.org/d05/</a>.</p>
<h3 id="Upgrade-UEFI-and-trust-firmware"><a href="#Upgrade-UEFI-and-trust-firmware" class="headerlink" title="Upgrade UEFI and trust firmware"></a><a name="2.3">Upgrade UEFI and trust firmware</a></h3><p>You can upgrade UEFI and trust firmware yourself based on FTP service, but this is not necessary. If you really want to do it, please refer to <a href="https://github.com/open-estuary/estuary/tree/estuary-d05-3.0b/doc/UEFI_Manual.4D05.md" target="_blank" rel="external">UEFI_Manual.md</a>.</p>
<h2 id="Bring-up-System-via-ACPI-mode"><a href="#Bring-up-System-via-ACPI-mode" class="headerlink" title="Bring up System via ACPI mode"></a><a name="3">Bring up System via ACPI mode</a></h2><p>There are several methods to bring up system, you can select following anyone fitting you to boot up.</p>
<p>D05 only supports booting via ACPI, not support DTS mode. Set the parameters as follow to boot via ACPI.</p>
<p>You must add “<code>acpi=force</code>“ property in “<code>linux=....</code>“ line for <code>grub.cfg</code> file.<br>e.g.:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Booting from NFS with Centos rootfs</span></div><div class="line"> menuentry <span class="string">"D05 Centos NFS(ACPI)"</span> --id d05_centos_nfs_acpi &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">    linux /Image acpi=force pcie_aspm=off rdinit=/init crashkernel=256M@32M console=ttyAMA0,115200 earlycon=pl011,mmio,0x602B0000 root=/dev/nfs rw nfsroot=192.168.1.107:/home/hisilicon/ftp/centos ip=dhcp</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>NOTE: you can get more information about setting grub.cfg from <a href="https://github.com/open-estuary/estuary/tree/estuary-d05-3.0b/doc/Grub_Manual.4All.md" target="_blank" rel="external">Grub_Manual.md</a>.</p>
<h3 id="Boot-via-PXE-ACPI"><a href="#Boot-via-PXE-ACPI" class="headerlink" title="Boot via PXE(ACPI)"></a><a name="3.1">Boot via PXE(ACPI)</a></h3><p>In this boot mode, the UEFI will get grub from PXE server.The grub will get the configuration file from TFTP service configured by PXE server.</p>
<ol>
<li>Setup PXE environment on host<br>Enable both DHCP and TFTP services on one of your host machines according to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Setup_PXE_Env_on_Host.4All.md" target="_blank" rel="external">Setup_PXE_Env_on_Host.md</a>.</li>
<li>Reboot and press anykey except “enter” to enter UEFI Boot Menu</li>
<li>Select boot option “Boot Manager”-&gt;”EFI Network <code>&lt;No&gt;</code>“ boot option and press “Enter”.<br><strong>Note</strong>: If you are connecting the D05 board of openlab, please select “EFI Network 2”.<br>The value of <code>&lt;No&gt;</code> is depended on which D05 GE port is connected. D05 board support 4 on-board network ports at maximun.To enable any one of them by connecting to network cable or optical fiber. From left to right, followed by two GE ports, two 10GE ports which corresponding to UEFI startup interface are EFI Network 2, EFI Network 3, EFI Network 0, EFI Network 1.</li>
<li>After several seconds, D05 will boot by PXE automatically.</li>
</ol>
<p>To config the grub.cfg to support PXE boot, please refer to  <a href="https://github.com/open-estuary/estuary/tree/estuary-d05-3.0b/doc/Grub_Manual.4All.md" target="_blank" rel="external">Grub_Manual.md</a>.</p>
<h3 id="Boot-via-NFS-ACPI"><a href="#Boot-via-NFS-ACPI" class="headerlink" title="Boot via NFS(ACPI)"></a><a name="3.2">Boot via NFS(ACPI)</a></h3><p>In this boot mode, the root parameter in <code>grub.cfg</code> menuentry will set to <code>/dev/nfs</code> and <code>nfsroot</code> will be set to the path of rootfs on NFS server. You can use <code>showmount -e &lt;server ip address&gt;</code> to list the exported NFS directories on the NFS server.</p>
<p>D05 supports booting via NFS, you can try it as following steps:</p>
<ol>
<li>Enable DHCP, TFTP and NFS service according to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Setup_PXE_Env_on_Host.4All.md" target="_blank" rel="external">Setup_PXE_Env_on_Host.md</a>.  </li>
<li>Get and config grub file to support NFS boot according to <a href="https://github.com/open-estuary/estuary/tree/estuary-d05-3.0b/doc/Grub_Manual.4All.md" target="_blank" rel="external">Grub_Manual.md</a>.<br><strong>Note</strong>: D05 only supports booting via ACPI mode with Centos distribution, so please refer to <a href="https://github.com/open-estuary/estuary/tree/estuary-d05-3.0b/doc/Grub_Manual.4All.md" target="_blank" rel="external">Grub_Manual.md</a> to get correct configuration.  </li>
<li>Reboot D05 and press anykey except “enter” to enter UEFI Boot Menu  </li>
<li>Select boot option “Boot Manager”-&gt;”EFI Network <code>&lt;No&gt;</code>“ boot option to enter.<br><strong>Note</strong>: If you are connecting the D05 board of openlab, please select “EFI Network 2”. The value of <code>&lt;No&gt;</code> is depended on which D05 GE port is connected.</li>
</ol>
<h3 id="Boot-via-DISK-SAS-USB-SATA-ACPI"><a href="#Boot-via-DISK-SAS-USB-SATA-ACPI" class="headerlink" title="Boot via DISK(SAS/USB/SATA)(ACPI)"></a><a id="3.3">Boot via DISK(SAS/USB/SATA)(ACPI)</a></h3><p>D05 board supports booting via SAS, USB and SATA by default. The UEFI will directly get the grub from the EFI system partition on the hard disk. The grub will load the grub configuration file from the EFI system partition. So <code>grubaa64.efi</code>, <code>grub.cfg</code>, <code>Image</code> and different estuary release distributions are stored on disk.</p>
<ol>
<li><p>Boot by PXE (please refer to “Boot via PXE”) to part and format hardware disk before booting D05 board<br>Format hardware disk, e.g.:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo mkfs.vfat /dev/sda1</div><div class="line">sudo mkfs.ext4 /dev/sda2</div></pre></td></tr></table></figure>
<p>Part hardware disk with command <code>sudo fdisk /dev/sda</code> as follow:<br>add a gpt to this disk :<br><code>g</code>——-add a gpt partition  </p>
<p>add some EFI partition :<br><code>n</code>——-add a partition<br><code>1</code>——-the number of partition</p>
<p>type “Enter” key —— First sector<br><code>+200M</code>———Last sector, size of partition<br><code>t</code>——-change the type of partition to EFI system</p>
<p>add some another partition <code>...</code><br>save the change : <code>w</code><br>format EFI partition : <code>sudo mkfs.vfat /dev/sda1</code><br>format ext4 partition : <code>sudo mkfs.ext4 /dev/sda2</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+---------+-----------+--------------+------------------+</div><div class="line">| Name    |   Size    |    Type      |   USB/SAS/SATA   |</div><div class="line">+---------+-----------+--------------+------------------+</div><div class="line">| sda1    |   200M    |  EFI system  |   EFI            |</div><div class="line">+---------+-----------+--------------+------------------+</div><div class="line">| sda2    |   10G     |    ext4      | linux filesystem |</div><div class="line">+---------+-----------+--------------+------------------+</div><div class="line">| sda3    |   10G     |    ext4      | linux filesystem |</div><div class="line">+---------+-----------+--------------+------------------+</div><div class="line">| sda4    |   10G     |    ext4      | linux filesystem |</div><div class="line">+---------+-----------+--------------+------------------+</div><div class="line">| sda5    |rest space |    ext4      | linux swap       |</div><div class="line">+---------+-----------+--------------+------------------+</div></pre></td></tr></table></figure>
<p><strong>Note</strong>: EFI partition must be a fat filesystem, so you should format sda1 with <code>sudo mkfs.vfat /dev/sda1</code>.</p>
</li>
<li><p>Download files and store them into hardware disk as below.<br>(SAS/USB/SATA) Related files are placed as follow:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sda1: -------EFI</div><div class="line">       |       |</div><div class="line">       |       GRUB2------grubaa64.efi  //grub binary file</div><div class="line">       |</div><div class="line">       |-------------grub.cfg           //grub config file</div><div class="line">       |</div><div class="line">       |-------------Image              //kernel binary Image</div><div class="line">sda2: Centos distribution</div></pre></td></tr></table></figure>
<p><strong>Note</strong>: D05 only supports booting system with Centos, so Centos distribution should be uncompressed in sda2. The <code>grubaa64.efi</code> file must be put in <code>/EFI/GRUB2</code> directory of <code>/dev/sda1</code>(gpt partition)</p>
<p>To get kernel image file, please refer to <a href="https://github.com/open-estuary/estuary/tree/estuary-d05-3.0b/doc/Readme.4D05.md" target="_blank" rel="external">Readme.md</a>.<br>To get and config grub and grub.cfg, please refer to <a href="https://github.com/open-estuary/estuary/tree/estuary-d05-3.0b/doc/Grub_Manual.4All.md" target="_blank" rel="external">Grub_Manual.md</a>.<br>To get Centos distribution, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Distributions_Guide.4All.md" target="_blank" rel="external">Distributions_Guider</a>.</p>
</li>
<li><p>Boot the board via SAS/USB/SATA<br><strong>a</strong>. Modify grub config file, please refer to <a href="https://github.com/open-estuary/estuary/blob/estuary-d05-3.0b/doc/Grub_Manual.4All.md" target="_blank" rel="external">Grub_Manual.4All.md</a><br>   e.g.:  </p>
   <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Sample GRUB configuration file</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Boot automatically after 5 secs.</span></div><div class="line"><span class="built_in">set</span> timeout=5</div><div class="line"><span class="comment"># By default, boot the Estuary with Centos filesystem</span></div><div class="line"><span class="built_in">set</span> default=d05_centos_sata_acpi</div><div class="line"><span class="comment"># For booting GNU/Linux</span></div><div class="line"></div><div class="line">menuentry <span class="string">"D05 Centos SATA(ACPI)"</span> --id d05_centos_sata_acpi &#123;</div><div class="line">    search --no-floppy --fs-uuid --set=root &lt;UUID&gt;</div><div class="line">    linux /Image acpi=force pcie_aspm=off rdinit=/init crashkernel=256M@32M console=ttyAMA0,115200 earlycon=pl011,mmio,0x602B0000 root=PARTUUID=&lt;PARTUUID&gt; rootwait rootfstype=ext4 rw ip=dhcp</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   <strong>Note</strong>:<br>   <code>&lt;UUID&gt;</code>means the UUID of that partition which your EFI System is located in.<br>   <code>&lt;PARTUUID&gt;</code> means the PARTUUID of that partition which your linux distribution is located in.<br>   To see the values of UUID and PARTUUID, please use the command: <code>blkid</code>.<br><strong>b</strong>. Reboot and press anykey except “enter” to enter UEFI main menu.<br><strong>c</strong>. For USB: Select “Boot Manager”-&gt; “EFI USB Device”-&gt; to enter grub selection menu.<br>   For SAS: Select “Boot Manager”-&gt; “EFI Misc Device 1” to enter grub selection menu.<br>   For SATA: Select “Boot Manager”-&gt; “EFI Hard Drive” to enter grub selection menu.<br><strong>d</strong>. Press arrow key up or down to select grub boot option to decide which distribution should boot.</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Distributions_Guild.4All.md]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/All/Distributions_Guide.4All/</url>
      <content type="html"><![CDATA[<p>This is the guide for distributions</p>
<a id="more"></a>
<p>Distribution indicates a specially total rootfs for linux kernel.<br>After you run <code>./estuary/build.sh -d &lt;Platform Name&gt; -p &lt;Distribution Name&gt;</code>, the corresponding distribution tarball will be created into <code>&lt;project root&gt;/build/&lt;platform name&gt;/distro</code>.<br>By default, it is named as <distribution name="">_<arm arch="">.tar.gz, and the default username and password for them are “root,root”.</arm></distribution></p>
<p>You can do following commands to uncompress the tarball into any special block device’s partition, e.g.: SATA, SAS or USB disk.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir tempdir</div><div class="line">sudo mount /dev/&lt;block device name&gt; tempdir</div><div class="line">sudo tar -xzf &lt;Distribution Name&gt;_&lt;Arm arch&gt;.tar.gz -C tempdir</div></pre></td></tr></table></figure></p>
<p>You can also simply uncompress the tarball into a special directory as follows, and use the directory as the NFS’s rootfs.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir nfsdir</div><div class="line">sudo tar -xzf &lt;Distribution Name&gt;_&lt;Arm arch&gt;.tar.gz -C nfsdir</div></pre></td></tr></table></figure></p>
<p>If you want to produce a rootfs image file for QEMU, you can try as belows<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">mkdir tempdir</div><div class="line">sudo tar -xzf &lt;Distribution Name&gt;_&lt;Arm arch&gt;.tar.gz -C tempdir </div><div class="line"></div><div class="line"><span class="built_in">pushd</span> tempdir</div><div class="line">dd <span class="keyword">if</span>=/dev/zero of=../rootfs.img bs=1M count=10240</div><div class="line">mkfs.ext4 ../rootfs.img -F</div><div class="line">mkdir -p ../tempdir 2&gt;/dev/null</div><div class="line">sudo mount ../rootfs.img ../tempdir</div><div class="line">sudo cp <span class="_">-a</span> * ../tempdir/</div><div class="line">sudo umount ../tempdir</div><div class="line">rm -rf ../tempdir</div><div class="line"><span class="built_in">popd</span></div></pre></td></tr></table></figure></p>
<p>Then you will get the rootfs image file as rootfs.img</p>
<p><strong>You can download above distributions by following commands manually</strong>.</p>
<p>All validated distributions can be obtained in <a href="http://download.open-estuary.org/" target="_blank" rel="external">HTTP Download</a>/[release|pre-releases]/<code>&lt;version&gt;</code>/linux/<code>&lt;distro name&gt;</code>/.</p>
<p>e.g.:<br>You can get Ubuntu distribution of estuary v2.2-rc1 pre-releases version as follow:<br><code>wget -c http://download.open-estuary.org/AllDownloads/DownloadsEstuary/pre-releases/2.2/rc1/linux/Ubuntu/Common/Ubuntu_ARM64.tar.gz</code></p>
<p>For other distributions please refer to the description aboved.</p>
<p><strong>And all original distributions can be gotten by following commands</strong>:</p>
<p>Ubuntu:<br><code>wget -c https://cloud-images.ubuntu.com/vivid/current/vivid-server-cloudimg-arm64.tar.gz</code></p>
<p>OpenSUSE:<br><code>wget -c http://download.opensuse.org/ports/aarch64/distribution/13.2/appliances/openSUSE-13.2-ARM-JeOS.aarch64-rootfs.aarch64-Current.tbz</code></p>
<p>Fedora:<br><code>wget -c http://dmarlin.fedorapeople.org/fedora-arm/aarch64/F21-20140407-foundation-v8.tar.xz</code></p>
<p>Redhat: TBD</p>
<p>Debian:<br><code>wget -c http://people.debian.org/~wookey/bootstrap/rootfs/debian-unstable-arm64.tar.gz</code></p>
<p>OpenEmbedded:<br><code>wget -c http://releases.linaro.org/14.06/openembedded/aarch64/vexpress64-openembedded_minimal-armv8-gcc-4.8_20140623-668.img.gz</code></p>
<p>More detail about how to deploy target system into target board, please refer to Deployment_Manual.md.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[README.armor.perf.md]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/All/README.armor.perf/</url>
      <content type="html"><![CDATA[<a id="more"></a>
<p><strong>Readme for Ubuntu ARM64</strong></p>
<p>Install the latest perf binary*<br><code>$# sudo apt-get install linux-tools-3.19.0-23</code><br>The latest version availabe can be installed.<br>Now use the perf tool installed in <code>/usr/lib/linux-tools-3.19.0-23/perf</code><br><code>$# /usr/lib/linux-tools-3.19.0-23/perf stat -e L1-dcache-stores ls -l</code></p>
<p>The LLC, MN and DDR are added as RAW events.<br>The RAW event encoding format is as below<br><code>&lt;die ID(4 bit)&gt;&lt;Module ID(4 bit)&gt;&lt;Bank(4 bit)&gt;&lt;event code(12 bit)&gt;</code></p>
<p>Example: For LLC_READ_ALLOCATE event for TotemC will be 0x24f300, where 0x2 is DieID for TotemC, 0x4 is the ModuleID of LLC, 0xf is for all LLC banks, 0x300is the event code for LLC_READ_ALLOCATE<br>The Module ID’s are as below<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">LLC	= 0x4</div><div class="line">MN	= 0xb</div><div class="line">DDRC0	= 0x8</div><div class="line">DDRC1	= 0xd</div></pre></td></tr></table></figure></p>
<p>The DieID for the CPU Die are as below<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">SOC0_TOTEMA = 0x1 /* TOTEM A <span class="keyword">in</span> Socket 0 */</div><div class="line">SOC0_TOTEMC = 0x2</div><div class="line">SOC0_TOTEMB = 0x3</div><div class="line">SOC1_TOTEMA = 0x4</div><div class="line">SOC1_TOTEMC = 0x5</div><div class="line">SOC1_TOTEMB = 0x6</div></pre></td></tr></table></figure></p>
<p>The 22 LLC events are added as RAW events starting from 0x300 to 0x315<br>The 9 MN event codes and also the DDRC read, write and latecy counters, event codes are listed below<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">LLC_READ_ALLOCATE 		= 0x300</div><div class="line">LLC_WRITE_ALLOCATE 		= 0x301</div><div class="line">LLC_READ_NOALLOCATE		= 0x302</div><div class="line">LLC_WRITE_NOALLOCATE		= 0x303</div><div class="line">LLC_READ_HIT			= 0x304</div><div class="line">LLC_WRITE_HIT			= 0x305</div><div class="line">LLC_CMO_REQUEST			= 0x306</div><div class="line">LLC_COPYBACK_REQ		= 0x307</div><div class="line">LLC_HCCS_SNOOP_REQ		= 0x308</div><div class="line">LLC_SMMU_REQ			= 0x309</div><div class="line">LLC_EXCL_SUCCESS		= 0x30A</div><div class="line">LLC_EXCL_FAIL			= 0x30B</div><div class="line">LLC_CACHELINE_OFLOW		= 0x30C</div><div class="line">LLC_RECV_ERR			= 0x30D</div><div class="line">LLC_RECV_PREFETCH		= 0x30E</div><div class="line">LLC_RETRY_REQ			= 0x30F</div><div class="line">LLC_DGRAM_2B_ECC		= 0x310</div><div class="line">LLC_TGRAM_2B_ECC		= 0x311</div><div class="line">LLC_SPECULATE_SNOOP		= 0x312</div><div class="line">LLC_SPECULATE_SNOOP_SUCCESS	= 0x313</div><div class="line">LLC_TGRAM_1B_ECC		= 0x314</div><div class="line">LLC_DGRAM_1B_ECC		= 0x315</div><div class="line"></div><div class="line">MN_EO_BARR_REQ			= 0x316</div><div class="line">MN_EC_BARR_REQ			= 0x317</div><div class="line">MN_DVM_OP_REQ			= 0x318</div><div class="line">MN_DVM_SYNC_REQ			= 0x319</div><div class="line">MN_READ_REQ			= 0x31A</div><div class="line">MN_WRITE_REQ			= 0x31B</div><div class="line">MN_COPYBK_REQ			= 0x31C</div><div class="line">MN_OTHER_REQ			= 0x31D</div><div class="line">MN_RETRY_REQ			= 0x31E</div><div class="line"></div><div class="line">DDRC0_FLUX_READ_BW		= 0x31F</div><div class="line">DDRC0_FLUX_WRITE_BW		= 0x320</div><div class="line">DDRC0_FLUX_READ_LAT		= 0x321</div><div class="line">DDRC0_FLUX_WRITE_LAT		= 0x322</div><div class="line">DDRC1_FLUX_READ_BW		= 0x323</div><div class="line">DDRC1_FLUX_WRITE_BW		= 0x324</div><div class="line">DDRC1_FLUX_READ_LAT		= 0x325</div><div class="line">DDRC1_FLUX_WRITE_LAT		= 0x326</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># To count LLC_WRITE_NOALLOCATE and LLC_READ_ALLOCATE for TotemC</span></div><div class="line"><span class="variable">$#</span> /usr/lib/linux-tols-3.19.0-23/perf <span class="built_in">stat</span> <span class="_">-e</span> r24f303 <span class="_">-e</span> r24f300 ls <span class="_">-l</span></div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># To count MN_EO_BARR_REQ and LLC_READ_ALLOCATE for TotemA</span></div><div class="line"><span class="variable">$#</span> /usr/lib/linux-tols-3.19.0-23/perf <span class="built_in">stat</span> <span class="_">-e</span> r1bf316 <span class="_">-e</span> r14f300 ls <span class="_">-l</span></div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># To count LLC_READ_HIT and LLC_WRITE_HIT for a process with pid</span></div><div class="line"><span class="variable">$#</span> /usr/lib/linux-tools-3.19.0-23/perf <span class="built_in">stat</span> <span class="_">-e</span> r24f304,r24f305 -p &lt;pid&gt;</div></pre></td></tr></table></figure>
<p>Known Issues:</p>
<ol>
<li><p>As Hisilicon hardware counters are not CPU core specific, the counter values maynot be accurate. To get more accurate count. please append the option “-C 0 -A” in perf stat command.<br><code>$# perf stat -C 0 -A -e r24f303 -e r24f300 ls -l</code></p>
</li>
<li><p>As the counter registers in Hisiilicon are config and accessed via Djtag interface, it can affect the event counter readings as the access is not atomic.</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Toolchains_Guide.4All.md]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/All/Toolchains_Guide.4All/</url>
      <content type="html"><![CDATA[<p>This is the guide for toolchains</p>
<a id="more"></a>
<p>If your host machine and target machine have the different architecture, you have to prepare toolchains before you build any target binaries.</p>
<p>E.g. if you are building an arm-based target binary on Intel machine, you must use them in your host machine.<br>By default, after you do <code>./esutary/build.sh -i toolchain</code>, the toolchain will be install your host machine’s <code>/opt</code> directory.</p>
<p>And the original toolchains files will be download into <code>&lt;project root&gt;/toolchain</code> directory too.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gcc-linaro-aarch64-linux-gnu-4.9-2014.09_linux.tar.xz   <span class="comment"># this is for aarch64 architecture.</span></div><div class="line">gcc-linaro-arm-linux-gnueabihf-4.9-2014.09_linux.tar.xz <span class="comment"># this is for arm32 architecture.</span></div></pre></td></tr></table></figure></p>
<p>Of course, you can install the toolchains yourself with following commands (take the aarch64 as example):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">pushd</span> toolchain</div><div class="line">sudo mkdir -p /opt 2&gt;/dev/null</div><div class="line">sudo tar -xvf gcc-linaro-aarch64-linux-gnu-4.9-2014.09_linux.tar.xz -C /opt</div><div class="line">str=<span class="string">'export PATH=$PATH:/opt/gcc-linaro-aarch64-linux-gnu-4.9-2014.09_linux/bin'</span> </div><div class="line">grep <span class="string">"<span class="variable">$str</span>"</span> ~/.bashrc &gt;/dev/null</div><div class="line"><span class="keyword">if</span> [ x<span class="string">"$?"</span> != x<span class="string">"0"</span> ]; <span class="keyword">then</span> <span class="built_in">echo</span> <span class="string">"<span class="variable">$str</span>"</span>&gt;&gt; ~/.bashrc; <span class="keyword">fi</span></div><div class="line"><span class="built_in">source</span> ~/.bashrc</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Introduction_for_Docker]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/All/Introduction_for_Docker/</url>
      <content type="html"><![CDATA[<p>What is Docker?</p>
<a id="more"></a>
<p>Docker is an open-source project that automates the deployment of applications inside software containers. In details, Docker containers wrap up a piece of software in a complete filesystem that contains everything it needs to run: code, runtime, system tools, system libraries - anything you can install on a server. This guarantees that it will always run the same, regardless of the environment it is running in. Click on the link <a href="https://www.docker.com" target="_blank" rel="external">https://www.docker.com</a> for more information.</p>
<p>Docker organization offers an official storage called Docker Hub for users to pull and push Images. For details please visit the link <a href="https://hub.docker.com" target="_blank" rel="external">https://hub.docker.com</a>. The Docker Images from open-estuary are all stored here, you can visit the link <a href="https://hub.docker.com/u/openestuary" target="_blank" rel="external">https://hub.docker.com/u/openestuary</a>. </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Introduction_for_LAMP_with_Docker]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/All/Introduction_for_LAMP_with_Docker/</url>
      <content type="html"><![CDATA[<p>How to Build LAMP Service with Docker Images?</p>
<a id="more"></a>
<p>This doc is designed to build LAMP service by using Docker Images.</p>
<p>LAMP is an archetypal model of web service solution stacks, which contains four parts: the Linux operating system, the Apache HTTP Server, MySQL, and the PHP programming language. Docker helps developers focus on the web project, not the running environment.</p>
<p>Two Docker Images: openestuary/mysql and openestuary/apache have been developed which are stored in Docker Hub. About how to build lamp service is shown as follow: </p>
<p>You are supposed to have installed Docker successfully and enable Docker service automatically. Then you should pull related Docker Images which will take some time, please be patient. Just type as follows:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker pull openestuary/apache</div><div class="line">$ docker pull openestuary/mysql</div></pre></td></tr></table></figure></p>
<p>After finished above operation, you can start Docker container by using the pulled Images. Just type as follows:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ docker run <span class="_">-d</span> -p 32775:80 --name apache -v /x/xx:/var/www/html openestuary/apache</div><div class="line">$ docker run <span class="_">-d</span> -p 32776:3306 --name mysql openestuary/mysql</div></pre></td></tr></table></figure></p>
<p>Using the two containers named apache and mysql, you only need the source code of the web project. Suppose the web project is stored under /x/xx, we can use the command “-v” to mount the local files into the specified path of the container. The local host will assign a free port to the default port 80 of apache service. Using “-p”, you should check the port is free firstly. It is the same for mysql when assigning a local port mapping the default port 3306 of mysql service.</p>
<p>Mysql container use default username “mysql” and password “123456”. Of course, you can change the configuration of mysql with the following commands<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ docker run <span class="_">-d</span> -P --name mysql \</div><div class="line">      <span class="_">-e</span> MYSQL_USER=xxx \</div><div class="line">      <span class="_">-e</span> MYSQL_PASSWORD=xxx \</div><div class="line">      <span class="_">-e</span> MYSQL_DATABASE=xxx \</div><div class="line">      openestuary/mysql</div></pre></td></tr></table></figure></p>
<p>In order to make it more specific, The use of a PHP page with mysql connection will be demonstrated. If PHP page display normally, the two images are proven to work well. Suppose the local IP is 192.168.1.220. The content of the PHP page named index.php is as follows:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line"><span class="variable">$con</span> = mysql_connect(<span class="string">"192.168.1.220:32776"</span>,<span class="string">"mysql"</span>,<span class="string">"123456"</span>);</div><div class="line"><span class="keyword">if</span> (!<span class="variable">$con</span>)</div><div class="line">&#123;</div><div class="line">die(<span class="string">'Could not connect: '</span> . mysql_error());</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line"><span class="built_in">echo</span> <span class="string">"hello world!"</span>;</div><div class="line">mysql_close(<span class="variable">$con</span>);</div><div class="line">?&gt;</div></pre></td></tr></table></figure></p>
<p>Everything goes well if you see the output “hello world!” at website <a href="http://192.168.1.220:32775/index.php" target="_blank" rel="external">http://192.168.1.220:32775/index.php</a>. Please enjoy the lamp service offered by the two containers named mysql and apache.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[README.armor.lttng.md]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/All/README.armor.lttng/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">LTTNG</a></li>
<li><a href="#2">Ubuntu</a></li>
<li><a href="#3">Fedora</a></li>
<li><a href="#4">OpenSuse</a></li>
</ul>
<a id="more"></a>
<h2 id="LTTNG"><a href="#LTTNG" class="headerlink" title="LTTNG"></a><a name="1">LTTNG</a></h2><p>Installtion and building of lttng kernel modules (lttng-modules-dkms) using apt-get does not work on estuary Ubuntu platform. Thus lttng module build from source code and installed into rootfs.<br>The source code of lttng kernel module worked is lttng-modules-2.6.4.tar.bz2 (ubuntu version) downloaded from <a href="https://lttng.org/download/#build-from-source" target="_blank" rel="external">https://lttng.org/download/#build-from-source</a></p>
<h2 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a><a name="2">Ubuntu</a></h2><ul>
<li><p>LTTNG user space packages are available to install in Ubuntu distribution.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt-get install -y lttng-tools</div><div class="line">apt-get install -y liblttng-ust-dev</div></pre></td></tr></table></figure>
</li>
<li><p>The armor-postinstall.sh script does the lttng user space packages installations on first bootup.</p>
</li>
</ul>
<h2 id="Fedora"><a href="#Fedora" class="headerlink" title="Fedora"></a><a name="3">Fedora</a></h2><ul>
<li><p>LTTNG user space packages are available to install in Fedora distribution.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dnf install -y lttng-tools.aarch64</div><div class="line">dnf install -y lttng-ust.aarch64</div><div class="line">dnf install -y babeltrace.aarch64</div></pre></td></tr></table></figure>
</li>
<li><p>The armor-postinstall.sh script does the lttng user space package installations on first bootup.</p>
</li>
</ul>
<h2 id="OpenSuse"><a href="#OpenSuse" class="headerlink" title="OpenSuse"></a><a name="4">OpenSuse</a></h2><p>LTTNG packages are not available to install in OpenSuse distribution.<br>Thus lttng-tools and lttng-ust to be natively built on target board from source code and</p>
<p>install using the build script present in the <code>/usr/local/armor/build_scripts/build_lttng_tools_opensuse.sh</code><br>in the rootfs.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[README.armor.kgdb.kdb.md]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/All/README.armor.kgdb.kdb/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">Readme for KGDB and KDB Tools</a></li>
<li><a href="#2">Debugging using KGDB</a></li>
</ul>
<a id="more"></a>
<h2 id="Readme-for-KGDB-and-KDB-Tools"><a href="#Readme-for-KGDB-and-KDB-Tools" class="headerlink" title="Readme for KGDB and KDB Tools"></a><a name="1">Readme for KGDB and KDB Tools</a></h2><ol>
<li><p>Enable following configurations in the open-estuary kernel defconfig file, if it is not already done.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">CONFIG_HAVE_ARCH_KGDB=y</div><div class="line">CONFIG_KGDB=y</div><div class="line">CONFIG_KGDB_SERIAL_CONSOLE=y</div><div class="line">CONFIG_KGDB_TESTS=y</div><div class="line">CONFIG_KGDB_KDB=y</div><div class="line">CONFIG_KDB_DEFAULT_ENABLE=0x1</div><div class="line">CONFIG_KDB_KEYBOARD=y</div><div class="line">CONFIG_KDB_CONTINUE_CATASTROPHIC=0</div><div class="line">CONFIG_MAGIC_SYSRQ=y</div></pre></td></tr></table></figure>
</li>
<li><p>Build kernel. </p>
</li>
<li><p>Set Kernel Debugger Boot Arguments (kgdboc=ttyS0,115200) in the grub.conf file as given in the following example.  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">menuentry <span class="string">"ubuntu64-nfs"</span> --id ubuntu64-nfs &#123;</div><div class="line"><span class="built_in">set</span> root=(tftp,192.168.0.3)</div><div class="line">linux /ftp-X/Image rdinit=/init console=ttyS0,115200  kgdboc=ttyS0,115200 earlycon=uart8250,mmio32,0x80300000 ...</div><div class="line">devicetree /ftp-X/hip05<span class="_">-d</span>02.dtb</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Boot the target D02 board with the above grub.conf and kernal image built in step <code>2</code>.</p>
</li>
<li><p>On D02, enter the kernel debugger(kdb) manually or by waiting for an oops or fault.<br>There are several ways you can enter the kernel debugger manually; all involve using the sysrq-g. When logged in as root or with a super user session you can run:<br><code>echo g &gt; /proc/sysrq-trigger</code><br>This will enter kdb terminal and then coninue with kernel debugging using kdb commands.</p>
</li>
</ol>
<h2 id="Debugging-using-KGDB"><a href="#Debugging-using-KGDB" class="headerlink" title="Debugging using KGDB"></a><a id="2">Debugging using KGDB</a></h2><ol>
<li><p>On D02 kdb terminal type ‘kgdb’ command. Then please attach debugger from host machine to remotely debug using gdb.</p>
</li>
<li><p>On the host machine install gdb-multiarch<br><code>sudo adb-get install gdb-multiarch</code>   </p>
</li>
<li><p>run command on the host machine. ‘sudo gdb-multiarch ./vmlinux’<br>where vmlinux is the uncompressed kernel image built in step (2). </p>
</li>
<li><p>On the gdb terminal, run following commands</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(gdb) <span class="built_in">set</span> remote interrupt-sequence Ctrl-C BREAK BREAK-g  -&gt; optional </div><div class="line">(gdb) <span class="built_in">set</span> serial baud 115200 -&gt; <span class="built_in">set</span> serial baud rate</div><div class="line">(gdb) <span class="built_in">set</span> debug remote 1  -&gt; optional <span class="keyword">for</span> more gdb debug messages</div><div class="line">(gdb) target remote /dev/ttyUSB1 -&gt; connect to the kgdb over serial port /dev/ttyUSB1 on host machine.</div><div class="line">(gdb) target remote `/dev/ttyUSB1`</div></pre></td></tr></table></figure>
<p>Remote debugging using <code>/dev/ttyUSB1</code><br>Sending packet: <code>$qSupported:multiprocess+;xmlRegisters=i386;qRelocInsn+#b5...Ack</code><br>……….<br>Sending packet: <code>$g#67...Ack</code><br>Packet received: </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">801b0901c0ffffff01000000000000000000000000000000881b0901c0ffffff1600000000000000ff01000000000000545d5900c0ffffffa066f200c0ffffff5b01000000000000000000000000000006000000000000000090f400c0ffffff06000000000000003000000000000000ffffffffffffff0f1100000000000000010000000000000000000000000000002f33ad44000000003035f500c0ffffff801b0901c0ffffff801b0901c0ffffff801b0901c0ffffffd0d3<span class="built_in">fc</span>00c0ffffff000000000000000000a6e800c0ffffff70e2e200c0ffffff00e00501c0ffffffa0a5e800c0ffffff207ddcf6d1ffffff08e11500c0ffffff207ddcf6d1ffffffbccc1500c0ffffff450000600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000</div></pre></td></tr></table></figure>
<p>Sending packet: <code>$mffffffc00015ccbc,4#15...Ack</code><br>Packet received: <code>208020d4</code><br>arch_kgdb_breakpoint () at <code>./arch/arm64/include/asm/kgdb.h:32</code><br><code>32      ./arch/arm64/include/asm/kgdb.h</code>: No such file or directory.<br>Sending packet: <code>$qSymbol::#5b...Ack</code><br>Packet received:</p>
</li>
<li>Once the gdb successfully connected to the remote kgdb on D02, kernel can be debugged as user space applications using normal gdb commands.</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[README.armor.iptables.md]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/All/README.armor.iptables/</url>
      <content type="html"><![CDATA[<p>How to verify iptables tool</p>
<a id="more"></a>
<p><strong>On D02</strong></p>
<p><code>iptables -A INPUT -s &lt;172.18.45.13&gt; -j REJECT</code>  -&gt; set the rule to reject the packets </p>
<p><code>iptables -L</code> -&gt; shows the added rule</p>
<p><strong>Where</strong></p>
<p><code>172.18.45.60</code> - ip address of D02 board and</p>
<p><code>172.18.45.13</code> - ip address of the PC.</p>
<p><strong>On PC</strong></p>
<p><code>ping &lt;172.18.45.60&gt;</code> -&gt; unreachable as packets are rejected based on above iptables rule.</p>
<p><strong>On D02</strong></p>
<p><code>iptables -D INPUT 1</code> -&gt; delete the rule.</p>
<p><code>iptables -A INPUT -s &lt;172.18.45.13&gt; -j ACCEPT</code>  -&gt; set the rule to accept the packets </p>
<p><code>iptables -L</code> -&gt; shows the added rule</p>
<p><strong>ON PC</strong></p>
<p><code>ping &lt;172.18.45.60&gt;</code> -&gt; work ok as packets are accpeted.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Deploy_Manual.4HiKey.md]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/HiKey/Deploy_Manual.4HiKey/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">Preparation</a><ul>
<li><a href="#2.1">Hardware Connect</a></li>
<li><a href="#2.2">PC Environment</a></li>
<li><a href="#2.3">Image File</a></li>
</ul>
</li>
<li><a href="#3">Upgrade Systerm</a><ul>
<li><a href="#3.1">Flash Uefi image to eMMC</a></li>
<li><a href="#3.2">Flash Boot image to eMMC</a></li>
<li><a href="#3.3">Update Distrubition</a><ul>
<li><a href="#3.3.1">SD card placing this ubuntu systerm</a></li>
<li><a href="#3.3.2">eMMC on HiKey placing this ubuntu systerm</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4">Appendix 1: Partition Information</a> </li>
</ul>
<a id="more"></a>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><a name="1">Introduction</a></h2><p>This documentation provides a general overview for getting started with Estuary Release Distributions such as ubuntu, debian and so on to support the HiKey board, There are two primary ways to install software onto the HiKey board as thissample of ubuntu systerm.<br>First and simplest, you can install uefi image, boot image into eMMC on HiKey board while installing Estuary Release Distributions such as ubuntu, debian and so on into SD card. You can download uefi image and boot image by fastboot mode while using SD card to load Estuary Release Distributions. It follows the instructions in “Update systerm” chapter.<br>Second, you also can install uefi image, boot image and Estuary Release Distributions such as ubuntu, debian and soon into eMMC on HiKey board. You can download uefi image and boot image by fastboot mode while loading Estuary Release Distributions into eMMC by wifi mode. It follows the instructions in “Update systerm” chapter.</p>
<h2 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a><a name="2">Preparation</a></h2><p>The HiKey board is ready to use “out of the box” with a preinstalled version of the Debian Linux distribution from the factory. To get started you need power supply(9V~15V ,2A), a standard microUSB cable, usb to serial port(TTL 1.8V),SD card and PC.</p>
<h3 id="Hardware-Connect"><a href="#Hardware-Connect" class="headerlink" title="Hardware Connect"></a><a name="2.1">Hardware Connect</a></h3><ol>
<li>Connect standard microUSB to USB connector between the HiKey microUSB port and Linux PC.  </li>
<li>Connect usb to serial port to USB connector between the HiKey (UART3 J2) and Linux PC.  </li>
<li>Link 1-2 (J601) pin causes HiKey to auto-power up when power is applied.  </li>
<li>Connect the HiKey power supply to the HiKey board (Uart3 P301).<br>NOTE: please refer to the Hardware User Guide for more information on board link options. you can visit: <a href="http://open-estuary.com/hikey/" target="_blank" rel="external">http://open-estuary.com/hikey/</a></li>
</ol>
<h3 id="PC-Environment"><a href="#PC-Environment" class="headerlink" title="PC Environment"></a><a name="2.2">PC Environment</a></h3><ol>
<li>Ensure PC is Linux systerm.  </li>
<li>Config a serial com on PC such as kermit, mincom and so on.  </li>
<li><p>Install fastboot tool, you do it as follows:  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get update</div><div class="line">$ sudo apt-get install android-tools-fastboot</div></pre></td></tr></table></figure>
</li>
<li><p>Install Python, you can do it as follows:  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get update</div><div class="line">$ sudo apt-get install python2.7 python2.7-dev</div><div class="line">$ <span class="built_in">alias</span> python=python2.7</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Image-File"><a href="#Image-File" class="headerlink" title="Image File"></a><a name="2.3">Image File</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ mkdir hikey-image</div><div class="line">$ <span class="built_in">cd</span> hikey-image</div><div class="line">$ cp &#123;<span class="built_in">pwd</span>&#125;/open-estuary/build/HiKey/binary/* ./  -rf</div><div class="line">$ sudo cp &#123;<span class="built_in">pwd</span>&#125;/open-estuary/build/HiKey/distro/* ./  -rf</div></pre></td></tr></table></figure>
<p>NOTE: you can get more information about Image explaination from this <a href="https://github.com/open-estuary/estuary/blob/master/doc/Readme.4HiKey.md" target="_blank" rel="external">Readme.md</a> document.</p>
<h2 id="Upgrade-Systerm"><a href="#Upgrade-Systerm" class="headerlink" title="Upgrade Systerm"></a><a name="3">Upgrade Systerm</a></h2><p>When most users get HiKey board first, they want to reload the all system image by using instructions. However, this section will describes how to reinstall all system image.</p>
<h3 id="Flash-Uefi-image-to-eMMC"><a href="#Flash-Uefi-image-to-eMMC" class="headerlink" title="Flash Uefi image to eMMC"></a><a name="3.1">Flash Uefi image to eMMC</a></h3><p>The flashing process requires to be in “recovery mode” which will link 1-2 (J601) and link 3-4(J601) with setting board link options as follow:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Name             Link               State</div><div class="line">Auto Power up    Link 1-2           closed</div><div class="line">Boot Select      Link 3-4           closed</div><div class="line">GPIO3-1          Link 5-6           open</div></pre></td></tr></table></figure></p>
<p>Link 1-2 causes HiKey to auto-power up when power is installed. Link 3-4 causes the HiKey SoC internal ROM to start up in at a special “install bootloader” mode which will install a supplied bootloader from the microUSB OTG port into RAM, and will present itself to a connect PC as a ttyUSB device.<br>Note: USB does NOT power the HiKey board because the power supply requirements in certain use cases can exceed the power supply available on a USB port. You must use an external power supply.<br>If you can understand above information, you will start to flash this image according to this instruction:  </p>
<ol>
<li>Turn off HiKey board  </li>
<li>Connect debug UART3 on HiKey to PC (used to monitor debug status)  </li>
<li>Make sure pin1-pin2 and pin3-pin4 on J601 are linked (recovery mode)  </li>
<li>Connect HiKey MicroUSB to PC with USB cable  </li>
<li><p>Turn on HiKey board and flash this image<br>On serial console, you should see some debug message (NULL packet) run HiKey recovery tool to flash l-loader.bin  </p>
<p>Note: if the serial port recorded in hisi-idt.py isn’t available, adjust the command line below by manually setting the serial port with “-d /dev/ttyUSBx” where x is usually the last serial port reported by “dmesg” command</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> hikey-image</div><div class="line">$ sudo python hisi-idt.py <span class="_">-d</span> /dev/ttyUSBx --img1=l-loader.bin</div></pre></td></tr></table></figure>
<p>Do not reboot yet. Run fastboot commands to flash the images (order must be respected)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ sudo fastboot flash ptable ptable-linux.img</div><div class="line">$ sudo fastboot flash fastboot UEFI_HiKey.fd</div><div class="line">$ sudo fastboot flash nvme nvme.img</div></pre></td></tr></table></figure>
</li>
<li><p>Turn off HiKey board</p>
</li>
<li>Remove the jumper of pin3-pin4 on J601</li>
<li>Connected the jumper of pin5-pin6 on J601(fastboot mode)</li>
</ol>
<h3 id="Flash-Boot-image-to-eMMC"><a href="#Flash-Boot-image-to-eMMC" class="headerlink" title="Flash Boot image to eMMC"></a><a name="3.2">Flash Boot image to eMMC</a></h3><p>The boot partition is a 64MB FAT partition and contains kernel/dtb, grub files and so on. You should make the boot-fat.uefi.img image and flash this image according to follow this instruction:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> hikey-image</div><div class="line">$ mkdir boot-fat</div><div class="line">$ dd <span class="keyword">if</span>=/dev/zero of=boot-fat.uefi.img bs=512 count=131072</div><div class="line">$ sudo mkfs.fat -n <span class="string">"BOOT IMG"</span> boot-fat.uefi.img</div><div class="line">$ sudo mount -o loop,rw,sync boot-fat.uefi.img boot-fat</div><div class="line">$ sudo cp Image_HiKey hi6220-hikey.dtb boot-fat/ || <span class="literal">true</span></div><div class="line">$ sudo cp grubaa64.efi grub.cfg boot-fat/ || <span class="literal">true</span></div><div class="line">$ sudo cp mini-rootfs-arm64.cpio.gz boot-fat/mini-rootfs.cpio.gz || <span class="literal">true</span></div><div class="line">$ sudo cp AndroidFastbootApp.efi boot-fat/fastboot.efi</div><div class="line">$ sudo umount boot-fat</div><div class="line">$ rm -rf boot-fat</div></pre></td></tr></table></figure></p>
<p>NOTE: More detail information about how to write this grub.cfg, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Grub_Manual.4All.md" target="_blank" rel="external">GRUB_Manual.md</a> document.</p>
<p>If you finish making boot-fat.uefi.img image, you start to flash this image according to this instruction:  </p>
<ol>
<li>Turn off HiKey board  </li>
<li>Connect debug UART3 on HiKey to PC (used to monitor debug status)  </li>
<li>Make sure pin1-pin2 and pin5-pin6 on J601 are linked (recovery mode)  </li>
<li>Connect HiKey Micro-USB to PC with USB cable  </li>
<li>Turn on HiKey board and flash this image<br><code>$ sudo fastboot flash boot boot-fat.uefi.img</code>  </li>
<li>Turn off HiKey board<h3 id="Update-Distrubition"><a href="#Update-Distrubition" class="headerlink" title=" Update Distrubition"></a><a name="3.3"> Update Distrubition</a></h3></li>
</ol>
<p>You can select SD card or eMMC on HiKey board to place the Estuary release distrubition such as ubuntu. This part will explain how to use SD card and eMMC on HiKey board to boot ubuntu.</p>
<h4 id="SD-card-placing-this-ubuntu-systerm"><a href="#SD-card-placing-this-ubuntu-systerm" class="headerlink" title="SD card placing this ubuntu systerm"></a><a name="3.3.1">SD card placing this ubuntu systerm</a></h4><p>You should partion SD card (8G) and tar this Ubuntu_ARM64.tar.gz into your SD card according to this instruction:</p>
<ol>
<li>Insert SD card into your linux PC by card reader  </li>
<li><p>Grep SD card node and fdisk or partion SD card in your linux PC</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ sudo parted /dev/sdx</div><div class="line">(parted) mklabel gpt</div><div class="line">(parted) mkpart primary ext4 1MB 7086MB</div><div class="line">(parted) q</div><div class="line">$ sudo mkfs.ext4 -L <span class="string">"ubuntu"</span> /dev/sdx1</div></pre></td></tr></table></figure>
</li>
<li><p>Remove and insert SD card in your PC  </p>
</li>
<li><p>Tar Ubuntu_ARM64.tar.gz into your SD card  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> hikey-image	</div><div class="line">$ tar -xvzf Ubuntu_ARM64.tar.gz -C /media/&#123;admin&#125;/ubuntu</div></pre></td></tr></table></figure>
</li>
<li><p>Insert SD card into HiKey board  </p>
</li>
<li>Turn on HiKey board  </li>
<li>Select “grub on eMMC” from uefi options  </li>
<li>Select “Hikey Ubuntu SD card” from grub options  </li>
<li>Success to boot ubunt system<br>NOTE: WIFI config about mini-rootfs systerm please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Setup_HiKey_WiFi_Env.4HiKey.md" target="_blank" rel="external">Setup_HiKey_Wifi_Env.md</a> document</li>
</ol>
<h4 id="eMMC-on-HiKey-placing-this-ubuntu-systerm"><a href="#eMMC-on-HiKey-placing-this-ubuntu-systerm" class="headerlink" title="eMMC on HiKey placing this ubuntu systerm"></a><a name="3.3.2">eMMC on HiKey placing this ubuntu systerm</a></h4><p>If you purchase HiKey board which eMMC is 8G, We recommend you to use eMMC HiKey placing this ubuntu systerm. Estuary provides ptable image which will suport 8G eMMC HiKey board.In return you purchase HiKey board which eMMC is 4G, We recommend you to use SD card placing this ubuntu syterm because Estuary release distribution volume is 4G~5G or so. However, you also may use HiKey board which eMMC is 4G to place this clipping ubuntu systerm.<br>You can place this ubuntu systerm into eMMC on HiKey according to this following instruction:  </p>
<ol>
<li>Turn on HiKey board  </li>
<li>Select “grub on eMMC” from uefi options  </li>
<li>Select “Hikey minilinux eMMC” from grub options (boot min rootfs)  </li>
<li>Refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Setup_HiKey_WiFi_Env.4HiKey.md" target="_blank" rel="external">Setup_HiKey_Wifi_Env.md</a> document to config WIFI link  </li>
<li><p>Download this ubuntu systerm into eMMC on HiKey board  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ mount /dev/mmcblk0p9 /tmp</div><div class="line">$ <span class="built_in">cd</span> /tmp</div><div class="line">$ <span class="literal">false</span>; <span class="keyword">while</span> [ $? <span class="_">-ne</span> 0 ]; <span class="keyword">do</span> wget -c http://7xjz0v.com1.z0.glb.clouddn.com/dist_&lt;version&gt;/Ubuntu_ARM64.tar.gz; <span class="keyword">done</span></div><div class="line">$ tar -xvzf Ubuntu_ARM64.tar.gz</div><div class="line">$ <span class="built_in">cd</span> /</div><div class="line">$ mount /tmp</div></pre></td></tr></table></figure>
</li>
<li><p>Reboot HiKey board  </p>
</li>
<li>Select “grub on eMMC” from uefi options.  </li>
<li>Select “Hikey Ubuntu eMMC” from grub options  </li>
<li>Success to boot ubunt systerm  </li>
</ol>
<p>NOTE: WIFI config about ubuntu systerm please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Setup_HiKey_WiFi_Env.4HiKey.md" target="_blank" rel="external">Setup_HiKey_Wifi_Env.md</a> document</p>
<h3 id="Appendix-1-Partition-Information"><a href="#Appendix-1-Partition-Information" class="headerlink" title="Appendix 1: Partition Information"></a><a name="4">Appendix 1: Partition Information</a></h3><p>Table 1 describes the partition layout on the HiKey eMMC.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Device            Start   End   Sectors  name</div><div class="line">/dev/mmcblk0p1    2048    4095    2048    vrl</div><div class="line">/dev/mmcblk0p2    4096    6143    2048    vrl_backup</div><div class="line">/dev/mmcblk0p3    6144    8191    2048    mcuimage</div><div class="line">/dev/mmcblk0p4    8192   24575   16384    fastboot</div><div class="line">/dev/mmcblk0p5   24576   28671    4096    nvme</div><div class="line">/dev/mmcblk0p6   28672  159743  131072    boot</div><div class="line">/dev/mmcblk0p7  159744  684031  524288    reserved</div><div class="line">/dev/mmcblk0p8  684032 1208319  524288    cache</div><div class="line">/dev/mmcblk0p9 1208320 7818182656         system</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UEFI_Manual.4D05]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/D05/UEFI_Manual.4D05/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">Upgrade UEFI</a></li>
<li><a href="#3">Recover the UEFI when it broke</a><a id="more"></a>
</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><a name="1">Introduction</a></h2><p>UEFI is a kind of BIOS to boot system and provide runtime service to OS which can do some basic IO operation with the runtime service, e.g.: reboot, power off and etc.<br>Normally, there are some trust firmware will be produce from UEFI building, they are responsible for trust reprogram, they include:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UEFI_D05.fd         //UEFI executable binary file.</div></pre></td></tr></table></figure></p>
<p>Where to get them, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Readme.4D05.md" target="_blank" rel="external">Readme.md</a>.</p>
<h2 id="Upgrade-UEFI"><a href="#Upgrade-UEFI" class="headerlink" title="Upgrade UEFI"></a><a name="2">Upgrade UEFI</a></h2><p>Note: This is not necessary unless you want to upgrade UEFI really.</p>
<ol>
<li>Prepare files about UEFI on local computer<br>FTP protocol is used for downloading between hardware boards and local network. Aboveall, please make sure you have a working FTP server in local network, so that board can get needed files from network by FTP.<br>All files mentioned above should be ready firstly, then put them in the root directory of FTP.</li>
<li>Connect the board’s UART port to a host machine<br>Please refer to <a href="https://github.com/open-estuary/estuary/tree/estuary-d05-3.0b/doc/Deploy_Manual.4D05.md" target="_blank" rel="external">Deploy_Manual.4D05.md</a> “Prerequisite” chapter.  </li>
</ol>
<p>If you choose Method 1, use another console window, use <code>board_reboot</code> command to reset the board.<br>If you choose Method 2, press the reset key on the board to reset the board.</p>
<p>when system showing “Press Any key in 10 seconds to stop automatical booting…”, press any key except “enter” key to enter UEFI main menu.</p>
<h3 id="UEFI-menu-introduction"><a href="#UEFI-menu-introduction" class="headerlink" title="UEFI menu introduction"></a>UEFI menu introduction</h3><p>UEFI main menu option is showed as follow:<br>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">continue</span></div><div class="line">select Language            &lt;standard English&gt;</div><div class="line">&gt;Boot Manager</div><div class="line">&gt;Device Manager</div><div class="line">&gt;Boot Maintenance Manager</div></pre></td></tr></table></figure></p>
<p>Choose “Boot Manager” and enter into Boot option menu:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">EFI Misc Device</div><div class="line">EFI Network</div><div class="line">EFI Network 1</div><div class="line">EFI Network 2</div><div class="line">EFI Network 3</div><div class="line">EFI Internal Shell</div><div class="line">ESL Start OS</div><div class="line">Embedded Boot Loader(EBL)</div></pre></td></tr></table></figure></p>
<p>D05 board support 4 on-board network ports at maximun. To enable any one of them by connecting to network cable or optical fiber. From left to right, followed by the two 2GE ports, two 10GE ports which corresponding to UEFI startup interface are EFI Network 2, EFI Network 3, EFI Network 0, EFI Network 1.</p>
<p><em>EFI Internal Shell mode</em> is a standard command shell in UEFI.<br><em>Embedded Boot Loader(EBL) mode</em> is an embedded command shell based on boot loader specially for developers.<br>You can switch between two modes by typing “exit” from one mode to UEFI main menu and then choose the another mode.</p>
<h3 id="Update-UEFI-files"><a href="#Update-UEFI-files" class="headerlink" title="Update UEFI files"></a>Update UEFI files</h3><ul>
<li><p>IP address config at “EFI Internal Shell” mode(Optional, you can ignore this step if DHCP works well)<br>Press any key except “enter” key to enter UEFI main menu. Select “Boot Manager”-&gt;”EFI Internal Shell”.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifconfig <span class="_">-s</span> eth0 static &lt;IP address&gt; &lt;mask&gt; &lt;gateway&gt;</div></pre></td></tr></table></figure>
<p>e.g.:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifconfig <span class="_">-s</span> eth0 static 192.168.1.4 255.255.255.0 192.168.1.1</div></pre></td></tr></table></figure>
</li>
<li><p>Burn BIOS file at “Embedded Boot Loader(EBL)” mode<br>Enter “exit” from “EFI Internal Shell” mode to the UEFI main menu and choose “Boot Manager”-&gt; “Embedded Boot Loader(EBL)”after setting the IP address done.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Download file from FTP server to board's RAM</span></div><div class="line">provision &lt;server IP&gt; -u &lt;ftp user name&gt; -p &lt;ftp password&gt; <span class="_">-f</span> &lt;UEFI binary&gt; <span class="_">-a</span> &lt;download target address&gt;</div><div class="line"><span class="comment"># Write the data into NORFLASH</span></div><div class="line">spiwfmem &lt;<span class="built_in">source</span> address&gt; &lt;target address&gt; &lt;data length&gt;</div></pre></td></tr></table></figure>
<p>e.g.:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">provision 192.168.1.107 -u sch -p aaa <span class="_">-f</span> UEFI_D05.fd <span class="_">-a</span> 0x100000</div><div class="line">spiwfmem 0x100000 0x0000000 0x300000</div></pre></td></tr></table></figure>
</li>
<li><p>Power off and reboot board again.</p>
</li>
</ul>
<h2 id="Recover-the-UEFI-when-it-broke"><a href="#Recover-the-UEFI-when-it-broke" class="headerlink" title="Recover the UEFI when it broke"></a><a name="3">Recover the UEFI when it broke</a></h2><ol>
<li>Connect board’s BMC port to the network port of your ubuntu host.</li>
<li>Configure board’s BMC IP and your ubuntu host’s IP at the same network segment.</li>
<li><p>Login the BMC website, The <code>username/passwd</code> are <code>root/Huawei12#$</code>. Click “system”, click “Firmware upgrade”, click “Browse” to choose the hpm formate uefi file(Please contact support@open-estuary.org to get the hpm formate uefi file).</p>
<p>Note: Usually BMC website can be visited by (<a href="https://192.168.2.100" target="_blank" rel="external">https://192.168.2.100</a>) by default. If BMC IP have modified by somebody, please take the following steps to find modified BMC IP</p>
<ul>
<li>Pull out the power cable. Find the pin named “<code>COM_SW</code>“ at <code>J44</code>. Then connect it.</li>
<li>Power on the board, connect the board’s serial port to your ubuntu serial port. When the screen display message “You are trying to access a restricted zone. Only Authorized Users allowed.”, type “Enter” key, input <code>username/passwd</code>, the <code>username/passwd</code> are <code>root/Huawei12#$</code>.</li>
<li>After you login the BMC interface which start with “<code>iBMC:/-&gt;</code>“, use command “<code>ifconfig</code>“ to see the modified BMC IP.</li>
<li>When you get the board’s BMC IP, please visit the BMC website by <code>https://&lt;board&#39;s BMC IP&gt;</code></li>
</ul>
</li>
<li>Click “Start update”(Do not power off during this period).</li>
<li>After updated UFEI file, reboot the board to enter UEFI menu.</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Readme.4HiKey.md]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/HiKey/Readme.4HiKey/</url>
      <content type="html"><![CDATA[<p>This is the readme file for HiKey platform</p>
<a id="more"></a>
<p>Above all, you need install some applications firstly as follows:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install -y wget automake1.11 make bc libncurses5-dev libtool li</div><div class="line">bc6:i386 libncurses5:i386 libstdc++6:i386 lib32z1 bison flex uuid-dev build-esse</div><div class="line">ntial iasl gcc zlib1g-dev libperl-dev libgtk2.0-dev libfdt-dev</div></pre></td></tr></table></figure></p>
<p>After you executed <code>./estuary/build.sh --file=./estuary/estuarycfg.json --builddir=./workspace</code> for HiKey, all targets files will be produced. they are:</p>
<h3 id="l-loader-bin"><a href="#l-loader-bin" class="headerlink" title="l-loader.bin"></a>l-loader.bin</h3><h3 id="ptable-linux-img"><a href="#ptable-linux-img" class="headerlink" title="ptable-linux.img"></a>ptable-linux.img</h3><h3 id="AndroidFastbootApp-efi"><a href="#AndroidFastbootApp-efi" class="headerlink" title="AndroidFastbootApp.efi"></a>AndroidFastbootApp.efi</h3><h3 id="UEFI-HiKey-fd"><a href="#UEFI-HiKey-fd" class="headerlink" title="UEFI_HiKey.fd"></a>UEFI_HiKey.fd</h3><p><strong>description</strong>: l-loader.bin - used to switch from aarch32 to aarch64 and boot, UEFI_HiKey.fd is the UEFI bios for HiKey, ptable-linux.img - partition tables for Linux images.<br><strong>target</strong>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;project root&gt;/workspace/binary/HiKey/l-loader.bin</div><div class="line"></div><div class="line">&lt;project root&gt;/workspace/binary/HiKey/ptable-linux.img</div><div class="line"></div><div class="line">&lt;project root&gt;/workspace/binary/HiKey/AndroidFastbootApp.efi</div><div class="line"></div><div class="line">&lt;project root&gt;/workspace/binary/HiKey/UEFI_HiKey.fd.</div></pre></td></tr></table></figure></p>
<p><strong>source</strong>: <code>&lt;project root&gt;/uefi</code></p>
<p>build commands(supposedly, you are in <code>&lt;project root&gt;</code> currently:</p>
<p><code>./estuary/submodules/build-uefi.sh --platform=HiKey --output=workspace</code></p>
<h3 id="grubaa64-efi"><a href="#grubaa64-efi" class="headerlink" title="grubaa64.efi"></a>grubaa64.efi</h3><p><strong>description</strong>: grubaa64.efi is used to load kernel image and dtb files from SD card, nandflash into RAM and start the kernel.<br><strong>target</strong>: <code>&lt;project root&gt;/workspace/binary/arm64/grubaa64.efi</code><br><strong>source</strong>: <code>&lt;project root&gt;/grub</code>  </p>
<p>build commands(supposedly, you are in <code>&lt;project root&gt;</code> currently:<br><code>./estuary/submodules/build-grub.sh --output=./workspace</code>, if your host is not arm architecture, please execute<code>build-grub.sh --output=./workspace --cross=aarch64-linux-gnu-</code></p>
<p>Note: more details about how to install gcc-linaro-aarch64-linux-gnu-4.9-2014.09_linux, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md" target="_blank" rel="external">https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md</a>.</p>
<h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><h3 id="hi6220-hikey-dtb"><a href="#hi6220-hikey-dtb" class="headerlink" title="hi6220-hikey.dtb"></a>hi6220-hikey.dtb</h3><p><strong>descriptions</strong>: Image is the kernel executable program, and hi6220-hikey.dtb is the device tree binary.<br><strong>target</strong>: Image in <code>&lt;project root&gt;/workspace/binary/arm64/Image</code><br>hi6220-hikey.dtb in <code>&lt;project root&gt;/workspace/binary/HiKey/hi6220-hikey.dtb</code><br><strong>source</strong>: <code>&lt;project root&gt;/kernel</code>  </p>
<p>build commands(supposedly, you are in <code>&lt;project root&gt;</code> currently):<br><code>./estuary/submodules/build-kernel.sh --platform=HiKey --output=workspace</code>, if your host is not arm architecture, please execute <code>./estuary/submodules/build-kernel.sh --platform=HiKey --output=workspace --cross=aarch64-linux-gnu-</code>.</p>
<p>Note: more details about how to install gcc-linaro-aarch64-linux-gnu-4.9-2014.09_linux, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md" target="_blank" rel="external">https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md</a>.</p>
<p>If you get more information about uefi, please visit <a href="https://github.com/96boards/documentation/wiki/HiKeyUEFI" target="_blank" rel="external">https://github.com/96boards/documentation/wiki/HiKeyUEFI</a><br>More detail information about how to deploy target system into HiKey board, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Deploy_Manual.4HiKey.md" target="_blank" rel="external">Deploy_Manual.4HiKey.md</a>.<br>More detail information about how to config this WiFi function into HiKey board, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Setup_HiKey_WiFi_Env.4HiKey.md" target="_blank" rel="external">Setup_HiKey_Wifi_Env.md</a>.<br>More detail information about distributions, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Distributions_Guide.4All.md" target="_blank" rel="external">Distributions_Guider.md</a>.<br>More detail information about toolchains, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md" target="_blank" rel="external">Toolchains_Guider.md</a>.<br>More detail information about how to benchmark system, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Caliper_Manual.4All.md" target="_blank" rel="external">Caliper_Manual.md</a>.<br>More detail information about how to access remote boards in OpenLab, please refer to <a href="http://open-estuary.org/accessing-boards-in-open-lab/" target="_blank" rel="external">Boards_in_OpenLab</a>.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Quick_Deployment.4D05]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/D05/Quick_Deployment.4D05/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">Quick Deploy System</a><ul>
<li><a href="#2.1">Deploy system via USB Disk</a></li>
<li><a href="#2.2">Deploy system via DVD/BMC</a></li>
<li><a href="#2.3">Deploy system via PXE</a><a id="more"></a>
</li>
</ul>
</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><a name="1">Introduction</a></h2><p>Above all, prepare hardware boards with SCSI disk and download Estuary source code from GitHub.<br>To learn more about how to do them, please visit this web site: <a href="http://open-estuary.com/estuary-user-manual/" target="_blank" rel="external">http://open-estuary.com/estuary-user-manual/</a>, and then refer to ‘Get &amp; Build Estuary yourself’.<br>Note: In my case, the working directory is <code>~/workdir</code>.</p>
<h2 id="Quick-Deploy-System"><a href="#Quick-Deploy-System" class="headerlink" title="Quick Deploy System"></a><a name="2">Quick Deploy System</a></h2><h3 id="Deploy-system-via-USB-Disk"><a href="#Deploy-system-via-USB-Disk" class="headerlink" title="Deploy system via USB Disk"></a><a name="2.1">Deploy system via USB Disk</a></h3><ol>
<li>Prepare usb install disk.<ul>
<li>Modify <code>estuary/estuarycfg.json</code>. Make sure the platform, distros are all right.</li>
<li>Change the value of “install” to “yes” in object “setup” for usb and the value “device” to your USB install disk.<br>(Notice: if the specified usb device does not exist, the first usb device will be selected by default.)</li>
<li>Use <code>build.sh</code> to create the usb install disk.<br>eg: <code>./estuary/build.sh -f estuary/estuarycfg.json</code></li>
</ul>
</li>
<li>Connect the usb install disk to the board.</li>
<li>Reboot the board.</li>
<li>Boot from the usb device. (About how to boot from USB device, please refer to the UEFI related manual.)</li>
<li>According to the prompt to deploy the system.</li>
<li>Start the boards from “grub” menu of UEFI by default.</li>
</ol>
<h3 id="Deploy-system-via-DVD-BMC"><a href="#Deploy-system-via-DVD-BMC" class="headerlink" title="Deploy system via DVD/BMC"></a><a name="2.2">Deploy system via DVD/BMC</a></h3><ol>
<li>Prepare ISO image and install disk.<ul>
<li>Modify <code>estuary/estuarycfg.json</code>. Make sure the platform, distros are all right.</li>
<li>Change the value of “install” to “yes” in object “setup” for iso and the value “name” to your target iso image file name.</li>
<li>Use <code>build.sh</code> to create the target install iso image file.<br>eg: <code>./estuary/build.sh -f estuary/estuarycfg.json</code></li>
</ul>
</li>
<li>Via DVD<ul>
<li>Burn the iso image file to DVD disk if you use the physical DVD driver.</li>
<li>Connect the physical DVD driver to the board, plug in the install DVD disk.</li>
<li>Reboot the board.</li>
<li>Boot from the DVD device. (About how to boot from DVD device, please refer to the UEFI related manual.)</li>
<li>According to the prompt to deploy the system.</li>
<li>Start the boards from “grub” menu of UEFI by default.</li>
</ul>
</li>
<li>Via BMC<ul>
<li>Login BMC website of specified IP with browser(IE browser is suggested to use), The <code>username</code> &amp; <code>password</code> is <code>root</code> &amp; <code>Huawei12#$</code>.</li>
<li>Click “Remote” on the top of BMC webiste. Select “Remote Virtual Console (Private Mode)” to enter into KVM interface. Click “Image File” and choose the iso image, then click “Connect” button.</li>
<li>Click “Config” on the top of BMC website, click “Boot Option” to select “DVD-ROM drive”, then click “Save” button.</li>
<li>Reboot the board</li>
<li>According to the prompt to deploy the system.</li>
</ul>
</li>
</ol>
<h3 id="Deploy-system-via-PXE"><a href="#Deploy-system-via-PXE" class="headerlink" title="Deploy system via PXE"></a><a name="2.3">Deploy system via PXE</a></h3><ol>
<li>Connect Ubuntu PC and hardware boards into the same local area network. (Make sure the PC can connect to the internet and no other PXE servers exist.)</li>
<li>Modify the configuration file of <code>estuary/estuarycfg.json</code> based on you hardware boards. Change the values of mac to physical addresses of the connected network cards on the board. Change the value of “install” to “yes” in object “setup” for PXE.</li>
<li>Backup files under the tftp root directory if necessary. Use <code>build.sh</code> to build the  project and setup the PXE server on Ubuntu PC.<br>eg: <code>./estuary/build.sh -f estuary/estuarycfg.json</code></li>
<li>After that, install minicom and connect the serial ports of hardware boards to the Ubuntu PC. Connect the hardware boards by minicom using serial ports.</li>
<li>Reboot the hardware boards and start the boards from the correct EFI Network.</li>
<li>Install the system according to prompt. After install finished, the boards will restart automatically.</li>
<li>Start the boards from “grub” menu of UEFI by default.</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Readme.4QEMU.md]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/QEMU/Readme.4QEMU/</url>
      <content type="html"><![CDATA[<p>This is the readme file for QEMU platform</p>
<a id="more"></a>
<p>After you do <code>./estuary/build.sh -p QEMU -d Ubuntu</code>, all targets files will be produced into <code>&lt;project root&gt;/build/QEMU</code> directory, they are: UEFI, grub and dtb files are not necessary for QEMU platform</p>
<h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><p><strong>descriptions</strong>: Image is the kernel executable program.<br><strong>target</strong>: <code>&lt;project root&gt;/build/QEMU/kernel/arch/arm64/boot/Image</code><br><strong>source</strong>: <code>&lt;project root&gt;/kernel</code><br><strong>Note</strong>: Before compiling kernel, gcc-linaro-aarch64-linux-gnu-4.9-2014.09_linux(<a href="https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md" target="_blank" rel="external">https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md</a>) and libssl-dev should be installed first.</p>
<p>build commands(supposedly, you are in <code>&lt;project root&gt;</code>currently):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">build_dir=build</div><div class="line">KERNEL_DIR=kernel</div><div class="line">mkdir -p <span class="variable">$build_dir</span>/QEMU/<span class="variable">$KERNEL_DIR</span> 2&gt;/dev/null</div><div class="line">kernel_dir=<span class="variable">$build_dir</span>/QEMU/<span class="variable">$KERNEL_DIR</span></div><div class="line">KERNEL_BIN=<span class="variable">$kernel_dir</span>/arch/arm64/boot/Image</div><div class="line">CFG_FILE=defconfig</div><div class="line">DTB_BIN=</div><div class="line"><span class="built_in">export</span> ARCH=arm64</div><div class="line"><span class="built_in">export</span> CROSS_COMPILE=aarch64-linux-gnu-</div><div class="line"></div><div class="line"><span class="built_in">pushd</span> <span class="variable">$KERNEL_DIR</span>/</div><div class="line"></div><div class="line">git clean -fdx</div><div class="line">git reset --hard</div><div class="line">sudo rm -rf ../<span class="variable">$kernel_dir</span>/*</div><div class="line">make O=../<span class="variable">$kernel_dir</span> mrproper</div><div class="line"></div><div class="line">./scripts/kconfig/merge_config.sh -O ../<span class="variable">$kernel_dir</span> -m arch/arm64/configs/defconfig \</div><div class="line">arch/arm64/configs/distro.config arch/arm64/configs/estuary_defconfig arch/arm64/configs/qemu_defconfig</div><div class="line">mv <span class="_">-f</span> ../<span class="variable">$kernel_dir</span>/.config ../<span class="variable">$kernel_dir</span>/.merged.config</div><div class="line">make O=../<span class="variable">$kernel_dir</span> KCONFIG_ALLCONFIG=../<span class="variable">$kernel_dir</span>/.merged.config alldefconfig</div><div class="line"></div><div class="line">make O=../<span class="variable">$kernel_dir</span> -j<span class="variable">$&#123;corenum&#125;</span> <span class="variable">$&#123;KERNEL_BIN##*/&#125;</span></div><div class="line"></div><div class="line">dtb_dir=<span class="variable">$&#123;DTB_BIN#*arch/&#125;</span></div><div class="line">dtb_dir=<span class="variable">$&#123;DTB_BIN%/*&#125;</span></div><div class="line">dtb_dir=../<span class="variable">$&#123;kernel_dir&#125;</span>/arch/<span class="variable">$&#123;dtb_dir&#125;</span></div><div class="line"></div><div class="line">mkdir -p <span class="variable">$dtb_dir</span> 2&gt;/dev/null</div><div class="line"></div><div class="line">make O=../<span class="variable">$kernel_dir</span> <span class="variable">$&#123;DTB_BIN#*/boot/dts/&#125;</span></div></pre></td></tr></table></figure></p>
<h3 id="qemu-system-aarch64"><a href="#qemu-system-aarch64" class="headerlink" title="qemu-system-aarch64"></a>qemu-system-aarch64</h3><p><strong>descriptions</strong>: qemu-system-aarch64 is the QEMU executable program.<br><strong>target</strong>: <code>&lt;project root&gt;/build/qemu/bin/qemu-system-aarch64</code><br><strong>source</strong>: <code>&lt;project root&gt;/qemu</code><br>build commands(supposedly, you are in <project root=""> currently):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install -y gcc zlib1g-dev libperl-dev libgtk2.0-dev libfdt-dev</div><div class="line"></div><div class="line"><span class="built_in">pushd</span> qemu</div><div class="line">./configure --prefix=<span class="string">"/home/user/qemubuild"</span> --target-list=aarch64-softmmu</div><div class="line">make -j14</div><div class="line">make install</div><div class="line"><span class="built_in">popd</span></div><div class="line"></div><div class="line">/home/user/qemubuild/qemu-system-aarch64 -machine virt -cpu cortex<span class="_">-a</span>57 \</div><div class="line">    -kernel &lt;project root&gt;/build/QEMU/binary/Image_QEMU \</div><div class="line">    -drive <span class="keyword">if</span>=none,file=&lt;distribution image&gt;,id=fs \</div><div class="line">    -device virtio-blk-device,drive=fs \</div><div class="line">    -append <span class="string">"console=ttyAMA0 root=/dev/vda rw"</span> \</div><div class="line">    -nographic</div></pre></td></tr></table></figure></project></p>
<p>More detail about distributions, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Distributions_Guide.4All.md" target="_blank" rel="external">Distributions_Guide.md</a>.<br>More detail about toolchains, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md" target="_blank" rel="external">Toolchains_Guide.md</a>.<br>More detail about how to debug, analyse, diagnose system, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Armor_Manual.4All.md" target="_blank" rel="external">Armor_Manual.md</a>.<br>More detail about how to benchmark system, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Caliper_Manual.4All.md" target="_blank" rel="external">Caliper_Manual.md</a>.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Readme.4D05]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/D05/Readme.4D05/</url>
      <content type="html"><![CDATA[<p>This is the readme file for D05 platform<br><a id="more"></a></p>
<p>After you executed<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./estuary/build.sh --file=./estuary/estuarycfg.json --builddir=./workspace</div></pre></td></tr></table></figure></p>
<p>for D05, all targets files will be produced. they are:</p>
<h3 id="UEFI-D05-fd"><a href="#UEFI-D05-fd" class="headerlink" title="UEFI_D05.fd"></a>UEFI_D05.fd</h3><p><strong>description</strong>: UEFI_D05.fd is the UEFI bios for D05 platform.<br><strong>target</strong>: <code>&lt;project root&gt;/workspace/binary/D05/UEFI_D05.fd</code><br><strong>source</strong>: <code>&lt;project root&gt;/uefi</code></p>
<p>build commands(supposedly, you are in <code>&lt;project root&gt;</code> currently):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./estuary/submodules/build-uefi.sh --platform=D05 --output=workspace</div></pre></td></tr></table></figure></p>
<h3 id="grubaa64-efi"><a href="#grubaa64-efi" class="headerlink" title="grubaa64.efi"></a>grubaa64.efi</h3><p><strong>description</strong>: grubaa64.efi is used to load kernel image and dtb files from SATA, SAS, USB Disk, or NFS into RAM and start the kernel.<br><strong>target</strong>: <code>&lt;project root&gt;/workspace/binary/arm64/grubaa64.efi</code><br><strong>source</strong>: <code>&lt;project root&gt;/grub</code></p>
<p>build commands(supposedly, you are in <code>&lt;project root&gt;</code> currently):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./estuary/submodules/build-grub.sh --output=./workspace</div></pre></td></tr></table></figure></p>
<p>if your host is not arm architecture, please execute<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./estuary/submodules/build-grub.sh --output=./workspace --cross=aarch64-linux-gnu-</div></pre></td></tr></table></figure></p>
<p>Note: more details about how to install <code>gcc-linaro-aarch64-linux-gnu-4.9-2014.09_linux</code>, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md" target="_blank" rel="external">https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md</a>.</p>
<h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><p><strong>descriptions</strong>: Image is the kernel executable program.<br><strong>target</strong>: <code>&lt;project root&gt;/workspace/binary/arm64/Image</code><br><strong>source</strong>: <code>&lt;project root&gt;/kernel</code></p>
<p>build commands(supposedly, you are in <code>&lt;project root&gt;</code> currently):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./estuary/submodules/build-kernel.sh --platform=D05 --output=workspace</div></pre></td></tr></table></figure></p>
<p>if your host is not arm architecture, please execute<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./estuary/submodules/build-kernel.sh --platform=D05 --output=workspace --cross=aarch64-linux-gnu-.</div></pre></td></tr></table></figure></p>
<p>Note:<br>more details about how to install <code>gcc-linaro-aarch64-linux-gnu-4.9-2014.09_linux</code>, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md" target="_blank" rel="external">https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md</a>.<br>More detail about distributions, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Distributions_Guide.4All.md" target="_blank" rel="external">Distributions_Guide.md</a>.<br>More detail about toolchains, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md" target="_blank" rel="external">Toolchains_Guide.md</a>.<br>More detail about how to deploy target system into D05 board, please refer to <a href="https://github.com/open-estuary/estuary/blob/estuary-d05-3.0b/doc/Deploy_Manual.4D05.md" target="_blank" rel="external">Deployment_Manual.md</a>.<br>More detail about how to debug, analyse, diagnose system, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Armor_Manual.4All.md" target="_blank" rel="external">Armor_Manual.md</a>.<br>More detail about how to benchmark system, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Caliper_Manual.4All.md" target="_blank" rel="external">Caliper_Manual.md</a>.<br>More detail about how to access remote boards in OpenLab, please refer to <a href="http://open-estuary.org/accessing-boards-in-open-lab/" target="_blank" rel="external">Boards_in_OpenLab</a>.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[UEFI_Manual.4D03]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/D03/UEFI_Manual.4D03/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">Upgrade UEFI</a></li>
<li><a href="#3">Recover the UEFI when it broke</a><a id="more"></a>
</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><a id="1">Introduction</a></h2><p>UEFI is a kind of BIOS to boot system and provide runtime service to OS which can do some basic IO operation with the runtime service, e.g.: reboot, power off and etc.<br>Normally, there are some trust firmware will be produce from UEFI building, they are responsible for trust reprogram, they include:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UEFI_D03.fd         //UEFI executable binary file.</div><div class="line">CH02TEVBC_V03.bin   //CPLD binary to control power supplier.</div></pre></td></tr></table></figure></p>
<p>Where to get them, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Readme.4D03.md" target="_blank" rel="external">Readme.md</a>.</p>
<h2 id="Upgrade-UEFI"><a href="#Upgrade-UEFI" class="headerlink" title="Upgrade UEFI"></a><a name="2">Upgrade UEFI</a></h2><p>Note: This is not necessary unless you want to upgrade UEFI really.</p>
<ol>
<li>Prepare files about UEFI on local computer<br>FTP protocol is used for downloading between hardware boards and local network. Above all, please make sure you have a working FTP server in local network, so that board can get needed files from network by FTP.<br>All files mentioned above should be ready firstly, then put them in the root directory of FTP.</li>
<li>Connect the board’s UART port to a host machine<br>Please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Deploy_Manual.4D03.md" target="_blank" rel="external">Deploy_Manual.4D03.md</a> “Prerequisite” chapter.</li>
</ol>
<p>If you choose Method 1, use another console window, use <code>board_reboot</code> command to reset the board.<br>If you choose Method 2, press the reset key on the board to reset the board.</p>
<p>when system showing “Press Any key in 10 seconds to stop automatical booting…”, press any key except “enter” key to enter UEFI main menu.</p>
<h3 id="UEFI-menu-introduction"><a href="#UEFI-menu-introduction" class="headerlink" title="UEFI menu introduction"></a>UEFI menu introduction</h3><p>UEFI main menu option is showed as follow:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">continue</span></div><div class="line">select Language            &lt;standard English&gt;</div><div class="line">&gt;Boot Manager</div><div class="line">&gt;Device Manager</div><div class="line">&gt;Boot Maintenance Manager</div></pre></td></tr></table></figure></p>
<p>Choose “Boot Manager” and enter into Boot option menu:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">EFI Misc Device</div><div class="line">EFI Network</div><div class="line">EFI Network 1</div><div class="line">EFI Network 2</div><div class="line">EFI Network 3</div><div class="line">EFI Internal Shell</div><div class="line">ESL Start OS</div><div class="line">Embedded Boot Loader(EBL)</div></pre></td></tr></table></figure></p>
<p>D03 board support 4 on-board network ports at maximun. To enable any one of them by connecting to network cable or optical fiber. From left to right, followed by the two 2GE ports, two 10GE ports which corresponding to UEFI startup interface are EFI Network 2, EFI Network 3, EFI Network 0, EFI Network 1.</p>
<p><em>EFI Internal Shell mode</em> is a standard command shell in UEFI.<br><em>Embedded Boot Loader(EBL) mode</em> is an embedded command shell based on boot loader specially for developers.<br>You can switch between two modes by typing “exit” from one mode to UEFI main menu and then choose the another mode.</p>
<h3 id="Update-UEFI-files"><a href="#Update-UEFI-files" class="headerlink" title="Update UEFI files"></a>Update UEFI files</h3><ul>
<li><p>IP address config at “EFI Internal Shell” mode(Optional, you can ignore this step if DHCP works well)</p>
<p>Press any key except “enter” key to enter UEFI main menu. Select “Boot Manager”-&gt;”EFI Internal Shell”.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifconfig <span class="_">-s</span> eth0 static &lt;IP address&gt; &lt;mask&gt; &lt;gateway&gt;</div></pre></td></tr></table></figure>
<p>e.g.:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ifconfig -s eth0 static 192.168.1.4 255.255.255.0 192.168.1.1</div></pre></td></tr></table></figure>
</li>
<li><p>Burn BIOS file at “Embedded Boot Loader(EBL)” mode  </p>
<p>Enter “exit” from “EFI Internal Shell” mode to the UEFI main menu and choose “Boot Manager”-&gt; “Embedded Boot Loader(EBL)”after setting the IP address done.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Download file from FTP server to board's RAM</span></div><div class="line">provision &lt;server IP&gt; -u &lt;ftp user name&gt; -p &lt;ftp password&gt; <span class="_">-f</span> &lt;UEFI binary&gt; <span class="_">-a</span> &lt;download target address&gt;</div><div class="line"><span class="comment"># Write the data into NORFLASH</span></div><div class="line">spiwfmem &lt;<span class="built_in">source</span> address&gt; &lt;target address&gt; &lt;data length&gt;</div></pre></td></tr></table></figure>
<p>e.g.:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">provision 192.168.1.107 -u sch -p aaa <span class="_">-f</span> UEFI_D03.fd <span class="_">-a</span> 0x100000</div><div class="line">spiwfmem 0x100000 0x0000000 0x300000</div></pre></td></tr></table></figure>
</li>
<li><p>Power off and reboot board again.</p>
</li>
</ul>
<h2 id="Recover-the-UEFI-when-it-broke"><a href="#Recover-the-UEFI-when-it-broke" class="headerlink" title="Recover the UEFI when it broke"></a><a name="3">Recover the UEFI when it broke</a></h2><ol>
<li>Connect board’s BMC port to the network port of your ubuntu host.</li>
<li>Configure board’s BMC IP and your ubuntu host’s IP at the same network segment.</li>
<li><p>Login the BMC website, The <code>username/passwd</code> is <code>root/Huawei12#$</code>. Click “system”, click “Firmware upgrade”, click “Browse” to choose the hpm formate uefi file(Please contact support@open-estuary.org to get the hpm formate uefi file).</p>
<p>Note: Usually BMC website can be visited by (<a href="https://192.168.2.100" target="_blank" rel="external">https://192.168.2.100</a>) by default. If BMC IP have modified by somebody, please take the following steps to find modified BMC IP</p>
<ul>
<li>Pull out the power cable. Find the pin named “<code>COM_SW</code>“ at <code>J44</code>. Then connect it.</li>
<li>Power on the board, connect the board’s serial port to your ubuntu serial port. When the screen display message “You are trying to access a restricted zone. Only Authorized Users allowed.”, type “Enter” key, input <code>username/passwd</code>, the <code>username/passwd</code> are <code>root/Huawei12#$</code>.</li>
<li>After you login the BMC interface which start with “<code>iBMC:/-&gt;</code>“, use command “<code>ifconfig</code>“ to see the modified BMC IP.</li>
<li>When you get the board’s BMC IP, please visit the BMC website by <code>https://&lt;board&#39;s BMC IP&gt;</code></li>
</ul>
</li>
<li>Click “Start update”(Do not power off during this period).</li>
<li>After updated UFEI file, reboot the board to enter UEFI menu.</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Readme.4D02.md]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/D02/Readme.4D02/</url>
      <content type="html"><![CDATA[<p>This is the readme file for D02 platform</p>
<a id="more"></a>
<p>After you executed <code>./estuary/build.sh --file=./estuary/estuarycfg.json --builddir=./workspace</code> for D02, all targets files will be produced. they are:</p>
<h3 id="UEFI-D02-fd"><a href="#UEFI-D02-fd" class="headerlink" title="UEFI_D02.fd"></a>UEFI_D02.fd</h3><p><strong>description</strong>: UEFI_D02.fd is the UEFI bios for D02 platform.<br><strong>target</strong>: <code>&lt;project root&gt;/workspace/binary/D02/UEFI_D02.fd</code><br><strong>source</strong>: <code>&lt;project root&gt;/uefi</code></p>
<p>build commands(supposedly, you are in <code>&lt;project root&gt;</code> currently):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./estuary/submodules/build-uefi.sh --platform=D02 --output=workspace</div></pre></td></tr></table></figure></p>
<h3 id="grubaa64-efi"><a href="#grubaa64-efi" class="headerlink" title="grubaa64.efi"></a>grubaa64.efi</h3><p><strong>description</strong>: grubaa64.efi is used to load kernel image and dtb files from SATA, SAS, USB Disk, or NFS into RAM and start the kernel.<br><strong>target</strong>: <code>&lt;project root&gt;/workspace/binary/arm64/grubaa64.efi</code><br><strong>source</strong>: <code>&lt;project root&gt;/grub</code></p>
<p>build commands(supposedly, you are in <code>&lt;project root&gt;</code> currently):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./estuary/submodules/build-grub.sh --output=./workspace</div></pre></td></tr></table></figure></p>
<p>if your host is not arm architecture, please execute<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./estuary/submodules/build-grub.sh --output=./workspace --cross=aarch64-linux-gnu-</div></pre></td></tr></table></figure></p>
<p>Note: more details about how to install gcc-linaro-aarch64-linux-gnu-4.9-2014.09_linux, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md" target="_blank" rel="external">https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md</a>.</p>
<h3 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h3><h3 id="hip05-d02-dtb"><a href="#hip05-d02-dtb" class="headerlink" title="hip05-d02.dtb"></a>hip05-d02.dtb</h3><p><strong>descriptions</strong>: Image is the kernel executable program and hip05-d02.dtb is the device tree binary.<br><strong>target</strong>:<br>Image in <code>&lt;project root&gt;/workspace/binary/arm64/Image</code><br>hip05-d02.dtb in <code>&lt;project root&gt;/workspace/binary/D02/hip05-d02.dtb</code><br><strong>source</strong>: <code>&lt;project root&gt;/kernel</code></p>
<p>build commands(supposedly, you are in <code>&lt;project root&gt;</code> currently):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./estuary/submodules/build-kernel.sh --platform=D02 --output=workspace</div></pre></td></tr></table></figure></p>
<p>if your host is not arm architecture, please execute<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./estuary/submodules/build-kernel.sh --platform=D02 --output=workspace --cross=aarch64-linux-gnu-</div></pre></td></tr></table></figure></p>
<p>Note: more details about how to install gcc-linaro-aarch64-linux-gnu-4.9-2014.09_linux, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md" target="_blank" rel="external">https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md</a>.  </p>
<p>More detail about distributions, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Distributions_Guide.4All.md" target="_blank" rel="external">Distributions_Guide.md</a>.<br>More detail about toolchains, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md" target="_blank" rel="external">Toolchains_Guide.md</a>.<br>More detail about how to deploy target system into D02 board, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Deploy_Manual.4D02.md" target="_blank" rel="external">Deployment_Manual.md</a>.<br>More detail about how to debug, analyse, diagnose system, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Armor_Manual.4All.md" target="_blank" rel="external">Armor_Manual.md</a>.<br>More detail about how to benchmark system, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Caliper_Manual.4All.md" target="_blank" rel="external">Caliper_Manual.md</a>.<br>More detail about how to access remote boards in OpenLab, please refer to <a href="http://open-estuary.org/accessing-boards-in-open-lab/" target="_blank" rel="external">Boards_in_OpenLab</a>.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Deploy_Manual.4D03]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/D03/Deploy_Manual.4D03/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">Preparation</a><ul>
<li><a href="#2.1">Prerequisite</a></li>
<li><a href="#2.2">Check the hardware board</a></li>
<li><a href="#2.3">Upgrade UEFI and trust firmware</a></li>
<li><a href="#2.4">Upgrade DTB file</a></li>
</ul>
</li>
<li><a href="#3">Bring up System</a><ul>
<li><a href="#3.1">Boot via ESL</a></li>
<li><a href="#3.2">Boot via PXE</a></li>
<li><a href="#3.3">Boot via NFS</a></li>
<li><a href="#3.4">Boot via DISK(SAS/USB/SATA)</a></li>
<li><a href="#3.5">Boot via ACPI</a><a id="more"></a>
</li>
</ul>
</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><a name="1">Introduction</a></h2><p>This documentation describes how to get, build, deploy and bring up target system based Estuary Project, it will help you to make your Estuary Environment setup from ZERO.<br>All following sections will take the D03 board as example, other boards have the similar steps to do, for more detail difference between them, please refer to Hardware Boards sections in <a href="http://open-estuary.com/hardware-boards/" target="_blank" rel="external">http://open-estuary.com/hardware-boards/</a>.</p>
<h2 id="Preparation"><a href="#Preparation" class="headerlink" title="Preparation"></a><a name="2">Preparation</a></h2><h3 id="Prerequisite"><a href="#Prerequisite" class="headerlink" title="Prerequisite"></a><a name="2.1">Prerequisite</a></h3><p><em>Local network</em>: To connect hardware boards and host machine, so that they can communicate each other.<br><em>Serial cable</em>: To connect hardware board’s serial port to host machine, so that you can access the target board’s UART in host machine.</p>
<p>Two methods are provided to <strong>connect the board’s UART port to a host machine</strong>:<br><strong>Method 1</strong>: connect the board’s UART in openlab environment<br>Use <code>board_connect</code> command.(Details please refer to <code>board_connect --help</code>)<br><strong>Method 2</strong>: directly connect the board by UART cable<br>a. Connect the board’s UART port to a host machine with a serial cable.<br>b. Install a serial port application in host machine, e.g.: kermit or minicom.<br>c. Config serial port setting:115200/8/N/1 on host machine.<br>For more details, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/UEFI_Manual.4D03.md" target="_blank" rel="external">UEFI_Manual.md</a> “Upgrade UEFI” chapter.</p>
<h3 id="Check-the-hardware-board"><a href="#Check-the-hardware-board" class="headerlink" title="Check the hardware board"></a><a name="2.2">Check the hardware board</a></h3><p>Hardware board should be ready and checked carefully to make sure it is available, more detail information about different hardware board, please refer to <a href="http://open-estuary.org/d03/" target="_blank" rel="external">http://open-estuary.org/d03/</a>.</p>
<h3 id="Upgrade-UEFI-and-trust-firmware"><a href="#Upgrade-UEFI-and-trust-firmware" class="headerlink" title="Upgrade UEFI and trust firmware"></a><a name="2.3">Upgrade UEFI and trust firmware</a></h3><p>You can upgrade UEFI and trust firmare yourself based on FTP service, but this is not necessary. If you really want to do it, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/UEFI_Manual.4D03.md" target="_blank" rel="external">UEFI_Manual.md</a>.</p>
<h3 id="Upgrade-DTB-file-Necessary-step"><a href="#Upgrade-DTB-file-Necessary-step" class="headerlink" title="Upgrade DTB file(Necessary step) "></a><a name="2.4">Upgrade DTB file(Necessary step) </a></h3><p>Because this dtb file is important to this D03 boards, firstly you must flash this DTB file into spiflash before any methods of bringing up systerm.</p>
<p> “EFI internal shell” mode and “Embedded Boot Loader(EBL)” mode often used to upgrade DTB file , about how to enter two modes and how to switch between them, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/UEFI_Manual.4D03.md" target="_blank" rel="external">UEFI_Manual.md</a> “Upgarde UEFI” chapter.</p>
<ol>
<li><p>IP address config at “EFI Internal Shell” mode (Optional, you can ignore this step if DHCP works well)<br>Press any key except “enter” key to enter into UEFI main menu. Select “Boot Manager”-&gt;”EFI Internal Shell”.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Config board's IP address</span></div><div class="line">ifconfig <span class="_">-s</span> eth0 static &lt;IP address&gt; &lt;mask&gt; &lt;gateway&gt;</div></pre></td></tr></table></figure>
<p>e.g. <code>ifconfig -s eth0 static 192.168.1.4 255.255.255.0 192.168.1.1</code></p>
</li>
<li><p>Download dtb file from FTP at “Embedded Boot Loader(EBL)” mode<br>Enter “exit” from “EFI internal shell” to the UEFI main menu and choose “Boot Manager”-&gt; “Embedded Boot Loader(EBL)”after setting the IP address done.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Download file from FTP server to target board's RAM</span></div><div class="line">provision &lt;server IP&gt; -u &lt;ftp user name&gt; -p &lt;ftp password&gt; <span class="_">-f</span> &lt;dtb file&gt; <span class="_">-a</span> &lt;download target address&gt;</div><div class="line"><span class="comment"># Write data into FLASH</span></div><div class="line">sfcerase &lt;<span class="built_in">source</span> address&gt; &lt;target address&gt; &lt;data length&gt;</div><div class="line">sfcwrite &lt;<span class="built_in">source</span> address&gt; &lt;target address&gt; &lt;data length&gt;</div></pre></td></tr></table></figure>
<p>e.g.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">provision 192.168.1.107 -u sch -p aaa <span class="_">-f</span> hip06<span class="_">-d</span>03.dtb <span class="_">-a</span> 0x100000</div><div class="line">sfcerase 0x7C0000 0x10000</div><div class="line">sfcwrite 0x100000 0x7C0000 0x10000</div></pre></td></tr></table></figure>
</li>
<li><p>Reboot your D03 board<br>You must reboot your D03 board after above two steps, this new DTB file will be used on booting board.<br>Note: It is necessary to flash the DTB file to SPI flash to solve a known MAC address duplicate Issue. Also it is to be noted that the DTB file should not be input in the Grub config file. So if you wish to use a modified DTB file, then you should always have it flashed to SPI flash before bootup.</p>
</li>
</ol>
<h2 id="Bring-up-System"><a href="#Bring-up-System" class="headerlink" title="Bring up System"></a><a name="3">Bring up System</a></h2><p>There are several methods to bring up system, you can select following anyone fitting you to boot up.</p>
<h3 id="Boot-via-ESL"><a href="#Boot-via-ESL" class="headerlink" title="Boot via ESL"></a><a name="3.1">Boot via ESL</a></h3><p>In this boot mode, the kernel image, dtb file and rootfs file should be downloaded into RAM at first and then start the system by ESL.<br>After reboot or power off, all downloaded data will be lost.<br>This boot mode is just used for debugging.</p>
<p>Boot D03 to UEFI menu. Select “Boot Manager”-&gt;”Eebedded Boot Loader(EBL)” and type the<br>follow commands in EBL:</p>
<ol>
<li><p>Download Image binary file from FTP server to target board’s RAM</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Download Image binary file from FTP server to target board's RAM</span></div><div class="line">provision &lt;server IP&gt; -u &lt;ftp user name&gt; -p &lt;ftp password&gt; <span class="_">-f</span> &lt;Image binary file&gt; <span class="_">-a</span> &lt;download target address&gt;</div></pre></td></tr></table></figure>
<p> e.g. <code>provision 192.168.1.107 -u sch -p aaa -f Image -a 0x80000</code></p>
</li>
<li><p>Download dtb file from FTP server to target board’s RAM</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Download dtb file from FTP server to target board's RAM</span></div><div class="line">provision &lt;server IP&gt; -u &lt;ftp user name&gt; -p &lt;ftp password&gt; <span class="_">-f</span> &lt;dtb file&gt; <span class="_">-a</span> &lt;download target address&gt;</div></pre></td></tr></table></figure>
<p>e.g. <code>provision 192.168.1.107 -u sch -p aaa -f hip06-d03.dtb -a 0x06000000</code></p>
</li>
<li><p>Download rootfs file from FTP server</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Download rootfs file from FTP server to target board's RAM</span></div><div class="line">provision &lt;server IP&gt; -u &lt;ftp user name&gt; -p &lt;ftp password&gt; <span class="_">-f</span> &lt;rootfs file&gt; <span class="_">-a</span> &lt;download target address&gt;</div></pre></td></tr></table></figure>
<p>e.g.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">provision 192.168.1.107 -u sch -p aaa <span class="_">-f</span> mini-rootfs-arm64.cpio.gz <span class="_">-a</span> 0x07000000</div></pre></td></tr></table></figure>
</li>
<li><p>Start operating system<br>Type “exit” to exit EBL. Select “Boot Manager”-&gt;”ESL Start OS” menu to start operating system.</p>
</li>
</ol>
<h3 id="Boot-via-PXE"><a href="#Boot-via-PXE" class="headerlink" title="Boot via PXE"></a><a name="3.2">Boot via PXE</a></h3><p>In this boot mode, the UEFI will get grub from PXE server.The grub will get the configuration file from TFTP service configured by PXE server.</p>
<ol>
<li>Setup PXE environment on host<br>Enable both DHCP and TFTP services on one of your host machines according to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Setup_PXE_Env_on_Host.4All.md" target="_blank" rel="external">Setup_PXE_Env_on_Host.md</a>.</li>
<li>Reboot and press anykey except “enter” to enter UEFI Boot Menu</li>
<li>Select boot option “Boot Manager”-&gt;”EFI Network <code>&lt;No&gt;</code>“ boot option and press “Enter”.<br><strong>Note</strong>:<br>If you are connecting the D03 board of openlab, please select “EFI Network 2”.<br>The value of <code>&lt;No&gt;</code> is depended on which D03 GE port is connected. D03 board support 4 on-board network ports at maximun.To enable any one of them by connecting to network cable or optical fiber. From left to right, followed by two GE ports, two 10GE ports which corresponding to UEFI startup interface are EFI Network 2, EFI Network 3, EFI Network 0, EFI Network 1.</li>
<li>After several seconds, D03 will boot by PXE automatically.</li>
</ol>
<p>To config the <code>grub.cfg</code> to support PXE boot, please refer to  <a href="https://github.com/open-estuary/estuary/blob/master/doc/Grub_Manual.4All.md" target="_blank" rel="external">Grub_Manual.md</a>.</p>
<h3 id="3.3">Boot via NFS</h3>

<p>In this boot mode, the root parameter in grub.cfg menuentry will set to /dev/nfs and nfsroot will be set to the path of rootfs on NFS server. You can use <code>showmount -e &lt;server ip address&gt;</code> to list the exported NFS directories on the NFS server.</p>
<p>D03 supports booting via NFS, you can try it as following steps:</p>
<ol>
<li>Enable DHCP, TFTP and NFS service according to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Setup_PXE_Env_on_Host.4All.md" target="_blank" rel="external">Setup_PXE_Env_on_Host.md</a>.</li>
<li>Get and config grub file to support NFS boot according to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Grub_Manual.4All.md" target="_blank" rel="external">Grub_Manual.md</a>.</li>
<li>Reboot D03 and press anykey except “enter” to enter UEFI Boot Menu</li>
<li>Select boot option “Boot Manager”-&gt;”EFI Network <code>&lt;No&gt;</code>“ boot option to enter.<br><strong>Note</strong>: If you are connecting the D03 board of openlab, please select “EFI Network 2”. The value of <code>&lt;No&gt;</code> is depended on which D03 GE port is connected.</li>
</ol>
<h3 id="Boot-via-DISK-SAS-USB-SATA"><a href="#Boot-via-DISK-SAS-USB-SATA" class="headerlink" title="Boot via DISK(SAS/USB/SATA)"></a><a name="3.4">Boot via DISK(SAS/USB/SATA)</a></h3><p>D03 board supports booting via SAS, USB and SATA by default. The UEFI will directly get the grub from the EFI system partition on the hard disk. The grub will load the grub configuration file from the EFI system partition. So <code>grubaa64.efi</code>, <code>grub.cfg</code>, <code>Image</code> and different estuary release distributions are stored on disk.</p>
<ol>
<li><p>Boot by PXE (please refer to “Boot via PXE”) to part and format hardware disk before booting D03 board<br>Format hardware disk, e.g.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo mkfs.vfat /dev/sda1</div><div class="line">sudo mkfs.ext4 /dev/sda2</div></pre></td></tr></table></figure>
<p>Part hardware disk with <code>sudo fdisk /dev/sda</code> as follow:<br>add a gpt to this disk:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">fdisk /dev/sda</div></pre></td></tr></table></figure>
<p><code>g</code>——-add a gpt partition</p>
<p>add some EFI partition:<br><code>n</code>——-add a partition<br><code>1</code>——-the number of partition</p>
<p>type “Enter” key —— First sector<br><code>+200M</code>———Last sector, size of partition<br><code>t</code>——-change the type of partition to EFI system</p>
<p>add some another partition <code>...</code><br>save the change: <code>w</code><br>format EFI partition: <code>sudo mkfs.vfat /dev/sda1</code><br>format ext4 partition: <code>sudo mkfs.ext4 /dev/sda2</code>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">+---------+-----------+--------------+------------------+</div><div class="line">| Name    |   Size    |    Type      |   USB/SAS/SATA   |</div><div class="line">+---------+-----------+--------------+------------------+</div><div class="line">| sda1    |   200M    |  EFI system  |   EFI            |</div><div class="line">+---------+-----------+--------------+------------------+</div><div class="line">| sda2    |   10G     |    ext4      | linux filesystem |</div><div class="line">+---------+-----------+--------------+------------------+</div><div class="line">| sda3    |   10G     |    ext4      | linux filesystem |</div><div class="line">+---------+-----------+--------------+------------------+</div><div class="line">| sda4    |   10G     |    ext4      | linux filesystem |</div><div class="line">+---------+-----------+--------------+------------------+</div><div class="line">| sda5    |rest space |    ext4      | linux swap       |</div><div class="line">+---------+-----------+--------------+------------------+</div></pre></td></tr></table></figure>
<p>Note: EFI partition must be a fat filesystem, so you should format sda1 with <code>sudo mkfs.vfat /dev/sda1</code>.</p>
</li>
<li><p>Download files and store them into hardware disk as below.<br>(SAS/USB/SATA) Related files are placed as follow:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sda1: -------EFI</div><div class="line">       |       |</div><div class="line">       |       GRUB2------grubaa64.efi  // grub binary file</div><div class="line">       |</div><div class="line">       |-------------grub.cfg           // grub config file</div><div class="line">       |</div><div class="line">       |-------------Image              // kernel binary Image</div><div class="line">sda2: Ubuntu distribution</div><div class="line">sda3: Fedora distribution</div></pre></td></tr></table></figure>
<p>NOTE: The <code>grubaa64.efi</code> file must be put in <code>/EFI/GRUB2</code> directory of <code>/dev/sda1</code>(gpt partition), the distributions could be uncompressed in <code>/dev/sdaX</code>(X can be 2,3,4,etc. exclude 1).</p>
<p> To get kernel image and dtb file, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Readme.4D03.md" target="_blank" rel="external">Readme.md</a>.<br> To get and config grub and grub.cfg, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Grub_Manual.4All.md" target="_blank" rel="external">Grub_Manual.md</a>.<br> To get different distributions, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Distributions_Guide.4All.md" target="_blank" rel="external">Distributions_Guider</a>.</p>
</li>
<li><p>Boot the board via SAS/USB/SATA<br>a. Modify grub config file(please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Grub_Manual.4All.md" target="_blank" rel="external">Grub_Manual.4All.md</a>)<br>   e.g. grub.cfg file for official versions after V2.2 is modified as follow:</p>
   <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Sample GRUB configuration file</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Boot automatically after 5 secs.</span></div><div class="line"><span class="built_in">set</span> timeout=5</div><div class="line"><span class="comment"># By default, boot the Estuary with Ubuntu filesystem</span></div><div class="line"><span class="built_in">set</span> default=ubuntu</div><div class="line"><span class="comment"># For booting GNU/Linux</span></div><div class="line"></div><div class="line">menuentry <span class="string">"ubuntu"</span> --id ubuntu &#123;</div><div class="line">  search --no-floppy --fs-uuid --set=root &lt;UUID&gt;</div><div class="line">  linux /Image rdinit=/init pcie_aspm=off root=PARTUUID=&lt;PARTUUID&gt; rootwait rootfstype=ext4 rw console=ttyS0,115200 earlycon=hisilpcuart,mmio,0xa01b0000,0,0x2f8 ip=dhcp</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   grub.cfg file for official V2.2 and previous versions is modified as follow:</p>
   <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Sample GRUB configuration file</span></div><div class="line"><span class="comment">#</span></div><div class="line"><span class="comment"># Boot automatically after 5 secs.</span></div><div class="line"><span class="built_in">set</span> timeout=5</div><div class="line"><span class="comment"># By default, boot the Estuary with Ubuntu filesystem</span></div><div class="line"><span class="built_in">set</span> default=ubuntu</div><div class="line"><span class="comment"># For booting GNU/Linux</span></div><div class="line"></div><div class="line">menuentry <span class="string">"ubuntu"</span> --id ubuntu &#123;</div><div class="line">  search --no-floppy --fs-uuid --set=root &lt;UUID&gt;</div><div class="line">  linux /Image rdinit=/init pcie_aspm=off root=PARTUUID=&lt;PARTUUID&gt; rootwait rootfstype=ext4 rw console=ttyS1,115200 earlycon=hisilpcuart,mmio,0xa01b0000,0,0x2f8 ip=dhcp</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   <strong>Note</strong>:  </p>
<ul>
<li>The value of console is <code>ttyS0</code> for official versions after V2.2. If you use official V2.2 and previous versions, the value of console is <code>ttyS1</code></li>
<li><code>&lt;UUID&gt;</code> means the UUID of that partition which your EFI System is located in.<br><code>&lt;PARTUUID&gt;</code> means the PARTUUID of that partition which your linux distribution is located in.<br>To see the values of UUID and PARTUUID, please use the command:<code>blkid</code>.</li>
<li>If you want to use another linux distribution, please refer above steps.<br>b. Reboot and press anykey except “enter” to enter UEFI main menu.<br>c. For USB: Select “Boot Manager”-&gt; “EFI USB Device”-&gt; to enter grub selection menu.</li>
<li>For SAS: Select “Boot Manager”-&gt; “EFI Misc Device 1” to enter grub selection menu.</li>
<li>For SATA: Select “Boot Manager”-&gt; “EFI Hard Drive” to enter grub selection menu.<br>d. Press arrow key up or down to select grub boot option to decide which distribution should boot.</li>
</ul>
</li>
</ol>
<h3 id="Boot-via-ACPI"><a href="#Boot-via-ACPI" class="headerlink" title="Boot via ACPI"></a><a name="3.5">Boot via ACPI</a></h3><p>D03 also supports booting via ACPI, you can bring up this system which is similar with DTS mode, you must fix some point as follow:</p>
<ol>
<li><p>Delete DTB file(comment out devicetree <code>/&lt;user&gt;/hip06-d03.dtb</code> as follow) and don’t burn DTB file</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">menuentry <span class="string">"D03 Ubuntu NFS"</span> --id d03_ubuntu_nfs &#123;</div><div class="line">  <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">  linux /Image rdinit=/init pcie_aspm=off console=ttyS0,115200 earlycon=hisilpcuart,mmio,0xa01b0000,0,0x2f8 root=/dev/nfs rw nfsroot=192.168.1.107:/home/ftp/user/rootfs_ubuntu64 ip=dhcp</div><div class="line">  <span class="comment">#devicetree /&lt;user&gt;/hip06-d03.dtb</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>Set the parameters of booting via ACPI<br>you must add <code>acpi=force</code> property in <code>linux</code> line for “grub.cfg” file. If not, system will booted up with DTS by default. e.g.:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># Booting from NFS with Ubuntu rootfs</span></div><div class="line">menuentry <span class="string">"D03 Ubuntu NFS(ACPI)"</span> --id d03_ubuntu_nfs_acpi &#123;</div><div class="line">    <span class="built_in">set</span> root=(tftp,192.168.1.107)</div><div class="line">    linux /Image rdinit=/init pcie_aspm=off console=ttyS0,115200 earlycon=hisilpcuart,mmio,0xa01b0000,0,0x2f8 root=/dev/nfs rw nfsroot=192.168.1.107:/home/ftp/user/rootfs_ubuntu64 ip=dhcp acpi=force</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>NOTE: you can get more information about setting grub.cfg from <a href="https://github.com/open-estuary/estuary/blob/master/doc/Grub_Manual.4All.md" target="_blank" rel="external">Grub_Manual.md</a>.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Armor_Tools_Basic_Info.4All.md]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/All/Armor_Tools_Basic_Info.4All/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">List of Tools</a><a id="more"></a>
</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><a name="1">Introduction</a></h2><p>This document presents the basic information of the supported Armor tools. </p>
<h2 id="List-of-Tools"><a href="#List-of-Tools" class="headerlink" title="List of Tools"></a><a name="2">List of Tools</a></h2><ol>
<li><p>Perf integrated with LLC, MN and DDR</p>
<ul>
<li>Integrated LLC statistics registers access via perf, including DDR counter information. </li>
<li>Support counter overflow interrupt support for LLC counters. </li>
<li>Register Read/Get interface from Linux Kernel for LLC and Bus Registers for P660.</li>
<li>LLC statistics registers integration to perf for P660.</li>
</ul>
</li>
<li><p>strace : trace system calls and signals</p>
<p>strace is a diagnostic, debugging and instructional Linux user space utility. It is used to monitor interactions between processes and the Linux kernel, which include system calls, signal deliveries, and changes of process state. </p>
</li>
</ol>
<ol>
<li><p>ltrace : library call tracer.</p>
<p>ltrace intercepts and records the dynamic library calls which are called by the executed process and the signals which are received by that process. It can also intercept and print the system calls executed by the program.</p>
</li>
<li><p>netstat : </p>
<p>netstat prints network connections, routing tables, interface statistics, masquerade connections, and multicast memberships.</p>
</li>
<li><p>sar : Collect, report, or save system activity information.</p>
</li>
<li><p>top : display Linux tasks. </p>
<p>top shows how much CPU processing power and memory are being used, as well as other information about the running processes.</p>
</li>
<li><p>pidstat: Report statistics for Linux tasks.</p>
<p>pidstat command is used for monitoring individual tasks currently being managed by the Linux kernel. pidstat writes to standard output activities for every task selected with option -p or for every task managed by the Linux kernel if option -p ALL has been used.  </p>
</li>
<li><p>vmstat : Report virtual memory statistics.</p>
<p>vmstat reports information about processes, memory, paging, block IO, traps, and CPU activity.</p>
</li>
<li><p>ftrace: is the Linux kernel internal tracer that was included in the Linux kernel in 2.6.27.</p>
<p>ftrace supports function tracing, latency tracing, event tracing etc.</p>
</li>
<li><p>iostat :  Report CPU statistics and input/output statistics for devices, partitions and network filesystems (NFS). </p>
</li>
<li><p>tcpdump:dump traffic on a network.</p>
<p>Tcpdump prints out the headers of packets on a network interface. It can also be run with the -w flag, which causes it to save the packet data to a file for later analysis, and with the -r flag, which causes it to read from a saved packet file rather than to read packets from a network interface. </p>
</li>
<li><p>ethtool :  query or control network driver and hardware settings, particularly for wired Ethernet devices. </p>
</li>
<li><p>swapon, swapoff : enable/disable devices and files for paging and swapping, </p>
<p>used to specify devices on which paging and swapping are to take place. </p>
</li>
<li><p>kdump/kexec :</p>
<p>Kdump is a kexec based crash dumping mechanism for Linux.<br>Kexec is a mechanism of the Linux kernel that allows “live” booting of a new kernel “over” the currently running kernel.<br>Note: kdump/kexec is not verified for D02. The user space kexec-tools and kdump-tools components may need to build for arm64.  </p>
</li>
<li><p>gdb: gnu debugger</p>
<p>Gdb supports many features including the following:  </p>
<ul>
<li>put break points, watch points</li>
<li>single stepping</li>
<li>disassemble</li>
<li>printing value of variables, registers.</li>
<li>call traces</li>
</ul>
</li>
<li><p>iptables : administration tool for IPv4 packet filtering and NAT.</p>
<p>Iptables is used to set up, maintain, and inspect the tables of IP packet filter rules in the Linux kernel.</p>
</li>
<li><p>mkfs : build a Linux file system on a device, usually a hard disk partition.</p>
</li>
<li><p>mount : mount a file system. </p>
</li>
<li><p>du : estimates the file space usage.</p>
<p>The du summarize he disk usage of each file, recursively for directories.     </p>
</li>
<li><p>df : report file system disk space usage.</p>
<p>The df displays the amount of disk space available on the file system containing each filename argument. If no file system name is given, the spac available on all currently mounted file systems are shown.</p>
</li>
<li><p>dmidecode : DMI table decoder</p>
<p>dmidecode tool dump DMI(SMBIOS) table contents in a human readable format. This table contains description of the system’s hardware components, other information such as serial numbers and BIOs version.   </p>
</li>
<li><p>fsck : is used to check and optionally repair a Linux file system.</p>
</li>
<li><p>lscpu : display information about the CPU architecture. </p>
</li>
<li><p>lspci : List all PCI devices. </p>
<p>This utility display information about the PCI buses in the system and devices connected to them. </p>
</li>
<li><p>setpci : utility for querying and configuring PCI devices.  </p>
</li>
<li><p>tail : this utility outputs the last part of the files. </p>
</li>
<li><p>grep : tool searches the named input files for lines contains a match to the given pattern.   </p>
</li>
<li><p>awk : pattern scanning and processing language.</p>
</li>
<li><p>sed : is a stream editor, used to perform basic text transformations.</p>
</li>
<li><p>dstat: versatile tool for generating system resource statistics. Replacement for vmstat, iostat and ifstat.</p>
<p>dstat allows you to view all of your system resources instantly, for example you can compare disk usage in combination with interrupts from your IDE controller, or compare the network bandwidth numbers directly with the disk throughput (in the same interval). </p>
</li>
<li><p>procps: procps is the package that has a bunch of small useful utilities that give information about processes using the /proc filesystem.</p>
<p>The procps package includes the programs ps, top, vmstat, w, kill, free, slabtop, and skill.</p>
</li>
<li><p>tiptop: display hardware performance counters for Linux tasks.</p>
<p>Some of the features of tiptop are  </p>
<ul>
<li>No root privilege needed</li>
<li>No patch to OS</li>
<li>Any event supported by the hardware such as </li>
<li>some predefined: instructions, cycles, LLC misses (easy)</li>
<li>any hardware supported event (slightly harder)</li>
<li>two running modes - Live mode and batch mode.</li>
</ul>
</li>
<li><p>iotop: simple top-like I/O monitor.</p>
<p>iotop watches I/O usage information output by the Linux kernel and displays a table of current I/O usage by processes or threads on the system.</p>
</li>
<li><p>blktrace:  generate traces of the i/o traffic on block devices.</p>
<p>The blktrace utility extracts event traces from the kernel.  </p>
<ul>
<li>blktrace receives data from the kernel in buffers passed up through the debug file system (relay).<br> Each device being traced has a file created in the mounted directory for the debugfs, which defaults to /sys/kernel/debug </li>
<li>blktrace defaults to collecting all events that can be traced. To limit the events being captured,<br> you can specify one or more filter masks via the -a option.</li>
</ul>
</li>
<li><p>nicstat: Show Network Interface Card Statistics.</p>
<p>nicstat prints out network statistics for all network interface cards (NICs), including packets, kilobytes per second, average packet sizes and more. </p>
</li>
<li><p>lldptool: manage the LLDP settings and status of lldpad (Link Layer Discovery Protocol).</p>
</li>
<li><p>oprofile: a system-wide profiler, capable of profiling all running code at low overhead.</p>
<p>Supported features are</p>
<ul>
<li>Unobtrusive, no special recompilations, wrapper libraries or the like are necessary.  </li>
<li>System-wide profiling</li>
<li>Single process profiling</li>
<li>Event counting</li>
<li>Performance counter support</li>
<li>Call-graph support</li>
<li>Low overhead</li>
<li>Post-profile analysis</li>
<li>System support </li>
</ul>
</li>
<li><p>latencytop: a tool for developers to visualize system latencies.</p>
</li>
<li><p>kgdb: Kernel gnu debugger.</p>
<p>kgdb is one of the debugger front ends of the kernel which interface to the debug core.<br>Kgdb is intended to be used as a source level debugger for the Linux kernel. It is used along with gdb to debug a Linux kernel.<br>The expectation is that gdb can be used to “break in” to the kernel to inspect memory, variables and look through call stack information<br>similar to the way an application developer would use gdb to debug an application. It is possible to place breakpoints in kernel code and<br>perform some limited execution stepping.</p>
</li>
<li><p>kdb: kernel debugger.</p>
<p>kdb is one of the debugger front ends of the kernel which interface to the debug core.<br>Kdb is shell-style interface which you can use on a system console with a keyboard or serial console.<br>kdb can be used to inspect memory, registers, process lists, dmesg, and even set breakpoints to stop in a certain location.<br>Kdb is not a source level debugger, although you can set breakpoints and execute some basic kernel run control.<br>Kdb is mainly aimed at doing some analysis to aid in development or diagnosing kernel problems.</p>
</li>
<li><p>systemtap: SystemTap provides free software (GPL) infrastructure to simplify the gathering of information about the running Linux system. </p>
<p>SystemTap (stap) is a scripting language and tool for dynamically instrumenting running production Linux kernel-based operating systems.<br>System administrators can use SystemTap to extract, filter and summarize data in order to enable diagnosis of complex performance or functional problems.</p>
</li>
<li><p>kprobes: Kprobes enables you to dynamically break into any kernel routine and collect debugging and performance information non-disruptively.</p>
<p>Kernel Dynamic Probes (Kprobes) provides a lightweight interface for kernel modules to implant probes and register corresponding probe handlers.<br>A probe is an automated breakpoint that is implanted dynamically in executing (kernel-space) modules without the need to modify their underlying source.</p>
</li>
<li><p>crash : Analyze Linux crash dump data or a live system.</p>
<p>Crash is a tool for interactively analyzing the state of the Linux system while it is running, or after a kernel crash has occurred<br>and a core dump has been created by the netdump, diskdump, LKCD, kdump, xendump or kvmdump facilities.</p>
</li>
<li><p>memwatch: A memory leak detection tool. memwatch source files to be integrated and build as part of the code to be tested.</p>
</li>
<li><p>LTTNG: Linux Trace Toolkit Next Generation. LTTng consists of kernel modules (for Linux kernel tracing) and dynamically loaded libraries (for user application and library tracing). </p>
<p>It is controlled by a session daemon, which receives commands from a command line interface.</p>
</li>
<li><p>powertop: program help to analyse the power consumption.</p>
</li>
<li><p>slabtop: display kernel slab cache information.</p>
</li>
<li><p>ktap: script based dynamic tracing tool for Linux.</p>
</li>
<li><p>gprof: performance analysis tool.</p>
</li>
<li><p>valgrind: instrumentation framework for buiding dynamic analysis tools, which can detect memory management and threading bugs,does profiling etc.</p>
</li>
<li><p>pktgen - Linux packet generator is a tool to generate packets at very high speed in the kernel.Monitoring and controlling is done via /proc.</p>
<p>Sample scripts are available online.</p>
</li>
<li><p>packETHcli - packETHcli is the command line packet generator tool for ethernet.<br>It allows you to create and send any possible packet or sequence of packets on the ethernet link.</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Quick_Deployment.4D02.md]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/D02/Quick_Deployment.4D02/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">Quick Deploy System</a><ul>
<li><a href="#2.1">Deploy system via USB Disk</a></li>
<li><a href="#2.2">Deploy system via DVD</a></li>
<li><a href="#2.3">Deploy system via PXE</a></li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><a name="1">Introduction</a></h2><p>Above all, prepare hardware boards with SCSI disk and download Estuary source code from GitHub.<br>To learn more about how to do them, please visit this web site: <a href="http://open-estuary.com/estuary-user-manual/" target="_blank" rel="external">http://open-estuary.com/estuary-user-manual/</a> , and then refer to ‘Get &amp; Build Estuary yourself’.<br><strong>Note</strong>: In my case, the working directory is <code>~/workdir</code>.</p>
<h2 id="Quick-Deploy-System"><a href="#Quick-Deploy-System" class="headerlink" title="Quick Deploy System"></a><a name="2">Quick Deploy System</a></h2><h3 id="Deploy-system-via-USB-Disk"><a href="#Deploy-system-via-USB-Disk" class="headerlink" title="Deploy system via USB Disk"></a><a name="2.1">Deploy system via USB Disk</a></h3><ol>
<li>Prepare usb install disk.<ul>
<li>Modify estuary/estuarycfg.json. Make sure the platform, distros are all right.  </li>
<li>Change the value of “install” to “yes” in object “setup” for usb and the value “device” to your USB install disk.<br>(Notice: if the specified usb device does not exist, the first usb device will be selected by default.)  </li>
<li>Use build.sh to create the usb install disk.<br><code>eg: ./estuary/build.sh -f estuary/estuarycfg.json</code>  </li>
</ul>
</li>
<li>Connect the usb install disk to the board.  </li>
<li>Reboot the board.  </li>
<li>Boot from the usb device. (About how to boot from USB device, please refer to the UEFI related manual.)  </li>
<li>According to the prompt to deploy the system.  </li>
<li>Start the boards from “grub” menu of UEFI by default.  </li>
</ol>
<h3 id="Deploy-system-via-DVD"><a href="#Deploy-system-via-DVD" class="headerlink" title="Deploy system via DVD"></a><a name="2.2">Deploy system via DVD</a></h3><ol>
<li>Prepare ISO image and install disk.<ul>
<li>Modify estuary/estuarycfg.json. Make sure the platform, distros are all right.  </li>
<li>Change the value of “install” to “yes” in object “setup” for iso and the value “name” to your target iso image file name.  </li>
<li>Use build.sh to create the target install iso image file.<br>eg: <code>./estuary/build.sh -f estuary/estuarycfg.json</code>  </li>
<li>Burn the iso image file to DVD disk if you use the physical DVD driver.  </li>
</ul>
</li>
<li>Connect the physical DVD driver to the board, plug in the install DVD disk.  </li>
<li>Reboot the board.  </li>
<li>Boot from the DVD device. (About how to boot from DVD device, please refer to the UEFI related manual.)  </li>
<li>According to the prompt to deploy the system.  </li>
<li>Start the boards from “grub” menu of UEFI by default.</li>
</ol>
<h3 id="Deploy-system-via-PXE"><a href="#Deploy-system-via-PXE" class="headerlink" title="Deploy system via PXE"></a><a name="2.3">Deploy system via PXE</a></h3><ol>
<li>Connect Ubuntu PC and hardware boards into the same local area network. (Make sure the PC can connect to the internet and no other PXE servers exist.)  </li>
<li>Modify the configuration file of estuary/estuarycfg.json based on you hardware boards. Change the values of mac to physical addresses of the connected network cards on the board. Change the value of “install” to “yes” in object “setup” for PXE.  </li>
<li>Backup files under the tftp root directory if necessary. Use build.sh to build project and setup the PXE server on Ubuntu PC.<br>eg: <code>./estuary/build.sh -f estuary/estuarycfg.json</code>  </li>
<li>After that, install minicom and connect the serial ports of hardware boards to the Ubuntu PC. Connect the hardware boards by minicom using serial ports.  </li>
<li>Reboot the hardware boards and start the boards from the correct EFI Network.  </li>
<li>Install the system according to prompt. After install finished, the boards will restart automatically.  </li>
<li>Start the boards from “grub” menu of UEFI by default.</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Armor_Tools_Supported.4All.md]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/ALL/Armor_Tools_Supported.4All/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">List of supported Tools in Armor</a><ul>
<li><a href="#2.1">Ubuntu</a></li>
<li><a href="#2.2">Fedora</a></li>
<li><a href="#2.3">OpenSuse</a></li>
<li><a href="#2.4">Debian</a></li>
<li><a href="#2.5">CentOS</a></li>
<li><a href="#2.6">Miscelleneous Tools</a><a id="more"></a>
</li>
</ul>
</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><a name="1">Introduction</a></h2><p>This document presents the information of the supported Armor tools on D02 and Open-Estuary.</p>
<h2 id="List-of-supported-Tools-in-Armor"><a href="#List-of-supported-Tools-in-Armor" class="headerlink" title="List of supported Tools in Armor"></a><a name="2">List of supported Tools in Armor</a></h2><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a><a name="2.1">Ubuntu</a></h3><table>
<thead>
<tr>
<th>No</th>
<th>Tools</th>
<th>verison</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Perf integrated with LLC, MN and DDR</td>
<td>3.19.8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>strace - trace system calls and signals</td>
<td>4.8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>ltrace - library call tracer</td>
<td>0.7.3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>netstat</td>
<td>1.42</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>top - display Linux tasks</td>
<td>3.3.9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>pidstat - Report statistics for Linux tasks</td>
<td>11.0.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>vmstat - Report virtual memory statistics</td>
<td>3.3.9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>ftrace</td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>iostat -  Report CPU statistics and input/output statistics for devices, partitions and network filesystems (NFS)</td>
<td>11.0.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>tcpdump - dump traffic on a network.</td>
<td>4.6.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>ethtool - query or control network driver and hardware settings, particularly for wired Ethernet devices</td>
<td>3.16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>swapon, swapoff : enable/disable devices and files for paging and swapping</td>
<td>2.25.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>gdb: gnu debugger</td>
<td>7.9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>iptables - administration tool for IPv4 packet filtering and NAT</td>
<td>1.4.21</td>
<td></td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>dmidecode - DMI table decoder</td>
<td>2.12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>fsck - is used to check and optionally repair a Linux file system</td>
<td>2.25.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>lscpu - display information about the CPU architecture</td>
<td>2.25.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>18</td>
<td>lspci - List all PCI devices</td>
<td>3.2.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>19</td>
<td>setpci - utility for querying and configuring PCI devices</td>
<td>3.2.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>20</td>
<td>dstat - versatile tool for generating system resource statistics. Replacement for vmstat, iostat and ifstat</td>
<td>0.7.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>21</td>
<td>procps - procps is the package that has a bunch of small useful utilities that give information about processes using the /proc filesystem</td>
<td>3.3.9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>22</td>
<td>tiptop - display hardware performance counters for Linux tasks</td>
<td>2.3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>23</td>
<td>iotop - simple top-like I/O monitor</td>
<td>0.6</td>
<td></td>
<td></td>
</tr>
<tr>
<td>24</td>
<td>blktrace - generate traces of the i/o traffic on block devices</td>
<td>2.0.0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>25</td>
<td>nicstat - Show Network Interface Card Statistics</td>
<td>1.95</td>
<td></td>
<td></td>
</tr>
<tr>
<td>26</td>
<td>lldptool - manage the LLDP settings and status of lldpad (Link Layer Discovery Protocol)</td>
<td>0.9.46</td>
<td></td>
<td></td>
</tr>
<tr>
<td>27</td>
<td>oprofile - a system-wide profiler, capable of profiling all running code at low overhead</td>
<td>1.0.0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>28</td>
<td>latencytop - a tool for developers to visualize system latencies</td>
<td>0.5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>29</td>
<td>kgdb: Kernel gnu debugger</td>
<td></td>
<td></td>
</tr>
<tr>
<td>30</td>
<td>kdb: kernel debugger</td>
<td></td>
<td></td>
</tr>
<tr>
<td>31</td>
<td>systemtap - SystemTap provides free software (GPL) infrastructure to simplify the gathering of information about the running Linux system.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>32</td>
<td>kprobes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>33</td>
<td>crash - Analyze Linux crash dump data or a live system</td>
<td>7.1.3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>34</td>
<td>memwatch - memory leak detection tool</td>
<td>2.69</td>
<td></td>
<td></td>
</tr>
<tr>
<td>35</td>
<td>LTTNG - Linux Trace Toolkit Next Generation</td>
<td>2.5.0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>36</td>
<td>powertop - program help to analyse the power consumption</td>
<td>2.6.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>37</td>
<td>slabtop - display kernel slab cache information</td>
<td>3.3.9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>38</td>
<td>ktap - script based dynamic tracing tool for Linux</td>
<td>0.4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>39</td>
<td>gprof - performance analysis tool</td>
<td>2.25</td>
<td></td>
<td></td>
</tr>
<tr>
<td>40</td>
<td>valgrind - instrumentation framework for buiding dynamic analysis tools, which can detect memory management and threading bugs,does profiling etc</td>
<td>3.10.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>41</td>
<td>pktgen - Linux packet generator is a tool to generate packets at very high speed in the kernel.Monitoring and controlling is done via /proc. Sample scripts are available online.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>42</td>
<td>packETHcli - packETHcli is the command line packet generator tool for ethernet. It allows you to create and send any possible packet or sequence of packets on the ethernet link.</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="Fedora"><a href="#Fedora" class="headerlink" title="Fedora"></a><a name="2.2">Fedora</a></h3><table>
<thead>
<tr>
<th>No</th>
<th>Tools</th>
<th>verison</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Perf integrated with LLC</td>
<td>4.0.4-301.fc22.aarch64</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>strace - trace system calls and signals</td>
<td>4.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>ltrace - library call tracer</td>
<td>0.7.91</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>netstat</td>
<td>net-tools 2.10-alpha</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>top - display Linux tasks</td>
<td>3.3.10(proc-ps-ng)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>pidstat - Report statistics for Linux tasks</td>
<td>11.1.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>vmstat - Report virtual memory statistics</td>
<td>3.3.10(proc-ps-ng)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>ftrace</td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>iostat -  Report CPU statistics and input/output statistics for devices, partitions and network filesystems (NFS)</td>
<td>11.1.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>tcpdump - dump traffic on a network</td>
<td>4.7.4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>ethtool - query or control network driver and hardware settings, particularly for wired Ethernet devices</td>
<td>3.18</td>
<td></td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>swapon, swapoff : enable/disable devices and files for paging and swapping</td>
<td>util-linux 2.26.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>gdb: gnu debugger</td>
<td>7.9.1-17.fc22</td>
<td></td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>iptables - administration tool for IPv4 packet filtering and NAT</td>
<td>1.4.21</td>
<td></td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>dmidecode - DMI table decoder</td>
<td>2.12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>fsck - is used to check and optionally repair a Linux file system</td>
<td>util-linux 2.26.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>lscpu - display information about the CPU architecture</td>
<td>util-linux 2.26.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>18</td>
<td>lspci - List all PCI devices</td>
<td>3.3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>19</td>
<td>setpci - utility for querying and configuring PCI devices</td>
<td>3.3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>20</td>
<td>dstat - versatile tool for generating system resource statistics. Replacement for vmstat, iostat and ifstat</td>
<td>0.7.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>21</td>
<td>procps - procps is the package that has a bunch of small useful utilities that give information about processes using the /proc filesystem</td>
<td>3.3.10</td>
<td></td>
<td></td>
</tr>
<tr>
<td>22</td>
<td>tiptop - display hardware performance counters for Linux tasks</td>
<td>2.3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>23</td>
<td>iotop - simple top-like I/O monitor</td>
<td>0.6</td>
<td></td>
<td></td>
</tr>
<tr>
<td>24</td>
<td>blktrace - generate traces of the i/o traffic on block devices</td>
<td>2.0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>25</td>
<td>nicstat - Show Network Interface Card Statistics</td>
<td>1.95</td>
<td></td>
<td></td>
</tr>
<tr>
<td>26</td>
<td>lldptool - manage the LLDP settings and status of lldpad (Link Layer Discovery Protocol)</td>
<td>0.9.46</td>
<td></td>
<td></td>
</tr>
<tr>
<td>27</td>
<td>oprofile - a system-wide profiler, capable of profiling all running code at low overhead</td>
<td>1.0.0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>28</td>
<td>latencytop - a tool for developers to visualize system latencies</td>
<td>0.9.46</td>
<td></td>
<td></td>
</tr>
<tr>
<td>29</td>
<td>kgdb: Kernel gnu debugger.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>30</td>
<td>kdb: kernel debugger.</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>31</td>
<td>systemtap - SystemTap provides free software (GPL) infrastructure to simplify the gathering of information about the running Linux system.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>32</td>
<td>kprobes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>33</td>
<td>crash - Analyze Linux crash dump data or a live system</td>
<td>7.1.0-1.fc22</td>
<td></td>
<td></td>
</tr>
<tr>
<td>34</td>
<td>memwatch - memory leak detection tool</td>
<td>2.69</td>
<td></td>
<td></td>
</tr>
<tr>
<td>35</td>
<td>LTTNG - Linux Trace Toolkit Next Generation</td>
<td>2.6.0 - Gaia</td>
<td></td>
<td></td>
</tr>
<tr>
<td>36</td>
<td>powertop - program help to analyse the power consumption</td>
<td>2.8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>37</td>
<td>slabtop - display kernel slab cache information</td>
<td>procps-ng  3.3.10</td>
<td></td>
<td></td>
</tr>
<tr>
<td>38</td>
<td>ktap - script based dynamic tracing tool for Linux</td>
<td>0.4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>39</td>
<td>gprof - performance analysis tool</td>
<td>version - 2.25-8.fc22</td>
<td></td>
<td></td>
</tr>
<tr>
<td>40</td>
<td>valgrind - instrumentation framework for buiding dynamic analysis tools, which can detect memory management and threading bugs,does profiling etc</td>
<td>3.10.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>41</td>
<td>pktgen - Linux packet generator is a tool to generate packets at very high speed in the kernel.Monitoring and controlling is done via /proc. Sample scripts are available online.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>42</td>
<td>packETHcli - packETHcli is the command line packet generator tool for ethernet. It allows you to create and send any possible packet or sequence of packets on the ethernet link.</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="OpenSuse"><a href="#OpenSuse" class="headerlink" title="OpenSuse"></a><a name="2.3">OpenSuse</a></h3><table>
<thead>
<tr>
<th>No</th>
<th>Tools</th>
<th>verison</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Perf integrated with LLC</td>
<td>4.2.3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>strace - trace system calls and signals</td>
<td>4.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>ltrace - library call tracer</td>
<td>0.7.91</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>netstat</td>
<td>1.42</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>top - display Linux tasks</td>
<td>3.3.11</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>pidstat - Report statistics for Linux tasks</td>
<td>11.0.8(sysstat)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>vmstat - Report virtual memory statistics</td>
<td>3.3.11</td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>ftrace</td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>iostat -  Report CPU statistics and input/output statistics for devices, partitions and network filesystems (NFS)</td>
<td>11.0.8(systat)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>tcpdump - dump traffic on a network</td>
<td>4.7.4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>ethtool - query or control network driver and hardware settings, particularly for wired Ethernet devices</td>
<td>4.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>swapon, swapoff : enable/disable devices and files for paging and swapping</td>
<td>2.27.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>gdb: gnu debugger</td>
<td>7.9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>iptables - administration tool for IPv4 packet filtering and NAT</td>
<td>1.4.21</td>
<td></td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>dmidecode - DMI table decoder</td>
<td>3.0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>fsck - is used to check and optionally repair a Linux file system</td>
<td>2.27.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>lscpu - display information about the CPU architecture</td>
<td>2.27.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>18</td>
<td>lspci - List all PCI devices</td>
<td>3.4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>19</td>
<td>setpci - utility for querying and configuring PCI devices</td>
<td>3.4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>20</td>
<td>dstat - versatile tool for generating system resource statistics. Replacement for vmstat, iostat and ifstat</td>
<td>0.7.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>21</td>
<td>procps - procps is the package that has a bunch of small useful utilities that give information about processes using the /proc filesystem</td>
<td>3.3.11</td>
<td></td>
<td></td>
</tr>
<tr>
<td>22</td>
<td>tiptop - display hardware performance counters for Linux tasks</td>
<td>2.3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>23</td>
<td>iotop - simple top-like I/O monitor</td>
<td>0.6</td>
<td></td>
<td></td>
</tr>
<tr>
<td>24</td>
<td>blktrace - generate traces of the i/o traffic on block devices</td>
<td>2.0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>25</td>
<td>nicstat - Show Network Interface Card Statistics</td>
<td>1.95</td>
<td></td>
<td></td>
</tr>
<tr>
<td>26</td>
<td>lldptool - manage the LLDP settings and status of lldpad (Link Layer Discovery Protocol)</td>
<td>1.0.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>27</td>
<td>oprofile - a system-wide profiler, capable of profiling all running code at low overhead</td>
<td>1.0.0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>28</td>
<td>latencytop - a tool for developers to visualize system latencies</td>
<td>0.5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>29</td>
<td>kgdb: Kernel gnu debugger.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>30</td>
<td>kdb: kernel debugger.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>31</td>
<td>systemtap - SystemTap provides free software (GPL) infrastructure to simplify the gathering of information about the running Linux system.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>32</td>
<td>kprobes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>33</td>
<td>crash - Analyze Linux crash dump data or a live system</td>
<td>7.1.3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>34</td>
<td>memwatch - memory leak detection tool</td>
<td>2.69</td>
<td></td>
<td></td>
</tr>
<tr>
<td>35</td>
<td>LTTNG - Linux Trace Toolkit Next Generation</td>
<td>2.8.0-pre/2.7.0-rc1-354</td>
<td></td>
<td></td>
</tr>
<tr>
<td>36</td>
<td>powertop - program help to analyse the power consumption</td>
<td>2.8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>37</td>
<td>slabtop - display kernel slab cache information</td>
<td>procps-ng 3.3.11</td>
<td></td>
<td></td>
</tr>
<tr>
<td>38</td>
<td>ktap - script based dynamic tracing tool for Linux</td>
<td>0.4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>39</td>
<td>gprof - performance analysis tool</td>
<td>2.25</td>
<td></td>
<td></td>
</tr>
<tr>
<td>40</td>
<td>valgrind - instrumentation framework for buiding dynamic analysis tools, which can detect memory management and threading bugs,does profiling etc.</td>
<td>3.10.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>41</td>
<td>pktgen - Linux packet generator is a tool to generate packets at very high speed in the kernel.Monitoring and controlling is done via /proc. Sample scripts are available online.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>42</td>
<td>packETHcli - packETHcli is the command line packet generator tool for ethernet. It allows you to create and send any possible packet or sequence of packets on the ethernet link.</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="Debian"><a href="#Debian" class="headerlink" title="Debian "></a><a name="2.4">Debian </a></h3><table>
<thead>
<tr>
<th>No</th>
<th>Tools</th>
<th>verison</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Perf integrated with LLC</td>
<td>3.19.8</td>
<td><strong>Note</strong>: Only minimal testing done.</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>strace - trace system calls and signals</td>
<td>4.9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>ltrace - library call tracer</td>
<td>0.7.3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>netstat</td>
<td>1.42</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>top - display Linux tasks</td>
<td>3.3.9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>pidstat - Report statistics for Linux tasks</td>
<td>11.0.8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>vmstat - Report virtual memory statistics</td>
<td>3.3.9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>ftrace</td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>iostat -  Report CPU statistics and input/output statistics for devices, partitions and network filesystems (NFS)</td>
<td>11.0.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>tcpdump - dump traffic on a network</td>
<td>4.6.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>ethtool - query or control network driver and hardware settings, particularly for wired Ethernet devices</td>
<td>3.16</td>
<td></td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>swapon, swapoff : enable/disable devices and files for paging and swapping</td>
<td>2.25.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>gdb: gnu debugger</td>
<td>7.7.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>iptables - administration tool for IPv4 packet filtering and NAT</td>
<td>1.4.21</td>
<td></td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>dmidecode - DMI table decoder</td>
<td>2.12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>fsck - is used to check and optionally repair a Linux file system</td>
<td>2.25.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>lscpu - display information about the CPU architecture</td>
<td>2.25.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>18</td>
<td>lspci - List all PCI devices</td>
<td>3.2.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>19</td>
<td>setpci - utility for querying and configuring PCI devices</td>
<td>3.2.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>20</td>
<td>dstat - versatile tool for generating system resource statistics. Replacement for vmstat, iostat and ifstat</td>
<td>0.7.2</td>
<td><strong>Note</strong>: some test cases are not working.</td>
<td></td>
</tr>
<tr>
<td>21</td>
<td>procps - procps is the package that has a bunch of small useful utilities that give information about processes using the /proc filesystem</td>
<td>3.3.9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>22</td>
<td>tiptop - display hardware performance counters for Linux tasks</td>
<td>2.3</td>
<td><strong>Note</strong>: Some test cases are not working.</td>
<td></td>
</tr>
<tr>
<td>23</td>
<td>iotop - simple top-like I/O monitor</td>
<td>0.6</td>
<td></td>
<td></td>
</tr>
<tr>
<td>24</td>
<td>blktrace - generate traces of the i/o traffic on block devices</td>
<td>2.0.0.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>25</td>
<td>nicstat - Show Network Interface Card Statistics</td>
<td>1.95</td>
<td></td>
<td></td>
</tr>
<tr>
<td>26</td>
<td>lldptool - manage the LLDP settings and status of lldpad (Link Layer Discovery Protocol)</td>
<td>0.9.46</td>
<td></td>
<td></td>
</tr>
<tr>
<td>27</td>
<td>oprofile - a system-wide profiler, capable of profiling all running code at low overhead</td>
<td>1.0.0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>28</td>
<td>latencytop - a tool for developers to visualize system latencies</td>
<td>0.5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>29</td>
<td>kgdb: Kernel gnu debugger.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>30</td>
<td>kdb: kernel debugger.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>31</td>
<td>systemtap - SystemTap provides free software (GPL) infrastructure to simplify the gathering of information about the running Linux system.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>32</td>
<td>kprobes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>33</td>
<td>crash - Analyze Linux crash dump data or a live system</td>
<td>7.1.3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>34</td>
<td>memwatch - memory leak detection tool</td>
<td>2.69</td>
<td></td>
<td></td>
</tr>
<tr>
<td>35</td>
<td>LTTNG - Linux Trace Toolkit Next Generation</td>
<td>2.5.0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>36</td>
<td>powertop - program help to analyse the power consumption</td>
<td>2.6.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>37</td>
<td>slabtop - display kernel slab cache information</td>
<td>procps-ng 3.3.9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>38</td>
<td>ktap - script based dynamic tracing tool for Linux</td>
<td>0.4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>39</td>
<td>gprof - performance analysis tool</td>
<td>2.25</td>
<td></td>
<td></td>
</tr>
<tr>
<td>40</td>
<td>valgrind - instrumentation framework for buiding dynamic analysis tools, which can detect memory management and threading bugs,does profiling etc</td>
<td>3.10.0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>41</td>
<td>sysdig</td>
<td>0.1.89</td>
<td></td>
<td></td>
</tr>
<tr>
<td>42</td>
<td>pktgen - Linux packet generator is a tool to generate packets at very high speed in the kernel.Monitoring and controlling is done via /proc. Sample scripts are available online.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>43</td>
<td>packETHcli - packETHcli is the command line packet generator tool for ethernet. It allows you to create and send any possible packet or sequence of packets on the ethernet link.</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS "></a><a name="2.5">CentOS </a></h3><table>
<thead>
<tr>
<th>No</th>
<th>Tools</th>
<th>verison</th>
<th>Note</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>Perf integrated with LLC</td>
<td>4.2.0.26.el7.1.aarch64.debug.gbbb5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>strace - trace system calls and signals</td>
<td>4.8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>ltrace - library call tracer</td>
<td>0.7.91</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>netstat</td>
<td>net-tools 2.10-alpha</td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>top - display Linux tasks</td>
<td>3.3.10(proc-ps-ng)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>pidstat - Report statistics for Linux tasks</td>
<td>10.1.5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7</td>
<td>vmstat - Report virtual memory statistics</td>
<td>3.3.10(proc-ps-ng)</td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>ftrace</td>
<td></td>
<td></td>
</tr>
<tr>
<td>9</td>
<td>iostat -  Report CPU statistics and input/output statistics for devices, partitions and network filesystems (NFS)</td>
<td>10.1.5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>10</td>
<td>tcpdump - dump traffic on a network</td>
<td>4.5.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>11</td>
<td>ethtool - query or control network driver and hardware settings, particularly for wired Ethernet devices</td>
<td>3.15</td>
<td></td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>swapon, swapoff : enable/disable devices and files for paging and swapping</td>
<td>util-linux 2.26.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>13</td>
<td>gdb: gnu debugger</td>
<td>7.6.1-80.el7</td>
<td></td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>iptables - administration tool for IPv4 packet filtering and NAT</td>
<td>1.4.21</td>
<td></td>
<td></td>
</tr>
<tr>
<td>15</td>
<td>dmidecode - DMI table decoder</td>
<td>2.12</td>
<td></td>
<td></td>
</tr>
<tr>
<td>16</td>
<td>fsck - is used to check and optionally repair a Linux file system</td>
<td>util-linux 2.23.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>17</td>
<td>lscpu - display information about the CPU architecture</td>
<td>util-linux 2.23.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>18</td>
<td>lspci - List all PCI devices</td>
<td>3.2.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>19</td>
<td>setpci - utility for queryin0g and configuring PCI devices</td>
<td>3.2.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>20</td>
<td>dstat - versatile tool for generating system resource statistics. Replacement for vmstat, iostat and ifstat</td>
<td>0.7.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>21</td>
<td>procps - procps is the package that has a bunch of small useful utilities that give information about processes using the /proc filesystem</td>
<td>3.3.10</td>
<td></td>
<td></td>
</tr>
<tr>
<td>22</td>
<td>tiptop - display hardware performance counters for Linux tasks</td>
<td>2.3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>23</td>
<td>iotop - simple top-like I/O monitor</td>
<td>0.6</td>
<td></td>
<td></td>
</tr>
<tr>
<td>24</td>
<td>blktrace - generate traces of the i/o traffic on block devices</td>
<td>2.0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>25</td>
<td>nicstat - Show Network Interface Card Statistics</td>
<td>1.95</td>
<td></td>
<td></td>
</tr>
<tr>
<td>26</td>
<td>lldptool - manage the LLDP settings and status of lldpad (Link Layer Discovery Protocol)</td>
<td>1.0.1-2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>27</td>
<td>oprofile - a system-wide profiler, capable of profiling all running code at low overhead</td>
<td>0.9.9</td>
<td></td>
<td></td>
</tr>
<tr>
<td>28</td>
<td>latencytop - a tool for developers to visualize system latencies</td>
<td>0.5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>29</td>
<td>kgdb: Kernel gnu debugger.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>30</td>
<td>kdb: kernel debugger.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>31</td>
<td>systemtap - SystemTap provides free software (GPL) infrastructure to simplify the gathering of information about the running Linux system</td>
<td>2.8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>32</td>
<td>kprobes</td>
<td></td>
<td></td>
</tr>
<tr>
<td>33</td>
<td>crash - Analyze Linux crash dump data or a live system</td>
<td>7.1.2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>34</td>
<td>memwatch - memory leak detection tool</td>
<td>2.69</td>
<td></td>
<td></td>
</tr>
<tr>
<td>35</td>
<td>powertop - program help to analyse the power consumption</td>
<td>2.8</td>
<td></td>
<td></td>
</tr>
<tr>
<td>36</td>
<td>slabtop - display kernel slab cache information</td>
<td>procps-ng 3.3.10</td>
<td></td>
<td></td>
</tr>
<tr>
<td>37</td>
<td>ktap - script based dynamic tracing tool for Linux</td>
<td>0.4</td>
<td></td>
<td></td>
</tr>
<tr>
<td>38</td>
<td>gprof - performance analysis tool</td>
<td>2.23.52.0.1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>39</td>
<td>valgrind - instrumentation framework for buiding dynamic analysis tools, which can detect memory management and threading bugs,does profiling etc</td>
<td>3.10.0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>40</td>
<td>pktgen - Linux packet generator is a tool to generate packets at very high speed in the kernel.Monitoring and controlling is done via /proc. Sample scripts are available online.</td>
<td></td>
<td></td>
</tr>
<tr>
<td>41</td>
<td>packETHcli - packETHcli is the command line packet generator tool for ethernet. It allows you to create and send any possible packet or sequence of packets on the ethernet link.</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="Miscelleneous-Tools"><a href="#Miscelleneous-Tools" class="headerlink" title="Miscelleneous Tools "></a><a name="2.6">Miscelleneous Tools </a></h3><ol>
<li>mkfs - build a Linux file system on a device, usually a hard disk partition.</li>
<li>mount - mount a file system.</li>
<li>du - estimates the file space usage.</li>
<li>df - report file system disk space usage.</li>
<li>tail - this utility outputs the last part of the files.</li>
<li>grep - tool searches the named input files for lines contains a match to the given pattern.</li>
<li>awk - pattern scanning and processing language.</li>
<li>sed - is a stream editor, used to perform basic text transformations.</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Caliper_Manual.4All.md]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/All/Caliper_Manual.4All/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">What is Caliper?</a></li>
<li><a href="#2">Caliper Organization</a></li>
<li><a href="#3">System Requirements</a><ul>
<li><a href="#3.1">Software Requirements</a><ul>
<li><a href="#3.1.1">Host Dependency</a></li>
<li><a href="#3.1.2">Server Dependency</a></li>
<li><a href="#3.1.3">Target Dependency</a></li>
</ul>
</li>
<li><a href="#3.2">Host OS requirements</a></li>
<li><a href="#3.3">Toolchain</a></li>
</ul>
</li>
<li><a href="#4">Caliper Setup</a><ul>
<li><a href="#4.1">Download Caliper</a></li>
<li><a href="#4.2">Install Caliper(optional)</a></li>
<li><a href="#4.3">Caliper Configuration</a><ul>
<li><a href="#4.3.1">Target Configuration</a></li>
<li><a href="#4.3.2">Mail List Configuration</a></li>
<li><a href="#4.3.3">Execution Preference Configuration</a></li>
<li><a href="#4.3.4">Benchmark Selection</a></li>
<li><a href="#4.3.5">Benchmark Test Case Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#5">Caliper Execution</a></li>
<li><a href="#6">Caliper Output</a></li>
<li><a href="#7">Caliper Architecture</a></li>
<li><a href="#8">Benchmark Addition</a><ul>
<li><a href="#8.1">Test Case Definition Structure</a></li>
<li><a href="#8.2">Benchmark Definition</a></li>
<li><a href="#8.3">Benchmark Building</a></li>
<li><a href="#8.4">Benchmark Execution Configuration</a></li>
<li><a href="#8.5">Benchmark Output Parsing</a></li>
<li><a href="#8.6">Computing The Score</a></li>
<li><a href="#8.7">Generating Yaml File</a></li>
</ul>
</li>
<li><a href="#9">Caliper Report Generation</a></li>
<li><a href="#10">List of Benchmarks Supported in Caliper</a></li>
</ul>
<a id="more"></a>
<p>For the details, please refer to <a href="http://open-estuary.org/caliper-benchmarking/" target="_blank" rel="external">http://open-estuary.org/caliper-benchmarking/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Quick_Deployment.4D03]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/D03/Quick_Deployment.4D03/</url>
      <content type="html"><![CDATA[<ul>
<li><a href="#1">Introduction</a></li>
<li><a href="#2">Quick Deploy System</a><ul>
<li><a href="#2.1">Deploy system via USB Disk</a></li>
<li><a href="#2.2">Deploy system via DVD/BMC</a></li>
<li><a href="#2.3">Deploy system via PXE</a><a id="more"></a>
</li>
</ul>
</li>
</ul>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><a name="1">Introduction</a></h2><p>Above all, prepare hardware boards with SCSI disk and download Estuary source code from GitHub.<br>To learn more about how to do them, please visit this web site: <a href="http://open-estuary.com/estuary-user-manual/" target="_blank" rel="external">http://open-estuary.com/estuary-user-manual/</a>, and then refer to ‘Get &amp; Build Estuary yourself’.<br>Note: In my case, the working directory is <code>~/workdir</code>.</p>
<h2 id="Quick-Deploy-System"><a href="#Quick-Deploy-System" class="headerlink" title="Quick Deploy System"></a><a name="2">Quick Deploy System</a></h2><h3 id="Deploy-system-via-USB-Disk"><a href="#Deploy-system-via-USB-Disk" class="headerlink" title="Deploy system via USB Disk"></a><a name="2.1">Deploy system via USB Disk</a></h3><ol>
<li>Prepare usb install disk.<ul>
<li>Modify <code>estuary/estuarycfg.json</code>. Make sure the platform, distros are all right.</li>
<li>Change the value of “install” to “yes” in object “setup” for usb and the value “device” to your USB install disk.<br>(Notice: if the specified usb device does not exist, the first usb device will be selected by default.)</li>
<li>Use <code>build.sh</code> to create the usb install disk.<br>eg: <code>./estuary/build.sh -f estuary/estuarycfg.json</code></li>
</ul>
</li>
<li>Connect the usb install disk to the board.</li>
<li>Reboot the board.</li>
<li>Boot from the usb device. (About how to boot from USB device, please refer to the UEFI related manual.)</li>
<li>According to the prompt to deploy the system.</li>
<li>Start the boards from “grub” menu of UEFI by default.</li>
</ol>
<h3 id="Deploy-system-via-DVD-BMC"><a href="#Deploy-system-via-DVD-BMC" class="headerlink" title="Deploy system via DVD/BMC"></a><a name="2.2">Deploy system via DVD/BMC</a></h3><ol>
<li>Prepare ISO image and install disk.<ul>
<li>Modify <code>estuary/estuarycfg.json</code>. Make sure the platform, distros are all right.</li>
<li>Change the value of “install” to “yes” in object “setup” for iso and the value “name” to your target iso image file name.</li>
<li>Use <code>build.sh</code> to create the target install iso image file.<br>eg: <code>./estuary/build.sh -f estuary/estuarycfg.json</code></li>
</ul>
</li>
<li>Via DVD<ul>
<li>Burn the iso image file to DVD disk if you use the physical DVD driver.</li>
<li>Connect the physical DVD driver to the board, plug in the install DVD disk.</li>
<li>Reboot the board.</li>
<li>Boot from the DVD device. (About how to boot from DVD device, please refer to the UEFI related manual.)</li>
<li>According to the prompt to deploy the system.</li>
<li>Start the boards from “grub” menu of UEFI by default.</li>
</ul>
</li>
<li>Via BMC<ul>
<li>Login BMC website of specified IP with browser(IE browser is suggested to use), The <code>username</code> &amp; <code>password</code> is <code>root</code> &amp; <code>Huawei12#$</code>.</li>
<li>Click “Remote” on the top of BMC webiste. Select “Remote Virtual Console (Private Mode)” to enter into KVM interface. Click “Image File” and choose the iso image, then click “Connect” button.</li>
<li>Click “Config” on the top of BMC website, click “Boot Option” to select “DVD-ROM drive”, then click “Save” button.</li>
<li>Reboot the board</li>
<li>According to the prompt to deploy the system.</li>
</ul>
</li>
</ol>
<h3 id="Deploy-system-via-PXE"><a href="#Deploy-system-via-PXE" class="headerlink" title="Deploy system via PXE"></a><a name="2.3">Deploy system via PXE</a></h3><ol>
<li>Connect Ubuntu PC and hardware boards into the same local area network. (Make sure the PC can connect to the internet and no other PXE servers exist.)</li>
<li>Modify the configuration file of <code>estuary/estuarycfg.json</code> based on your hardware boards. Change the values of mac to physical addresses of the connected network cards on the board. Change the value of “install” to “yes” in object “setup” for PXE.</li>
<li>Backup files under the tftp root directory if necessary. Use <code>build.sh</code> to build project and setup the PXE server on Ubuntu PC.<br>eg: <code>./estuary/build.sh -f estuary/estuarycfg.json</code></li>
<li>After that, install minicom and connect the serial ports of hardware boards to the Ubuntu PC. Connect the hardware boards by minicom using serial ports.</li>
<li>Reboot the hardware boards and start the boards from the correct EFI Network.</li>
<li>Install the system according to prompt. After install finished, the boards will restart automatically.</li>
<li>Start the boards from “grub” menu of UEFI by default.</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Readme.4D03]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Documents/D03/Readme.4D03/</url>
      <content type="html"><![CDATA[<p>This is the readme file for D03 platform<br><a id="more"></a></p>
<p>After you executed<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./estuary/build.sh --file=./estuary/estuarycfg.json --builddir=./workspace</div></pre></td></tr></table></figure></p>
<p>for D03, all targets files will be produced. they are:</p>
<h3 id="UEFI-D03-fd"><a href="#UEFI-D03-fd" class="headerlink" title="UEFI_D03.fd"></a>UEFI_D03.fd</h3><p><strong>description</strong>: <code>UEFI_D03.fd</code> is the UEFI bios for D03 platform.<br><strong>target</strong>: <code>&lt;project root&gt;/workspace/binary/D03/UEFI_D03.fd</code><br><strong>source</strong>: <code>&lt;project root&gt;/uefi</code></p>
<p>build commands(supposedly, you are in <code>&lt;project root&gt;</code> currently):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./estuary/submodules/build-uefi.sh --platform=D03 --output=workspace</div></pre></td></tr></table></figure></p>
<h3 id="grubaa64-efi"><a href="#grubaa64-efi" class="headerlink" title="grubaa64.efi"></a>grubaa64.efi</h3><p><strong>description</strong>: <code>grubaa64.efi</code> is used to load kernel image and dtb files from SATA, SAS, USB Disk, or NFS into RAM and start the kernel.<br><strong>target</strong>: <code>&lt;project root&gt;/workspace/binary/arm64/grubaa64.efi</code><br><strong>source</strong>: <code>&lt;project root&gt;/grub</code></p>
<p>build commands(supposedly, you are in <code>&lt;project root&gt;</code> currently):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./estuary/submodules/build-grub.sh --output=./workspace</div></pre></td></tr></table></figure></p>
<p>if your host is not arm architecture, please execute<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./estuary/submodules/build-grub.sh --output=./workspace --cross=aarch64-linux-gnu-</div></pre></td></tr></table></figure></p>
<p>Note: more details about how to install <code>gcc-linaro-aarch64-linux-gnu-4.9-2014.09_linux</code>, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md" target="_blank" rel="external">https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md</a>.</p>
<h3 id="Image-amp-hip06-d03-dtb"><a href="#Image-amp-hip06-d03-dtb" class="headerlink" title="Image &amp; hip06-d03.dtb"></a>Image &amp; hip06-d03.dtb</h3><p><strong>descriptions</strong>: <code>Image</code> is the kernel executable program, and <code>hip06-d03.dtb</code> is the device tree binary.<br><strong>target</strong>:<br><code>Image</code> in <code>&lt;project root&gt;/workspace/binary/arm64/Image</code><br><code>hip06-d03.dtb</code> in <code>&lt;project root&gt;/workspace/binary/D03/hip06-d03.dtb</code><br><strong>source</strong>: <code>&lt;project root&gt;/kernel</code></p>
<p>build commands(supposedly, you are in <code>&lt;project root&gt;</code> currently):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./estuary/submodules/build-kernel.sh --platform=D03 --output=workspace</div></pre></td></tr></table></figure></p>
<p>if your host is not arm architecture, please execute<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./estuary/submodules/build-kernel.sh --platform=D03 --output=workspace --cross=aarch64-linux-gnu-</div></pre></td></tr></table></figure></p>
<p>Note: more details about how to install <code>gcc-linaro-aarch64-linux-gnu-4.9-2014.09_linux</code>, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md" target="_blank" rel="external">https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md</a>.</p>
<p>More detail about distributions, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Distributions_Guide.4All.md" target="_blank" rel="external">Distributions_Guide.md</a>.</p>
<p>More detail about toolchains, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Toolchains_Guide.4All.md" target="_blank" rel="external">Toolchains_Guide.md</a>.</p>
<p>More detail about how to deploy target system into D03 board, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Deploy_Manual.4D03.md" target="_blank" rel="external">Deployment_Manual.md</a>.</p>
<p>More detail about how to debug, analyse, diagnose system, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Armor_Manual.4All.md" target="_blank" rel="external">Armor_Manual.md</a>.</p>
<p>More detail about how to benchmark system, please refer to <a href="https://github.com/open-estuary/estuary/blob/master/doc/Caliper_Manual.4All.md" target="_blank" rel="external">Caliper_Manual.md</a>.</p>
<p>More detail about how to access remote boards in OpenLab, please refer to <a href="http://open-estuary.org/accessing-boards-in-open-lab/" target="_blank" rel="external">Boards_in_OpenLab</a>.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 部署]]></title>
      <url>http://jarsonfang.github.io/etesting/Tools/Hexo/hexo-deploy/</url>
      <content type="html"><![CDATA[<p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure></p>
<p>在开始之前，您必须先在 <code>_config.yml</code> 中修改参数，一个正确的部署配置中至少要有 <code>type</code> 参数，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div></pre></td></tr></table></figure></p>
<p>您可同时使用多个 deployer，Hexo 会依照顺序执行每个 deployer。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">- type: git</div><div class="line">  repo:</div><div class="line">- type: heroku</div><div class="line">  repo:</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>安装 hexo-deployer-git。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>
<p>修改配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: &lt;repository url&gt;</div><div class="line">  branch: [branch]</div><div class="line">  message: [message]</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>repo</td>
<td>库(Repository)地址</td>
</tr>
<tr>
<td>branch</td>
<td>分支名称。如果您使用的是GitHub或GitCafe的话，程序会尝试自动检测。</td>
</tr>
<tr>
<td>message</td>
<td>自定义提交信息（默认为Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }} ）</td>
</tr>
</tbody>
</table>
<h2 id="Rsync"><a href="#Rsync" class="headerlink" title="Rsync"></a>Rsync</h2><p>安装 hexo-deployer-rsync。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-rsync --save</div></pre></td></tr></table></figure></p>
<p>修改配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: rsync</div><div class="line">  host: &lt;host&gt;</div><div class="line">  user: &lt;user&gt;</div><div class="line">  root: &lt;root&gt;</div><div class="line">  port: [port]</div><div class="line">  delete: [true|false]</div><div class="line">  verbose: [true|false]</div><div class="line">  ignore_errors: [true|false]</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>host</td>
<td>远程主机的地址</td>
<td></td>
</tr>
<tr>
<td>user</td>
<td>使用者名称</td>
<td></td>
</tr>
<tr>
<td>root</td>
<td>远程主机的根目录</td>
<td></td>
</tr>
<tr>
<td>port</td>
<td>端口</td>
<td>22</td>
</tr>
<tr>
<td>delete</td>
<td>删除远程主机上的旧文件</td>
<td>true</td>
</tr>
<tr>
<td>verbose</td>
<td>显示调试信息</td>
<td>true</td>
</tr>
<tr>
<td>ignore_errors</td>
<td>忽略错误</td>
<td>false</td>
</tr>
</tbody>
</table>
<h2 id="FTPSync"><a href="#FTPSync" class="headerlink" title="FTPSync"></a>FTPSync</h2><p>安装 hexo-deployer-ftpsync。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-deployer-ftpsync --save</div></pre></td></tr></table></figure></p>
<p>修改配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: ftpsync</div><div class="line">  host: &lt;host&gt;</div><div class="line">  user: &lt;user&gt;</div><div class="line">  pass: &lt;password&gt;</div><div class="line">  remote: [remote]</div><div class="line">  port: [port]</div><div class="line">  ignore: [ignore]</div><div class="line">  connections: [connections]</div><div class="line">  verbose: [true|false]</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>host</td>
<td>远程主机的地址</td>
<td></td>
</tr>
<tr>
<td>user</td>
<td>使用者名称</td>
<td></td>
</tr>
<tr>
<td>pass</td>
<td>密码</td>
<td></td>
</tr>
<tr>
<td>remote</td>
<td>远程主机的根目录</td>
<td>/</td>
</tr>
<tr>
<td>port</td>
<td>端口</td>
<td>21</td>
</tr>
<tr>
<td>ignore</td>
<td>忽略的文件或根目录</td>
<td></td>
</tr>
<tr>
<td>connections</td>
<td>使用的连接数</td>
<td>1</td>
</tr>
<tr>
<td>verbose</td>
<td>显示调试信息</td>
<td>false</td>
</tr>
</tbody>
</table>
<h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><p>Hexo 生成的所有文件都放在 <code>public</code> 文件夹中，您可以将它们复制到您喜欢的地方。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 资源文件夹]]></title>
      <url>http://jarsonfang.github.io/etesting/Tools/Hexo/hexo-asset-folders/</url>
      <content type="html"><![CDATA[<p>资源（Asset）代表 <code>source</code> 文件夹中除了文章以外的所有文件，例如图片、CSS、JS 文件等。比方说，如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们放在 <code>source/images</code> 文件夹中。然后通过类似于 <code>![](/images/image.jpg)</code> 的方法访问它们。</p>
<a id="more"></a>
<p><strong>文章资源文件夹</strong></p>
<p>对于那些想要更有规律地提供图片和其他资源以及想要将他们的资源分布在各个文章上的人来说，Hexo也提供了更组织化的方式来管理资源。这个稍微有些复杂但是管理资源非常方便的功能可以通过将 <code>_config.yml</code> 文件中的 <code>post_asset_folder</code> 选项设为 <code>true</code> 来打开。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">post_asset_folder: true</div></pre></td></tr></table></figure></p>
<p>当资源文件管理功能打开后，Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个 markdown 文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p>
<p><strong>相对路径引用的标签插件</strong></p>
<p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% asset_path slug %&#125;</div><div class="line">&#123;% asset_img slug [title] %&#125;</div><div class="line">&#123;% asset_link slug [title] %&#125;</div></pre></td></tr></table></figure></p>
<p>比如说：当你打开文章资源文件夹功能后，你把一个 <code>example.jpg</code> 图片放在了你的资源文件夹中，如果通过使用相对路径的常规 markdown 语法 <code>![](/example.jpg)</code> ，它将 不会 出现在首页上。（但是它会在文章中按你期待的方式工作）</p>
<p>正确的引用图片方式是使用下列的标签插件而不是 markdown ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;% asset_img example.jpg This is an example image %&#125;</div></pre></td></tr></table></figure></p>
<p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p>
<p>Q: 如果有的文章需要资源文件夹，有的文章不需要资源文件夹怎么弄？<br>A: 直接用markdown，把图片放到指定的文件夹（而不是跟文章同名的那个文件夹）？</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 标签插件]]></title>
      <url>http://jarsonfang.github.io/etesting/Tools/Hexo/hexo-tag-plugins/</url>
      <content type="html"><![CDATA[<p>标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。</p>
<h2 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h2><p>在文章中插入引言，可包含作者、来源和标题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;</div><div class="line">content</div><div class="line">&#123;% endblockquote %&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>没有提供参数，则只输出普通的blockquote</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% blockquote %&#125;</div><div class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</div><div class="line">&#123;% endblockquote %&#125;</div></pre></td></tr></table></figure></p>
<blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p>
</blockquote>
<p><strong>引用书上的句子</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% blockquote David Levithan, Wide Awake %&#125;</div><div class="line">Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</div><div class="line">&#123;% endblockquote %&#125;</div></pre></td></tr></table></figure></p>
<blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p>
<footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote>
<p><strong>引用Twitter</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %&#125;</div><div class="line">NEW: DevDocs now comes with syntax highlighting. http://devdocs.io</div><div class="line">&#123;% endblockquote %&#125;</div></pre></td></tr></table></figure></p>
<blockquote><p>NEW: DevDocs now comes with syntax highlighting. <a href="http://devdocs.io" target="_blank" rel="external">http://devdocs.io</a></p>
<footer><strong>@DevDocs</strong><cite><a href="https://twitter.com/devdocs/status/356095192085962752" target="_blank" rel="external">twitter.com/devdocs/status/356095192085962752</a></cite></footer></blockquote>
<p><strong>引用网络上的文章</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&#125;</div><div class="line">Every interaction is both precious and an opportunity to delight.</div><div class="line">&#123;% endblockquote %&#125;</div></pre></td></tr></table></figure></p>
<blockquote><p>Every interaction is both precious and an opportunity to delight.</p>
<footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html" target="_blank" rel="external">Welcome to Island Marketing</a></cite></footer></blockquote>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>在文章中插入代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;</div><div class="line">code snippet</div><div class="line">&#123;% endcodeblock %&#125;</div></pre></td></tr></table></figure></p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><strong>普通的代码块</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% codeblock %&#125;</div><div class="line">alert(&apos;Hello World!&apos;);</div><div class="line">&#123;% endcodeblock %&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(&apos;Hello World!&apos;);</div></pre></td></tr></table></figure>
<p><strong>指定语言</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% codeblock lang:objc %&#125;</div><div class="line">[rectangle setX: 10 y: 10 width: 20 height: 20];</div><div class="line">&#123;% endcodeblock %&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[rectangle setX: <span class="number">10</span> y: <span class="number">10</span> width: <span class="number">20</span> height: <span class="number">20</span>];</div></pre></td></tr></table></figure>
<p><strong>附加说明</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% codeblock Array.map %&#125;</div><div class="line">array.map(callback[, thisArg])</div><div class="line">&#123;% endcodeblock %&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><figcaption><span>Array.map</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array.map(callback[, thisArg])</div></pre></td></tr></table></figure>
<p><strong>附加说明和网址</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;% codeblock \_.compact http://underscorejs.org/#compact Underscore.js %&#125;</div><div class="line">\_.compact([0, 1, false, 2, &apos;&apos;, 3]);</div><div class="line">=&gt; [1, 2, 3]</div><div class="line">&#123;% endcodeblock %&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><figcaption><span>\_.compact</span><a href="http://underscorejs.org/#compact" target="_blank" rel="external">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">\_.compact([0, 1, false, 2, &apos;&apos;, 3]);</div><div class="line">=&gt; [1, 2, 3]</div></pre></td></tr></table></figure>
<h2 id="其他标签"><a href="#其他标签" class="headerlink" title="其他标签"></a>其他标签</h2><h3 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h3><p>引用其他文章的链接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123;% post_path slug %&#125;</div><div class="line">&#123;% post_link slug [title] %&#125;</div></pre></td></tr></table></figure></p>
<p><strong>示例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;% post_path hexo-commands %&#125;</div></pre></td></tr></table></figure></p>
/etesting/Tools/Hexo/hexo-commands/
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;% post_link hexo-commands %&#125;</div></pre></td></tr></table></figure>
<a href="/etesting/Tools/Hexo/hexo-commands/" title="Hexo 命令">Hexo 命令</a>
<h3 id="引用资源"><a href="#引用资源" class="headerlink" title="引用资源"></a>引用资源</h3><p>引用文章的资源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% asset_path slug %&#125;</div><div class="line">&#123;% asset_img slug [title] %&#125;</div><div class="line">&#123;% asset_link slug [title] %&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Raw"><a href="#Raw" class="headerlink" title="Raw"></a>Raw</h3><p>如果您想在文章中插入 Swig 标签，可以尝试使用 Raw 标签，以免发生解析异常。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% raw %&#125;</div><div class="line">content</div><div class="line">&#123;% endraw %&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 基本操作]]></title>
      <url>http://jarsonfang.github.io/etesting/Tools/Hexo/hexo-operations/</url>
      <content type="html"><![CDATA[<h2 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h2><p>您可以执行下列命令来创建一篇新文章。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new [layout] &lt;title&gt;</div></pre></td></tr></table></figure></p>
<p>您可以在命令中指定文章的布局(layout)，默认为<code>post</code>，可以通过修改<code>_config.yml</code>中的<code>default_layout</code>参数来指定默认布局。</p>
<p><strong>布局(layout)</strong></p>
<p>Hexo有三种默认布局：<code>post</code>、<code>page</code>和<code>draft</code>，它们分别对应不同的路径，而您自定义的其他布局和<code>post</code>相同，都将存储到<code>source/_posts</code>文件夹。</p>
<table>
<thead>
<tr>
<th>布局</th>
<th>路径</th>
</tr>
</thead>
<tbody>
<tr>
<td>post</td>
<td>source/_posts</td>
</tr>
<tr>
<td>page</td>
<td>source</td>
</tr>
<tr>
<td>draft</td>
<td>source/_drafts</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>不要处理我的文章</strong><br>如果你不想你的文章被处理，你可以将Front-Matter中的<code>layout:</code>设为<code>false</code>。</p>
</blockquote>
<a id="more"></a>
<p><strong>文件名称</strong></p>
<p>Hexo默认以标题作为文件名称，但您可编辑<code>new_post_name</code>参数来改变默认的文件名称，举例来说，设为<code>:year-:month-:day-:title.md</code>可让您更方便的通过日期来管理文章。</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>:title</code></td>
<td>标题（小写，空格将会被替换为短杠）</td>
</tr>
<tr>
<td><code>:year</code></td>
<td>建立的年份，比如，<code>2015</code></td>
</tr>
<tr>
<td><code>:month</code></td>
<td>建立的月份（有前导零），比如，<code>04</code></td>
</tr>
<tr>
<td><code>:i_month</code></td>
<td>建立的月份（无前导零），比如，<code>4</code></td>
</tr>
<tr>
<td><code>:day</code></td>
<td>建立的日期（有前导零），比如，<code>07</code></td>
</tr>
<tr>
<td><code>:i_day</code></td>
<td>建立的日期（无前导零），比如，<code>7</code></td>
</tr>
</tbody>
</table>
<p><strong>草稿</strong></p>
<p>刚刚提到了 Hexo 的一种特殊布局：<code>draft</code>，这种布局在建立时会被保存到 <code>source/_drafts</code> 文件夹，您可通过 <code>publish</code> 命令将草稿移动到 <code>source/_posts</code> 文件夹，该命令的使用方式与 <code>new</code> 十分类似，您也可在命令中指定 <code>layout</code> 来指定布局。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo publish [layout] &lt;title&gt;</div></pre></td></tr></table></figure></p>
<p>草稿默认不会显示在页面中，您可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿。</p>
<p><strong>模板(Scaffold)</strong></p>
<p>在新建文章时，Hexo 会根据 <code>scaffolds</code> 文件夹内相对应的文件来建立文件，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new photo <span class="string">"My Gallery"</span></div></pre></td></tr></table></figure></p>
<p>在执行这行指令时，Hexo 会尝试在 <code>scaffolds</code> 文件夹中寻找<code>photo.md</code>，并根据其内容建立文章，以下是您可以在模版中使用的变量：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>layout</code></td>
<td>布局</td>
</tr>
<tr>
<td><code>title</code></td>
<td>标题</td>
</tr>
<tr>
<td><code>date</code></td>
<td>文件建立日期</td>
</tr>
</tbody>
</table>
<h2 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h2><p>Front-matter 是文件最上方以<code>---</code>分隔的区域，用于指定个别文件的变量，举例来说：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">title: Hello World</div><div class="line">date: 2013/7/13 20:46:25</div><div class="line">---</div></pre></td></tr></table></figure></p>
<p>以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>layout</td>
<td>布局</td>
<td></td>
</tr>
<tr>
<td>title</td>
<td>标题</td>
<td></td>
</tr>
<tr>
<td>date</td>
<td>建立日期</td>
<td>文件建立日期</td>
</tr>
<tr>
<td>updated</td>
<td>更新日期</td>
<td>文件更新日期</td>
</tr>
<tr>
<td>comments</td>
<td>开启文章的评论功能</td>
<td>true</td>
</tr>
<tr>
<td>tags</td>
<td>标签（不适用于页面(pages)）</td>
<td></td>
</tr>
<tr>
<td>categories</td>
<td>分类（不适用于页面(pages)）</td>
<td></td>
</tr>
<tr>
<td>permalink</td>
<td>覆盖文章默认的永久链接</td>
</tr>
</tbody>
</table>
<p><strong>分类和标签</strong></p>
<p>只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 <code>Foo, Bar</code> 不等于 <code>Bar, Foo</code>；而标签没有顺序和层次。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">categories:</div><div class="line">- Sports</div><div class="line">- Baseball</div><div class="line">tags:</div><div class="line">- Injury</div><div class="line">- Fight</div><div class="line">- Shocking</div></pre></td></tr></table></figure></p>
<p><strong>JSON Front-matter</strong></p>
<p>除了 YAML 外，你也可以使用 JSON 来编写 Front-matter，只要将 <code>---</code> 代换成 <code>;;;</code> 即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;title&quot;: &quot;Hello World&quot;,</div><div class="line">&quot;date&quot;: &quot;2013/7/13 20:46:25&quot;</div><div class="line">;;;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo 命令]]></title>
      <url>http://jarsonfang.github.io/etesting/Tools/Hexo/hexo-commands/</url>
      <content type="html"><![CDATA[<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p><strong>init</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo init [folder]</div></pre></td></tr></table></figure></p>
<p>新建一个网站。如果没有设置<code>folder</code>，Hexo默认在目前的文件夹建立网站。</p>
<p><strong>new</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new [layout] &lt;title&gt;</div></pre></td></tr></table></figure></p>
<p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <code>_config.yml</code> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。<br><a id="more"></a></p>
<p><strong>generate</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure></p>
<p>生成静态文件。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-d</code>, <code>--deploy</code></td>
<td>文件生成后立即部署网站</td>
</tr>
<tr>
<td><code>-w</code>, <code>--watch</code></td>
<td>监视文件变动</td>
</tr>
</tbody>
</table>
<p><strong>publish</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo publish [layout] &lt;filename&gt;</div></pre></td></tr></table></figure></p>
<p>发表草稿。</p>
<p><strong>server</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>启动服务器。默认情况下，访问网址为：<code>http://localhost:4000/</code>。</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-p</code>, <code>--port</code></td>
<td>重设端口</td>
</tr>
<tr>
<td><code>-s</code>, <code>--static</code></td>
<td>只使用静态文件</td>
</tr>
<tr>
<td><code>-l</code>, <code>--log</code></td>
<td>启动日志记录，使用覆盖记录格式</td>
</tr>
</tbody>
</table>
<p><strong>deploy</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure></p>
<p>部署网站。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-g</code>, <code>--generate</code></td>
<td>部署之前预先生成静态文件</td>
</tr>
</tbody>
</table>
<p><strong>render</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo render &lt;file1&gt; [file2] ...</div></pre></td></tr></table></figure></p>
<p>渲染文件。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>-o</code>, <code>--output</code></td>
<td>设置输出路径</td>
</tr>
</tbody>
</table>
<p><strong>migrate</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo migrate &lt;<span class="built_in">type</span>&gt;</div></pre></td></tr></table></figure></p>
<p>从其他博客系统迁移内容。<br>例如，迁移 WordPress:<br>首先，安装 <code>hexo-migrator-wordpress</code> 插件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-migrator-wordpress --save</div></pre></td></tr></table></figure></p>
<p>在 WordPress 仪表盘中导出数据(“Tools” → “Export” → “WordPress”)<br>插件安装完成后，执行下列命令来迁移所有文章。source 可以是 WordPress 导出的文件路径或网址。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo migrate wordpress &lt;<span class="built_in">source</span>&gt;</div></pre></td></tr></table></figure></p>
<p><strong>clean</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo clean</div></pre></td></tr></table></figure></p>
<p>清除缓存文件(<code>db.json</code>)和已生成的静态文件(<code>public</code>)。</p>
<p><strong>list</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo list &lt;<span class="built_in">type</span>&gt;</div></pre></td></tr></table></figure></p>
<p>列出网站资料。</p>
<p><strong>version</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo version</div></pre></td></tr></table></figure></p>
<p>显示Hexo版本。</p>
<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p><strong>安全模式</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo --safe</div></pre></td></tr></table></figure></p>
<p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p>
<p><strong>调试模式</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo --debug</div></pre></td></tr></table></figure></p>
<p>在终端中显示调试信息并记录到<code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并<a href="https://github.com/hexojs/hexo/issues/new" target="_blank" rel="external">提交调试信息到GitHub</a></p>
<p><strong>简洁模式</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo --silent</div></pre></td></tr></table></figure></p>
<p>隐藏终端信息。</p>
<p><strong>自定义配置文件的路径</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo --config custom.yml</div></pre></td></tr></table></figure></p>
<p>自定义配置文件的路径，执行后将不再使用<code>_config.yml</code>。</p>
<p><strong>显示草稿</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo --draft</div></pre></td></tr></table></figure></p>
<p>显示 <code>source/_drafts</code> 文件夹中的草稿文章。</p>
<p><strong>自定义CWD</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo --cwd /path/to/cwd</div></pre></td></tr></table></figure></p>
<p>自定义当前工作目录(Current working directory)的路径。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[awk 手册]]></title>
      <url>http://jarsonfang.github.io/etesting/Tools/sed-awk/awk/</url>
      <content type="html"><![CDATA[<blockquote>
<p>简体中文版由bones7456 (<a href="http://li2z.cn)整理" target="_blank" rel="external">http://li2z.cn)整理</a>.<br>原文:应该是 <a href="http://phi.sinica.edu.tw/aspac/reports/94/94011/" target="_blank" rel="external">http://phi.sinica.edu.tw/aspac/reports/94/94011/</a> 但是原文很乱.<br>说明:之前也是对awk几乎一无所知,无意中看到这篇文章,网上一搜,居然没有像样的简体中文版.有的也是不怎么完整,或者错误一大堆的.于是就顺手整理了下这篇文章.通过整理这篇文章,自己也渐渐掌握了awk的种种用法.<br>原文可能比较老,有些目前已经不适用的命令有所改动,文中所有命令均在ubuntu7.04下调试通过,用的awk是mawk.<br>由于本人能力有限,错误和不妥之处在所难免,欢迎多多指正.  </p>
</blockquote>
<a id="more"></a>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="有关本手册"><a href="#有关本手册" class="headerlink" title="有关本手册"></a>有关本手册</h3><p>这是一本awk学习指引, 其重点着重于:</p>
<ol>
<li>awk 适于解决哪些问题?</li>
<li>awk 常见的解题模式为何?</li>
</ol>
<p>为使读者快速掌握awk解题的模式及特性, 本手册系由一些较具代表性的范例及其题解所构成; 各范例由浅入深, 彼此间相互连贯, 范例中并对所使用的awk语法及指令辅以必要的说明. 有关awk的指令, 函数, … 等条列式的说明则收录于附录中, 以利读者往后撰写程序时查阅. 如此编排, 可让读者在短时间内顺畅地学会使用awk来解决问题. 建议读者循着范例上机实习, 以加深学习效果.<br>读者宜先具备下列背景:<br>[a.] UNIX 环境下的简单操作及基本概念.<br>例如: 文件编辑, 文件复制及管道, 输入/输出重定向等概念<br>[b.] C 语言的基本语法及流程控制指令.<br>(awk 指令并不多, 且其中之大部分与C语言中之用法一致, 本手册中对该类指令之语法及特性不再加以繁冗的说明, 读者若欲深究,可自行翻阅相关的 C 语言书籍)</p>
<h2 id="awk概述"><a href="#awk概述" class="headerlink" title="awk概述"></a>awk概述</h2><h3 id="为什么使用awk"><a href="#为什么使用awk" class="headerlink" title="为什么使用awk"></a>为什么使用awk</h3><p>awk 是一种程序语言. 它具有一般程序语言常见的功能.<br>因awk语言具有某些特点, 如: 使用直译器(Interpreter)不需先行编译; 变量无类型之分(Typeless), 可使用文字当数组的下标(Associative Array)…等特色. 因此, 使用awk撰写程序比起使用其它语言更简洁便利且节省时间. awk还具有一些内建功能, 使得awk擅于处理具数据行(Record), 字段(Field)型态的资料; 此外, awk内建有pipe的功能, 可将处理中的数据传送给外部的Shell命令加以处理, 再将Shell命令处理后的数据传回awk程序, 这个特点也使得awk程序很容易使用系统资源.<br>由于awk具有上述特色, 在问题处理的过程中, 可轻易使用awk来撰写一些小工具; 这些小工具并非用来解决整个大问题,它们只扮演解决个别问题过程的某些角色, 可藉由Shell所提供的pipe将数据按需要传送给不同的小工具进行处理, 以解决整个大问题. 这种解题方式, 使得这些小工具可因不同需求而被重复组合及重用(reuse); 也可藉此方式来先行测试大程序原型的可行性与正确性, 将来若需要较高的执行速度时再用C语言来改写.这是awk最常被应用之处. 若能常常如此处理问题, 读者可以以更高的角度来思考抽象的问题, 而不会被拘泥于细节的部份.<br>本手册为awk入门的学习指引, 其内容将先强调如何撰写awk程序,未列入进一步解题方式的应用实例, 这部分将留待UNIX进阶手册中再行讨论.</p>
<h3 id="如何取得awk"><a href="#如何取得awk" class="headerlink" title="如何取得awk"></a>如何取得awk</h3><p>一般的UNIX操作系统, 本身即附有awk. 不同的UNIX操作系统所附的awk其版本亦不尽相同. 若读者所使用的系统上未附有awk,可透过 anonymous ftp 到下列地方取得:<br>phi.sinica.edu.tw:/pub/gnu<br>ftp.edu.tw:/UNIX/gnu<br>prep.ai.mit.edu:/pub/gnu</p>
<h3 id="awk如何工作"><a href="#awk如何工作" class="headerlink" title="awk如何工作"></a>awk如何工作</h3><p>为便于解释awk程序架构, 及有关术语(terminology), 先以一个员工薪资档(emp.dat ), 来加以介绍.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">A125 Jenny 100 210</div><div class="line">A341 Dan 110 215</div><div class="line">P158 Max 130 209</div><div class="line">P148 John 125 220</div><div class="line">A123 Linda 95 210</div></pre></td></tr></table></figure></p>
<p>文件中各字段依次为员工ID, 姓名, 薪资率, 及实际工时. ID中的第一码为部门识别码. “A”,”P” 分别表示”组装”及”包装”部门.<br>本小节着重于说明awk程序的主要架构及工作原理, 并对一些重要的名词辅以必要的解释. 由这部分内容, 读者可体会出awk语言的主要精神及awk与其它语程序言的差异处. 为便于说明, 以条列方式说明于后.</p>
<h3 id="名词定义"><a href="#名词定义" class="headerlink" title="名词定义"></a>名词定义</h3><p><strong>数据行</strong>: awk从数据文件上读取数据的基本单位.以上列文件emp.dat为例, awk读入的<br>第一笔数据行是 “A125 Jenny 100 210”<br>第二笔数据行是 “A341 Dan 110 215”<br>一般而言, 一个数据行就相当于数据文件上的一行资料. (参考 : 附录 B 内建变量”RS”)</p>
<p><strong>字段(Field)</strong>: 为数据行上被分隔开的子字符串.<br>以数据行”A125 Jenny 100 210”为例,<br>第一栏 第二栏 第三栏 第四栏 “A125” “Jenny” 100 210<br>一般是以空格符来分隔相邻的字段. (参考 : 附录 D 内建变量”FS”)</p>
<h2 id="如何执行awk"><a href="#如何执行awk" class="headerlink" title="如何执行awk"></a>如何执行awk</h2><p>于UNIX的命令行上键入诸如下列格式的指令: ( “<code>$</code>“ 表Shell命令行上的提示符号)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="string">'awk程序'</span> 数据文件文件名</div></pre></td></tr></table></figure></p>
<p>则awk会先编译该程序, 然后执行该程序来处理所指定的数据文件.<br>(上列方式系直接把程序写在UNIX的命令行上)</p>
<h3 id="awk-程序的主要结构"><a href="#awk-程序的主要结构" class="headerlink" title="awk 程序的主要结构:"></a>awk 程序的主要结构:</h3><p>awk程序中主要语法是<code>Pattern { Actions }</code>, 故常见之awk程序其型态如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Pattern1 &#123; Actions1 &#125;</div><div class="line">Pattern2 &#123; Actions2 &#125;</div><div class="line">......</div><div class="line">Pattern3 &#123; Actions3 &#125;</div></pre></td></tr></table></figure></p>
<h3 id="Pattern-是什么"><a href="#Pattern-是什么" class="headerlink" title="Pattern 是什么 ?"></a>Pattern 是什么 ?</h3><p>awk可接受许多不同型态的Pattern. 一般常使用”关系表达式”(Relational expression)来当成Pattern.<br>例如:<br><code>x &gt; 34</code> 是一个Pattern, 判断变量 <code>x</code> 与 <code>34</code> 是否存在大于的关系.<br><code>x == y</code> 是一个Pattern, 判断变量 <code>x</code> 与变量 <code>y</code> 是否存在等于的关系.<br>上式中<code>x &gt;34</code>,<code>x == y</code>便是典型的Pattern.</p>
<p>awk 提供 C 语言中常见的关系运算符(Relational Operators) 如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;, &lt;, &gt;=, &lt;=, ==, !=</div></pre></td></tr></table></figure></p>
<p>此外, awk 还提供 <code>~</code> (match) 及 <code>!~</code> (not match) 二个关系运算符(注一).<br>其用法与涵义如下:<br>若 A 为一字符串, B 为一正则表达式(Regular Expression)<br><code>A ~ B</code> 判断字符串 A 中是否 <em>包含</em> 能匹配(match) B 表达式的子字符串.<br><code>A !~ B</code> 判断字符串 A 中是否 <em>不包含</em> 能匹配(match) B 表达式的子字符串.<br>例如 :<br><code>&quot;banana&quot; ~ /an/</code> 整个是一个Pattern.<br>因为”<code>banana</code>“中含有可以匹配 <code>/an/</code> 的子字符串, 故此关系式成立(true),整个Pattern的值也是true.</p>
<p>相关细节请参考 附录 A Patterns, 附录 E Regular Expression</p>
<p>(注一:) 有少数awk论著, 把 <code>~,</code> <code>!~</code> 当成另一类的 Operator, 并不视为一种 Relational Operator. 本手册中将这两个运算符当成一种 Relational Operator.</p>
<h3 id="Actions-是什么"><a href="#Actions-是什么" class="headerlink" title="Actions 是什么?"></a>Actions 是什么?</h3><p>Actions 是由许多awk指令构成. 而awk的指令与 C 语言中的指令十分类似.<br>例如:<br>awk的I/O指令: <code>print, printf( ), getline...</code><br>awk的流程控制指令: <code>if(...){..} else{..}, while(...){...}...</code></p>
<p>(请参考 附录 B — “Actions” )</p>
<h3 id="awk-如何处理-Pattern-Actions"><a href="#awk-如何处理-Pattern-Actions" class="headerlink" title="awk 如何处理 Pattern { Actions } ?"></a>awk 如何处理 Pattern { Actions } ?</h3><p>awk 会先判断(Evaluate) 该 Pattern 的值, 若 Pattern 判断后的值为 true (或不为0的数字,或不是空的字符串), 则 awk 将执行该 Pattern 所对应的 Actions. 反之, 若 Pattern 之值不为 true, 则awk将不执行该 Pattern 所对应的 Actions.</p>
<p>例如 : 若awk程序中有下列两指令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">50 &gt; 23 &#123;<span class="built_in">print</span> <span class="string">"Hello! The word!!"</span> &#125;</div><div class="line"><span class="string">"banana"</span> ~ /123/ &#123; <span class="built_in">print</span> <span class="string">"Good morning !"</span> &#125;</div></pre></td></tr></table></figure></p>
<p>awk会先判断<code>50 &gt;23</code>是否成立. 因为该式成立, 所以awk将印出”<code>Hello! The word!!</code>“. 而另一 Pattern 为<code>&quot;banana&quot; ~/123/</code>, 因为<code>&quot;banana&quot;</code>内未含有任何子字符串可<code>match /123/</code>, 该 Pattern 之值为false, 故awk将不会印出 “<code>Good morning !</code>“</p>
<h3 id="awk-如何处理-Actions-的语法-缺少Pattern部分"><a href="#awk-如何处理-Actions-的语法-缺少Pattern部分" class="headerlink" title="awk 如何处理{ Actions } 的语法? (缺少Pattern部分)"></a>awk 如何处理{ Actions } 的语法? (缺少Pattern部分)</h3><p>有时语法<code>Pattern { Actions }</code>中, <code>Pattern</code> 部分被省略, 只剩 <code>{Actions}</code>. 这种情形表示 “无条件执行这个Actions”.</p>
<h3 id="awk-的字段变量"><a href="#awk-的字段变量" class="headerlink" title="awk 的字段变量"></a>awk 的字段变量</h3><p>awk 所内建的字段变量及其涵意如下 :</p>
<table>
<thead>
<tr>
<th>字段变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$0</code></td>
<td>一字符串, 其内容为目前 awk 所读入的数据行.</td>
</tr>
<tr>
<td><code>$1</code></td>
<td><code>$0</code> 上第一个字段的数据.</td>
</tr>
<tr>
<td><code>$2</code></td>
<td><code>$0</code> 上第二个字段的数据.</td>
</tr>
<tr>
<td>…</td>
<td>其余类推</td>
</tr>
</tbody>
</table>
<h3 id="读入数据行时-awk如何更新-update-这些内建的字段变量"><a href="#读入数据行时-awk如何更新-update-这些内建的字段变量" class="headerlink" title="读入数据行时, awk如何更新(update)这些内建的字段变量?"></a>读入数据行时, awk如何更新(update)这些内建的字段变量?</h3><p>当 awk 从数据文件中读取一个数据行时, awk 会使用内建变量<code>$0</code>予以记录.每当<code>$0</code>被改动时 (例如 : 读入新的数据行或自行变更<code>$0</code>, …) awk 会立刻重新分析 <code>$0</code> 的字段情况, 并将 <code>$0</code> 上各字段的数据用 <code>$1</code>, <code>$2</code>, … 予以记录.</p>
<h3 id="awk的内建变量-Built-in-Variables"><a href="#awk的内建变量-Built-in-Variables" class="headerlink" title="awk的内建变量(Built-in Variables)"></a>awk的内建变量(Built-in Variables)</h3><p>awk 提供了许多内建变量, 使用者于程序中可使用这些变量来取得相关信息. 常见的内建变量有:</p>
<table>
<thead>
<tr>
<th>内建变量</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>NF (Number of Fields)</td>
<td>为一整数, 其值表<code>$0</code>上所存在的字段数目.</td>
</tr>
<tr>
<td>NR (Number of Records)</td>
<td>为一整数, 其值表awk已读入的数据行数目.</td>
</tr>
<tr>
<td>FILENAME</td>
<td>awk 正在处理的数据文件文件名.</td>
</tr>
</tbody>
</table>
<p>例如: awk 从资料文件 emp.dat 中读入第一笔数据行<br>“<code>A125 Jenny 100 210</code>“ 之后, 程序中:<br><code>$0</code> 之值将是 “A125 Jenny 100 210”<br><code>$1</code> 之值为 “A125”<br><code>$2</code> 之值为 “Jenny”<br><code>$3</code> 之值为 100<br><code>$4</code> 之值为 210<br><code>$NF</code> 之值为 4<br><code>$NR</code> 之值为 1<br><code>$FILENAME</code> 之值为 “emp.dat”</p>
<h3 id="awk的工作流程"><a href="#awk的工作流程" class="headerlink" title="awk的工作流程"></a>awk的工作流程</h3><p>执行awk时, 它会反复进行下列四步骤.</p>
<ul>
<li>自动从指定的数据文件中读取一个数据行.</li>
<li>自动更新(Update)相关的内建变量之值. 如:<code>NF</code>,<code>NR</code>, <code>$0</code> …</li>
<li>依次执行程序中所有的<code>Pattern { Actions }</code>指令.</li>
<li>当执行完程序中所有<code>Pattern { Actions }</code>时, 若数据文件中还有未读取的数据, 则反复执行步骤1到步骤4.</li>
</ul>
<p>awk会自动重复进行上述4个步骤, 使用者不须于程序中编写这个循环 (Loop).</p>
<h3 id="打印文件中指定的字段数据并加以计算"><a href="#打印文件中指定的字段数据并加以计算" class="headerlink" title="打印文件中指定的字段数据并加以计算"></a>打印文件中指定的字段数据并加以计算</h3><p>awk 处理数据时, 它会自动从数据文件中一次读取一笔记录, 并会将该数据切分成一个个的字段; 程序中可使用<code>$1</code>, <code>$2</code>, … 直接取得各个字段的内容. 这个特色让使用者易于用 awk 编写 reformatter 来改变量据格式.</p>
<p>范例: 以文件 emp.dat 为例, 计算每人应发工资并打印报表.<br>分析: awk 会自行一次读入一列数据, 故程序中仅需告诉 awk 如何处理所读入的数据行.<br>执行如下命令: (<code>$</code>表UNIX命令行上的提示符)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="string">'&#123; print $2, $3 * $4 &#125;'</span> emp.dat</div></pre></td></tr></table></figure></p>
<p>执行结果如下:<br>屏幕出现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Jenny 21000</div><div class="line">Dan 23650</div><div class="line">Max 27170</div><div class="line">John 27500</div><div class="line">Linda 19950</div></pre></td></tr></table></figure></p>
<p>说明:<br>UNIX命令行上, 执行awk的语法为:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="string">'awk程序'</span> 欲处理的资料文件文件名</div></pre></td></tr></table></figure></p>
<p>本范例中的程序部分为<code>{print $2, $3 * $4}</code>. 把程序置于命令行时, 程序之前后须以<code>&#39;</code>括住. <code>emp.dat</code>为指定给该程序处理的数据文件文件名.</p>
<p>本程序中使用:<code>Pattern { Actions }</code>语法.<br>Pattern 部分被省略, 表无任何限制条件. 故 awk 读入每笔数据行后都将无条件执行这个 Actions.<br><code>print</code>为awk所提供的输出指令, 会将数据输出到stdout(屏幕).<br><code>print</code>的参数间彼此以”<code>,</code>“ (逗号) 隔开, 印出数据时彼此间会以空白隔开. (参考 附录 D 内建变量OFS)</p>
<p>将上述的程序部分储存于文件 <code>pay1.awk</code> 中. 执行命令时再指定awk程序文件之文件名. 这是执行awk的另一种方式, 特别适用于程序较大的情况, 其语法如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="_">-f</span> awk程序文件名 数据文件文件名</div></pre></td></tr></table></figure></p>
<p>故执行下列两命令,将产生同样的结果.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="_">-f</span> pay1.awk emp.dat</div><div class="line">$ awk <span class="string">'&#123; print $2, $3 * $4 &#125;'</span> emp.dat</div></pre></td></tr></table></figure></p>
<p>读者可使用”<code>-f</code>“参数, 让awk主程序使用“其它仅含 awk 函数的文件中的函数”<br>其语法如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="_">-f</span> awk主程序文件名 <span class="_">-f</span> awk函数文件名 数据文件文件名</div></pre></td></tr></table></figure></p>
<p>(有关 awk 中函数的声明与使用于 7.4 中说明)</p>
<p>awk中也提供与 C 语言中类似用法的 <code>printf()</code> 函数. 使用该函数可进一步控制数据的输出格式.</p>
<p>编辑另一个awk程序如下, 并取名为 <code>pay2.awk</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="built_in">printf</span>(<span class="string">"%6s Work hours: %3d Pay: %5d\n"</span>, <span class="variable">$2</span>,<span class="variable">$3</span>, <span class="variable">$3</span>* <span class="variable">$4</span>) &#125;</div></pre></td></tr></table></figure></p>
<p>执行下列命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="_">-f</span> pay2.awk emp.dat</div></pre></td></tr></table></figure></p>
<p>执行结果屏幕出现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Jenny Work hours: 100 Pay: 21000</div><div class="line">   Dan Work hours: 110 Pay: 23650</div><div class="line">   Max Work hours: 130 Pay: 27170</div><div class="line">  John Work hours: 125 Pay: 27500</div><div class="line"> Linda Work hours:  95 Pay: 19950</div></pre></td></tr></table></figure></p>
<h2 id="选择符合指定条件的记录"><a href="#选择符合指定条件的记录" class="headerlink" title="选择符合指定条件的记录"></a>选择符合指定条件的记录</h2><p><code>Pattern { Action }</code>为awk中最主要的语法. 若某Pattern之值为真则执行它后方的 Action. awk中常使用 “关系表达式”(Relational Expression) 来当成 Pattern.</p>
<p>awk 中除了<code>&gt;, &lt;, ==, !=</code>, … 等关系运算符( Relational Operators )外, 另外提供<code>~</code>(match),<code>!~</code>(Not Match)二个关系运算符. 利用这两个运算符, 可判断某字符串是否包含能匹配所指定正则表达式的子字符串. 由于这些特性, 很容易使用awk来编写需要字符串比对, 判断的程序.</p>
<p>范例: 承上例,<br>组装部门员工调薪5%,(组装部门员工之ID以”A”开头)<br>所有员工最后之薪资率若仍低于100, 则以100计.<br>编写awk程序打印新的员工薪资率报表.</p>
<p>分析: 这个程序须先判断所读入的数据行是否合于指定条件, 再进行某些动作. awk 中<code>Pattern { Actions }</code>的语法已涵盖这种”<code>if ( 条件) { 动作}</code>“的架构. 编写如下之程序, 并取名<code>adjust1.awk</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$1</span> ~ /^A.*/ &#123; <span class="variable">$3</span> *= 1.05 &#125; <span class="variable">$3</span>&lt;100 &#123; <span class="variable">$3</span> = 100 &#125;</div><div class="line">&#123; <span class="built_in">printf</span>(<span class="string">"%s %8s %d\n"</span>, <span class="variable">$1</span>, <span class="variable">$2</span>, <span class="variable">$3</span>)&#125;</div></pre></td></tr></table></figure></p>
<p>执行下列命令 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$awk</span> <span class="_">-f</span> adjust1.awk emp.dat</div></pre></td></tr></table></figure></p>
<p>结果如下 : 屏幕出现 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">A125    Jenny 105</div><div class="line">A341      Dan 115</div><div class="line">P158      Max 130</div><div class="line">P148     John 125</div><div class="line">A123    Linda 100</div></pre></td></tr></table></figure></p>
<p>说明:<br>awk的工作程序是: 从数据文件中每次读入一个数据行, 依序执行完程序中所有的<code>Pattern{ Action }</code>指令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$1</span>~/^A.*/ &#123; <span class="variable">$3</span> *= 1.05 &#125;</div><div class="line"><span class="variable">$3</span> &lt; 100 &#123; <span class="variable">$3</span> = 100 &#125;</div><div class="line">&#123;<span class="built_in">printf</span>(<span class="string">"%s %8s %d\n"</span>,<span class="variable">$1</span>,<span class="variable">$2</span>,<span class="variable">$3</span>)&#125;</div></pre></td></tr></table></figure></p>
<p>再从数据文件中读进下一笔记录继续进行处理.<br>第一个<code>Pattern { Action }</code>是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$1</span> ~ /^A.*/ &#123; <span class="variable">$3</span> *= 1.05 &#125;</div></pre></td></tr></table></figure></p>
<p><code>$1 ~ /^A.*/</code> 是一个Pattern, 用来判断该笔数据行的第一栏是否包含以”A”开头的子字符串. 其中 <code>/^A.*/</code> 是一个Regular Expression, 用以表示任何以”A”开头的字符串. (有关 Regular Expression 之用法 参考 附录 E).<br>Actions 部分为 <code>$3 *= 1.05</code><br><code>$3 *= 1.05</code>与<code>$3 = $3 * 1.05</code> 意义相同. 运算子”<code>*=</code>“之用法则与 C 语言中一样. 此后与 C 语言中用法相同的运算子或语法将不予赘述.</p>
<p>第二个 <code>Pattern { Actions }</code> 是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$3</span> &lt;100 &#123; <span class="variable">$3</span> = 100 &#125;</div></pre></td></tr></table></figure></p>
<p>若第三栏的数据内容(表薪资率)小于100, 则调整为100.</p>
<p>第三个<code>Pattern { Actions }</code>是:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="built_in">printf</span>(<span class="string">"%s %8s %d\n"</span>,<span class="variable">$1</span>, <span class="variable">$2</span>, <span class="variable">$3</span> )&#125;</div></pre></td></tr></table></figure></p>
<p>省略了Pattern(无条件执行Actions), 故所有数据行调整后的数据都将被印出.</p>
<h2 id="awk-中数组"><a href="#awk-中数组" class="headerlink" title="awk 中数组"></a>awk 中数组</h2><p>awk程序中允许使用字符串当做数组的下标(index). 利用这个特色十分有助于资料统计工作.(使用字符串当下标的数组称为Associative Array)</p>
<p>首先建立一个数据文件, 并取名为 <code>reg.dat</code>. 此为一学生注册的资料文件; 第一栏为学生姓名, 其后为该生所修课程.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Mary O.S. Arch. Discrete</div><div class="line">Steve D.S. Algorithm Arch.</div><div class="line">Wang Discrete Graphics O.S.</div><div class="line">Lisa Graphics A.I.</div><div class="line">Lily Discrete Algorithm</div></pre></td></tr></table></figure></p>
<h3 id="awk中数组的特性"><a href="#awk中数组的特性" class="headerlink" title="awk中数组的特性"></a>awk中数组的特性</h3><p>使用字符串当数组的下标(index)，使用数组前不须宣告数组名及其大小.</p>
<p>例如: 希望用数组来记录 <code>reg.dat</code> 中各门课程的修课人数. 这情况,有二项信息必须储存:<br>(a) 课程名称, 如: “O.S.”, “Arch.” … ,共有哪些课程事先并不明确.<br>(b)各课程的修课人数. 如: 有几个人修”O.S.”<br>在awk中只要用一个数组就可同时记录上列信息. 其方法如下:</p>
<h4 id="使用一个数组Number"><a href="#使用一个数组Number" class="headerlink" title="使用一个数组Number[]"></a>使用一个数组Number[]</h4><p>以课程名称当<code>Number[]</code>的下标，以<code>Number[]</code>中不同下标所对映的元素代表修课人数.<br>例如:<br>有2个学生修”O.S.”, 则以<code>Number[&quot;O.S.&quot;] = 2</code>表之.<br>若修”O.S.”的人数增加一人, 则<code>Number[&quot;O.S.&quot;] = Number[&quot;O.S.&quot;] + 1</code> 或 <code>Number[&quot;O.S.&quot;]++</code> .</p>
<h4 id="如何取出数组中储存的信息"><a href="#如何取出数组中储存的信息" class="headerlink" title="如何取出数组中储存的信息"></a>如何取出数组中储存的信息</h4><p>以 C 语言为例, 声明 <code>int Arr[100];</code> 之后, 若想得知 <code>Arr[]</code> 中所储存的数据, 只须用一个循环, 如 :<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, Arr[i]);</div></pre></td></tr></table></figure></p>
<p>即可. 上式中:<br>数组 <code>Arr[]</code> 的下标: <code>0, 1, 2,..., 99</code><br>数组 <code>Arr[]</code> 中各下标所对应的值: <code>Arr[0], Arr[1],...Arr[99]</code><br>但 awk 中使用数组并不须事先宣告. 以刚才使用的 <code>Number[]</code> 而言, 程序执行前, 并不知将来有哪些课程名称可能被当成 <code>Number[]</code> 的下标.</p>
<p>awk 提供了一个指令, 藉由该指令awk会自动找寻数组中使用过的所有下标. 以 <code>Number[]</code> 为例, awk将会找到”O.S.”, “Arch.”, …<br>使用该指令时, 须指定所要找寻的数组, 及一个变量. awk会使用该的变量来记录从数组中找到的每一个下标. 例如<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(course <span class="keyword">in</span> Number)&#123;....&#125;</div></pre></td></tr></table></figure></p>
<p>指定用 <code>course</code> 来记录 awk 从<code>Number[]</code> 中所找到的下标. awk每找到一个下标时, 就用<code>course</code>记录该下标之值且执行<code>{....}</code>中之指令. 藉由这个方式便可取出数组中储存的信息. (详见下例)<br>范例: 统计各科修课人数,并印出结果.<br>建立如下程序,并取名为<code>course.awk</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="keyword">for</span>( i=2; i &lt;= NF; i++) Number[<span class="variable">$i</span>]++ &#125;</div><div class="line">END&#123;<span class="keyword">for</span>(course <span class="keyword">in</span> Number) <span class="built_in">printf</span>(<span class="string">"%10s %d\n"</span>, course, Number[course] )&#125;</div></pre></td></tr></table></figure></p>
<p>执行下列命令 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$awk</span> <span class="_">-f</span> course.awk reg.dat</div></pre></td></tr></table></figure></p>
<p>执行结果如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Graphics 2</div><div class="line">      O.S. 2</div><div class="line">  Discrete 3</div><div class="line">      A.I. 1</div><div class="line">      D.S. 1</div><div class="line">     Arch. 2</div><div class="line"> Algorithm 2</div></pre></td></tr></table></figure></p>
<p>说明:<br>这程序包含二个<code>Pattern { Actions }</code>指令.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="keyword">for</span>( i=2; i &lt;= NF; i++) Number[<span class="variable">$i</span>]++ &#125;</div><div class="line">END&#123;<span class="keyword">for</span>(course <span class="keyword">in</span> Number) <span class="built_in">printf</span>(<span class="string">"%10s %d\n"</span>, course, Number[course] )&#125;</div></pre></td></tr></table></figure></p>
<p>第一个<code>Pattern { Actions }</code>指令中省略了Pattern 部分. 故随着每笔数据行的读入其<code>Actions</code>部分将逐次无条件被执行.<br>以awk读入第一笔资料”Mary O.S. Arch. Discrete”为例, 因为该笔数据<code>NF = 4</code>(有4个字段), 故该 Action 的<code>for Loop</code>中<code>i = 2,3,4</code>.<br><code>i $i</code> 最初 <code>Number[$i] Number[$i]++</code> 之后<br><code>i=2</code>时 <code>$i=&quot;O.S.&quot; Number[&quot;O.S.&quot;]</code> 的值从默认的0,变成了1;<br><code>i=3</code>时 <code>$i=&quot;Arch.&quot; Number[&quot;Arch.&quot;]</code> 的值从默认的0,变成了1;<br>同理,<code>i=4</code>时 <code>$i=&quot;Discrete&quot; Number[&quot;Discrete&quot;]</code> 的值从默认的0,变成了1;</p>
<p>第二个<code>Pattern { Actions }</code>指令中 <code>END</code> 为awk之保留字, 为 Pattern 的一种.<br><code>END</code> 成立(其值为true)的条件是: “awk处理完所有数据, 即将离开程序时.”<br>平常读入数据行时,<code>END</code>并不成立, 故其后的Actions并不被执行;<br>唯有当awk读完所有数据时, 该Actions才会被执行(注意, 不管数据行有多少笔,<code>END</code>仅在最后才成立, 故该Actions仅被执行一次.)</p>
<p><code>BEGIN</code> 与 <code>END</code> 有点类似, 是awk中另一个保留的Pattern.<br>唯一不同的是: “以<code>BEGIN</code>为<code>Pattern</code>的<code>Actions</code>于程序一开始执行时, 被执行一次.”</p>
<p><code>NF</code>为awk的内建变量, 用以表示awk正处理的数据行中, 所包含的字段个数.</p>
<p>awk程序中若含有以<code>$</code>开头的自定变量, 都将以如下方式解释:<br>以<code>i= 2</code>为例, <code>$i = $2</code> 表第二个字段数据. (实际上,<code>$</code> 在 awk 中为一运算符(Operator), 用以取得字段数据.)</p>
<h2 id="awk-程序中使用-Shell-命令"><a href="#awk-程序中使用-Shell-命令" class="headerlink" title="awk 程序中使用 Shell 命令"></a>awk 程序中使用 Shell 命令</h2><p>awk程序中允许呼叫Shell指令. 并提供管道解决awk与系统间数据传递的问题. 所以awk很容易使用系统资源. 读者可利用这个特点来编写某些适用的系统工具.</p>
<p>范例: 写一个awk程序来打印出线上人数.<br>将下列程序建文件, 命名为 <code>count.awk</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line">    <span class="keyword">while</span> ( <span class="string">"who"</span> | getline ) n++</div><div class="line">    <span class="built_in">print</span> n</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>并执行下列命令 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk <span class="_">-f</span> count.awk</div></pre></td></tr></table></figure></p>
<p>执行结果将会印出目前在线人数</p>
<p>说明:<br>awk 程序并不一定要处理数据文件. 以本例而言, 仅输入程序文件<code>count.awk</code>, 未输入任何数据文件.</p>
<p><code>BEGIN</code> 和 <code>END</code> 同为awk中的一种 Pattern. 以 <code>BEGIN</code>为 Pattern 的 Actions, 只有在awk开始执行程序,尚未开启任何输入文件前, 被执行一次.(注意: 只被执行一次)</p>
<p><code>|</code> 为 awk 中表示管道的符号. awk 把<code>|</code>之前的字符串<code>&quot;who&quot;</code>当成Shell上的命令, 并将该命令送往Shell执行, 执行的结果(原先应于屏幕印出者)则藉由pipe送进awk程序中.</p>
<p><code>getline</code>为awk所提供的输入指令. 其语法如下:</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>由何处读取数据</th>
<th>数据读入后置于</th>
</tr>
</thead>
<tbody>
<tr>
<td>getline var <code>&lt;</code> file</td>
<td>所指定的file</td>
<td>变量 <code>var</code>(<code>var</code>省略时,表示置于<code>$0</code>)</td>
</tr>
<tr>
<td>getline var</td>
<td><code>pipe</code> 变量</td>
<td>变量 <code>var</code>(<code>var</code>省略时,表示置于<code>$0</code>)</td>
</tr>
<tr>
<td>getline var</td>
<td>见 注一</td>
<td>变量 var(<code>var</code>省略时,表示置于<code>$0</code>)</td>
</tr>
</tbody>
</table>
<p>注一: 当 Pattern 为 <code>BEGIN</code> 或 <code>END</code>时, <code>getline</code> 将从<code>stdin</code> 读取数据, 否则从awk正处理的数据文件上读取数据.</p>
<p><code>getline</code> 一次读取一行数据, 若读取成功则<code>return 1</code>, 若读取失败则<code>return -1</code>, 若遇到文件结束(<code>EOF</code>), 则<code>return 0</code>;</p>
<p>本程序使用 <code>getline</code> 所 <code>return</code> 的数据来做为 <code>while</code> 判断循环停止的条件, 某些awk版本较旧,并不容许使用者改变 <code>$0</code> 之值. 这种版的 awk 执行本程序时会产生<code>Error</code>, 读者可于 <code>getline</code> 之后置上一个变量 (如此, <code>getline</code> 读进来的数据便不会被置于 <code>$0</code> ), 或直接改用gawk便可解决.</p>
<h2 id="awk-程序的应用实例"><a href="#awk-程序的应用实例" class="headerlink" title="awk 程序的应用实例"></a>awk 程序的应用实例</h2><p>本节将示范一个统计上班到达时间及迟到次数的程序.</p>
<p>这程序每日被执行时将读入二个文件:</p>
<ol>
<li>员工当日到班时间的数据文件 (如下列之<code>arr.dat</code>)</li>
<li>存放员工当月迟到累计次数的文件.</li>
</ol>
<p>当程序执行执完毕后将更新第二个文件的数据(迟到次数), 并打印当日的报表.这程序将分成下列数小节逐步完成, 其大纲如下:</p>
<p>[1] 在到班资料文件 arr.dat 之前增加一行抬头<br>“<code>ID Number Arrvial Time</code>“, 并产生报表输出到文件<code>today_rpt1</code>中.</p>
<p><strong>思考: 在awk中如何将数据输出到文件</strong></p>
<p>[2] 将 <code>today_rpt1</code> 上的数据按员工代号排序, 并加注执行当日日期; 产生文件 <code>today_rpt2</code></p>
<p><strong>思考 awk中如何运用系统资源及awk中Pipe之特性</strong></p>
<p>[3] 将awk程序包含在一个shell script文件中</p>
<p>[4] 于 <code>today_rpt2</code> 每日报表上, 迟到者之前加上”*”, 并加注当日平均到班时间;产生文件 <code>today_rpt3</code></p>
<p>[5] 从文件中读取当月迟到次数, 并根据当日出勤状况更新迟到累计数.</p>
<p><strong>思考 使用者在awk中如何读取文件数据</strong></p>
<p>某公司其员工到勤时间档如下, 取名为 <code>arr.dat</code>. 文件中第一栏为员工代号, 第二栏为到达时间. 本范例中, 将使用该文件为数据文件.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1034 7:26</div><div class="line">1025 7:27</div><div class="line">1101 7:32</div><div class="line">1006 7:45</div><div class="line">1012 7:46</div><div class="line">1028 7:49</div><div class="line">1051 7:51</div><div class="line">1029 7:57</div><div class="line">1042 7:59</div><div class="line">1008 8:01</div><div class="line">1052 8:05</div><div class="line">1005 8:12</div></pre></td></tr></table></figure></p>
<h3 id="重定向输出到文件"><a href="#重定向输出到文件" class="headerlink" title="重定向输出到文件"></a>重定向输出到文件</h3><p>awk中并未提供如 C 语言中之 <code>fopen()</code> 指令, 也未有 <code>fprintf()</code> 文件输出这样的指令. 但awk中任何输出函数之后皆可借助使用与UNIX中类似的 I/O 重定向符, 将输出的数据重定向到指定的文件; 其符号仍为 <code>&gt;</code> (输出到一个新产生的文件) 或 <code>&gt;&gt;</code> (添加输出的数据到文件末尾).</p>
<p>[例:] 在到班数据文件 <code>arr.dat</code> 之前增加一行抬头如下:<br><code>&quot;ID Number Arrival Time&quot;</code>, 并产生报表输出到文件 <code>today_rpt1</code> 中</p>
<p>建立如下文件并取名为reformat1.awk<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123; <span class="built_in">print</span> <span class="string">" ID Number Arrival Time"</span> &gt; <span class="string">"today_rpt1"</span></div><div class="line">    <span class="built_in">print</span> <span class="string">"==========================="</span> &gt; <span class="string">"today_rpt1"</span></div><div class="line">&#125;</div><div class="line">&#123; <span class="built_in">printf</span>(<span class="string">" %s %s\n"</span>, <span class="variable">$1</span>,<span class="variable">$2</span> ) &gt; <span class="string">"today_rpt1"</span> &#125;</div></pre></td></tr></table></figure></p>
<p>执行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$awk</span> <span class="_">-f</span> reformat1.awk arr.dat</div></pre></td></tr></table></figure></p>
<p>执行后将产生文件 today_rpt1, 其内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ID Number Arrival Time</div><div class="line">============================</div><div class="line">1034 7:26</div><div class="line">1025 7:27</div><div class="line">1101 7:32</div><div class="line">1006 7:45</div><div class="line">1012 7:46</div><div class="line">1028 7:49</div><div class="line">1051 7:51</div><div class="line">1029 7:57</div><div class="line">1042 7:59</div><div class="line">1008 8:01</div><div class="line">1052 8:05</div><div class="line">1005 8:12</div></pre></td></tr></table></figure></p>
<p>[说明:]<br>awk程序中, 文件名称 <code>today_rpt1</code> 的前后须以<code>&quot;</code>(双引号)括住, 表示 <code>today_rpt1</code> 为一字符串常量. 若未以<code>&quot;</code>括住, 则 <code>today_rpt1</code> 将被awk解释为一个变量名称.</p>
<p>在awk中任何变量使用之前, 并不须事先声明. 其初始值为空字符串(Null string) 或 0.因此程序中若未以<code>&quot;</code>将 <code>today_rpt1</code> 括住, 则 <code>today_rpt1</code> 将是一变量, 其值将是空字符串, 这会在执行时造成错误(Unix 无法帮您开启一个以空字符串为文件名的文件).</p>
<p>因此在编辑awk程序时, 须格外留心. 因为若敲错变量名称, awk在编译程序时会认为是一新的变量, 并不会察觉. 因此往往会造成运行时错误.</p>
<p><code>BEGIN</code> 为awk的保留字, 是 Pattern 的一种.<br>以 <code>BEGIN</code> 为 Pattern 的 Actions 于awk程序刚被执行尚未读取数据文件时被执行一次, 此后便不再被执行.</p>
<p>读者或许觉得本程序中的I/O重定向符号应使用”<code>&gt;&gt;</code>“(append)而非”<code>&gt;</code>“.</p>
<p>本程序中若使用”<code>&gt;</code>“ 将数据重导到<code>today_rpt1</code>, awk 第一次执行该指令时会产生一个新档<code>today_rpt1</code>, 其后再执行该指令时则把数据追加到<code>today_rpt1</code>文件末, 并非每执行一次就重开一个新文件.</p>
<p>若采用”<code>&gt;&gt;</code>“其差异仅在第一次执行该指令时, 若已存在<code>today_rpt1</code>则 awk 将直接把数据append在原文件之末尾. 这一点, 与UNIX中的用法不同.</p>
<h3 id="awk-中如何利用系统资源"><a href="#awk-中如何利用系统资源" class="headerlink" title="awk 中如何利用系统资源"></a>awk 中如何利用系统资源</h3><p>awk程序中很容易使用系统资源. 这包括在程序中途调用 Shell 命令来处理程序中的部分数据; 或在调用 Shell 命令后将其产生的结果交回 awk 程序(不需将结果暂存于某个文件). 这一过程是借助 awk 所提供的管道 (虽然有些类似 Unix 中的管道, 但特性有些不同),及一个从 awk 中呼叫 Unix 的 Shell 命令的语法来达成的.</p>
<p>[例:] 承上题, 将数据按员工ID排序后再输出到文件 today_rpt2 , 并于表头附加执行时的日期.</p>
<p>[分析:]<br>awk 提供与 UNIX 用法近似的 pipe, 其记号亦为”<code>|</code>“. 其用法及含意如下:<br>awk程序中可接受下列两种语法:<br>[a.语法] awk output 指令 | “Shell 接受的命令”<br>(如: <code>print $1,$2 | &quot;sort -k 1&quot;</code>)<br>[b.语法] “Shell 接受的命令” | awk input 指令<br>(如: <code>&quot;ls&quot; | getline</code>)<br>注: awk input 指令只有 <code>getline</code> 一个.<br>awk output 指令有<code>print</code>, <code>printf()</code> 二个.</p>
<p>在 a 语法中, awk所输出的数据将转送往 Shell , 由 Shell 的命令进行处理.以上例而言, <code>print</code> 所输出的数据将经由 Shell 命令<code>&quot;sort -k 1&quot;</code>排序后再送往屏幕(stdout).</p>
<p>上列awk程序中, “<code>print$1, $2</code>“ 可能反复执行很多次, 其输出的结果将先暂存于 pipe 中,等到该程序结束时, 才会一并进行<code>&quot;sort -k 1&quot;</code>.</p>
<p>须注意二点: 不论<code>print $1, $2</code>被执行几次,<code>&quot;sort -k 1&quot;</code>的执行时间是”awk程序结束时”,<code>&quot;sort -k 1&quot;</code>的执行次数是”一次”.</p>
<p>在 b 语法中, awk将先调用 Shell 命令. 其执行结果将通过 pipe 送入awk程序,以上例而言, awk 先让 Shell 执行 <code>&quot;ls&quot;</code>, Shell 执行后将结果存于 pipe, awk指令<code>getline</code>再从 pipe 中读取数据.</p>
<p>使用本语法时应留心: 以上例而言,awk “立刻”调用 Shell 来执行<code>&quot;ls&quot;</code>, 执行次数是一次.</p>
<p><code>getline</code> 则可能执行多次 (若pipe中存在多行数据).</p>
<p>除上列 a, b 二中语法外, awk程序中其它地方如出现像<code>&quot;date&quot;</code>, <code>&quot;cls&quot;</code>, <code>&quot;ls&quot;</code>… 这样的字符串, awk只把它当成一般字符串处理.</p>
<p>建立如下文件并取名为 <code>reformat2.awk</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 程序 reformat2.awk</span></div><div class="line"><span class="comment"># 这程序用以练习awk中的pipe</span></div><div class="line">BEGIN &#123;</div><div class="line">    <span class="string">"date"</span> | getline <span class="comment"># Shell 执行 "date". getline 取得结果并以$0记录</span></div><div class="line">    <span class="built_in">print</span> <span class="string">" Today is "</span> , <span class="variable">$2</span>, <span class="variable">$3</span> &gt; <span class="string">"today_rpt2"</span></div><div class="line">    <span class="built_in">print</span> <span class="string">"========================="</span> &gt; <span class="string">"today_rpt2"</span></div><div class="line">    <span class="built_in">print</span> <span class="string">" ID Number Arrival Time"</span> &gt; <span class="string">"today_rpt2"</span></div><div class="line">    close( <span class="string">"today_rpt2"</span> )</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;<span class="built_in">printf</span>( <span class="string">"%s %s\n"</span>, <span class="variable">$1</span> ,<span class="variable">$2</span> ) | <span class="string">"sort -k 1 &gt;&gt;today_rpt2"</span>&#125;</div></pre></td></tr></table></figure></p>
<p>执行如下命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk <span class="_">-f</span> reformat2.awk arr.dat</div></pre></td></tr></table></figure></p>
<p>执行后, 系统会自动将 sort 后的数据追加(Append; 因为使用 “<code>&gt;&gt;</code>“) 到文件<code>today_rpt2</code>末端. <code>today_rpt2</code> 内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Today is  09月 21日</div><div class="line">=========================</div><div class="line"> ID Number Arrival Time</div><div class="line">1005 8:12</div><div class="line">1006 7:45</div><div class="line">1008 8:01</div><div class="line">1012 7:46</div><div class="line">1025 7:27</div><div class="line">1028 7:49</div><div class="line">1029 7:57</div><div class="line">1034 7:26</div><div class="line">1042 7:59</div><div class="line">1051 7:51</div><div class="line">1052 8:05</div><div class="line">1101 7:32</div></pre></td></tr></table></figure></p>
<p>[说明:]<br>awk程序由三个主要部分构成:<br>[i.] <code>Pattern { Action}</code>指令<br>[ii.] 函数主体. 例如:<code>function double( x ){ return 2*x }</code> (参考第11节 Recursive Program )<br>[iii.] Comment (以<code>#</code>开头识别之)</p>
<p>awk 的输入指令<code>getline</code>, 每次读取一列数据. 若<code>getline</code>之后未接任何变量, 则所读入之资料将以<code>$0</code>记录, 否则以所指定的变量储存之.</p>
<p>[以本例而言]:<br>执行 <code>&quot;date&quot; | getline</code> 后, <code>$0</code> 之值为 “2007年 09月 21日 星期五 14:28:02 CST”,当 <code>$0</code> 之值被更新时, awk将自动更新相关的内建变量, 如: <code>$1</code>,<code>$2</code>,..,<code>NF</code>.故 <code>$2</code> 之值将为”09月”, <code>$3</code>之值将为”21日”.</p>
<p>(有少数旧版的awk不允许即使用者自行更新(update)<code>$0</code>的值,或者更新<code>$0</code>时,它不会自动更新 <code>$1</code>,<code>$2</code>,..<code>NF</code>. 这情况下, 可改用<code>gawk</code>或<code>nawk</code>. 否则使用者也可自行以awk字符串函数<code>split()</code>来分隔<code>$0</code>上的数据)</p>
<p>本程序中 <code>printf()</code> 指令会被执行12次( 因为有<code>arr.dat</code>中有12行数据), 但读者不用担心数据被重复<code>sort</code>了12次. 当awk结束该程序时才会 <code>close</code> 这个 pipe , 此时才将这12行数据一次送往系统,并呼叫<code>&quot;sort -k 1 &gt;&gt; today_rpt2&quot;</code>处理之.</p>
<p>awk提供另一个调用Shell命令的方法, 即使用awk函数<code>system(&quot;shell command&quot;)</code><br>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ awk &apos;</div><div class="line">BEGIN&#123;</div><div class="line">system(&quot;date &gt; date.dat&quot;)</div><div class="line">getline &lt; &quot;date.dat&quot;</div><div class="line">print &quot;Today is &quot;, $2, $3</div><div class="line">&#125;</div><div class="line">&apos;</div></pre></td></tr></table></figure></p>
<p>但使用<code>system(&quot;shell command&quot;)</code>时, awk无法直接将执行中的部分数据输出给Shell 命令. 且 Shell 命令执行的结果也无法直接输入到awk中.</p>
<h3 id="执行-awk-程序的几种方式"><a href="#执行-awk-程序的几种方式" class="headerlink" title="执行 awk 程序的几种方式"></a>执行 awk 程序的几种方式</h3><p>本小节中描述如何将awk程序直接写在 shell script 之中. 此后使用者执行 awk 程序时, 就不需要每次都键入”<code>awk -f program datafile</code>“.</p>
<p>script 中还可包含其它 Shell 命令, 如此更可增加执行过程的自动化.</p>
<p>建立一个简单的 awk程序 mydump.awk, 如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="built_in">print</span> &#125;</div></pre></td></tr></table></figure></p>
<p>这个程序执行时会把数据文件的内容 <code>print</code> 到屏幕上( 与cat功用类似 ).</p>
<p><code>print</code> 之后未接任何参数时, 表示 “<code>print $0</code>“.</p>
<p>若欲执行该awk程序, 来印出文件 <code>today_rpt1</code> 及 <code>today_rpt2</code> 的内容时, 必须于 UNIX 的命令行上执行下列命令:<br>方式一 <code>awk -f mydump.awk today_rpt1 today_rpt2</code><br>方式二 <code>awk &#39;{ print }&#39; today_rpt1 today_rpt2</code><br>第二种方式系将awk 程序直接写在 Shell 的命令行上, 这种方式仅适合较短的awk程序.<br>方式三 建立如下之 shell script, 并取名为<code>mydisplay</code>,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"></div><div class="line"><span class="comment"># 注意以下的 awk 与 ' 之间须有空白隔开</span></div><div class="line">awk <span class="string">'</span></div><div class="line">&#123;print&#125;</div><div class="line">' $*</div><div class="line"><span class="comment"># 注意以上的 ' 与 $* 之间须有空白隔开</span></div></pre></td></tr></table></figure></p>
<p>执行 <code>mydisplay</code> 之前, 须先将它改成可执行的文件(此步骤往后不再赘述). 请执行如下命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ chmod +x mydisplay</div></pre></td></tr></table></figure></p>
<p>往后使用者就可直接把 <code>mydisplay</code> 当成指令, 来display任何文件.<br>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./mydisplay today_rpt1 today_rpt2</div></pre></td></tr></table></figure></p>
<p>[说明:]<br>在script文件 <code>mydisplay</code> 中, 指令”<code>awk</code>“与第一个<code>&#39;</code> 之间须有空格(Shell中并无” <code>awk&#39;</code> “指令).<br>第一个 <code>&#39;</code> 用以通知 Shell 其后为awk程序.<br>第二个<code>&#39;</code> 则表示 awk 程序结束.<br>故awk程序中一律以<code>&quot;</code>括住字符串或字符, 而不使用<code>&#39;</code>, 以免Shell混淆.<br><code>$*</code> 为 shell script中的用法, 它可用来代表命令行上”<code>mydisplay</code>之后的所有参数”.<br>例如执行 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ mydisplay today_rpt1 today_rpt2</div></pre></td></tr></table></figure></p>
<p>事实上 Shell 已先把该指令转换成:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">&#123; print&#125;</div><div class="line">' today_rpt1 today_rpt2</div></pre></td></tr></table></figure></p>
<p>本例中, <code>$*</code> 用以代表 <code>&quot;today_rpt1 today_rpt2&quot;</code>. 在Shell的语法中, 可用<code>$1</code> 代表第一个参数, <code>$2</code>代表第二个参数. 当不确定命令行上的参数个数时, 可使用 <code>$*</code> 表之.</p>
<p>awk命令行上可同时指定多个数据文件.<br>以<code>awk -f dump.awk today_rpt1 today_rpt2hf</code>为例, awk会先处理<code>today_rpt1</code>, 再处理 <code>today_rpt2</code>. 此时若文件无法打开, 将造成错误.<br>例如: 不存在文件”<code>file_no_exist</code>“, 则执行 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="_">-f</span> dump.awk file_no_exit</div></pre></td></tr></table></figure></p>
<p>将产生运行时错误(无法打开文件).</p>
<p>但某些awk程序 “仅” 包含以 <code>BEGIN</code> 为Pattern的指令. 执行这种awk程序时, awk并不须开启任何数据文件.此时命令行上若指定一个不存在的数据文件,并不会产生 “无法打开文件”的错误.(事实上awk并未打开该文件)<br>例如执行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="string">'BEGIN &#123;print "Hello,World!!"&#125; '</span> file_no_exist</div></pre></td></tr></table></figure></p>
<p>该程序中仅包含以 <code>BEGIN</code> 为 Pattern 的 <code>Pattern {actions}</code>, awk 执行时并不会开启任何数据文件; 所以不会因不存在文件<code>file_no_exit</code>而产生 “无法打开文件”的错误.</p>
<p>awk会将 Shell 命令行上awk程序(或 -f 程序文件名)之后的所有字符串, 视为将输入awk进行处理的数据文件文件名.</p>
<p>若执行awk的命令行上 “未指定任何数据文件文件名”, 则将<code>stdin</code>视为输入之数据来源, 直到输入<code>end of file( Ctrl-D )</code>为止.</p>
<p>读者可以用下列程序自行测试, 执行如下命令 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="_">-f</span> mydump.awk  <span class="comment">#(未接任何数据文件文件名)</span></div></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./mydisplay  <span class="comment">#(未接任何数据文件文件名)</span></div></pre></td></tr></table></figure></p>
<p>将会发现: 此后键入的任何数据将逐行复印一份于屏幕上. 这情况不是机器当机 ! 是因为awk程序正处于执行中. 它正按程序指示, 将读取数据并重新dump一次; 只因执行时未指定数据文件文件名, 故awk 便以stdin(键盘上的输入)为数据来源. 读者可利用这个特点, 设计可与awk即时聊天的程序.</p>
<h3 id="改变-awk-切割字段的方式-amp-自定义函数"><a href="#改变-awk-切割字段的方式-amp-自定义函数" class="headerlink" title="改变 awk 切割字段的方式 &amp; 自定义函数"></a>改变 awk 切割字段的方式 &amp; 自定义函数</h3><p>awk不仅能自动分割字段, 也允许使用者改变其字段切割方式以适应各种格式之需要. 使用者也可自定义函数, 若有需要可将该函数单独写成一个文件,以供其它awk程序调用.</p>
<p>[范例:] 承接 6.2 的例子, 若八点为上班时间, 请加注”<code>*</code>“于迟到记录之前, 并计算平均上班时间.<br>[分析:]<br>因八点整到达者,不为迟到, 故仅以到达的小时数做判断是不够的; 仍应参考到达时的分钟数. 若 “将到达时间转换成以分钟为单位”, 不仅易于判断是否迟到, 同时也易于计算到达平均时间.<br>到达时间(<code>$2</code>)的格式为<code>dd:dd</code>或<code>d:dd</code>; 数字当中含有一个”<code>:</code>“. 但文本数字交杂的数据awk无法直接做数学运算. (注: awk中字符串”<code>26</code>“与数字<code>26</code>, 并无差异, 可直接做字符串或数学运算, 这是awk重要特色之一. 但awk对文本数字交杂的字符串无法正确进行数学运算).</p>
<p>解决之方法:<br>[方法一]<br>对到达时间(<code>$2</code>)<code>d:dd</code>或<code>dd:dd</code>进行字符串运算,分别取出到达的小时数及分钟数.<br>首先判断到达小时数为一位或两位字符,再调用函数分别截取分钟数及小时数.<br>此解法需使用下列awk字符串函数:<br><code>length( 字符串 )</code>:返回该字符串的长度.<br><code>substr( 字符串,起始位置,长度)</code>:返回从起始位置起, 指定长度之子字符串. 若未指定长度, 则返回从起始位置到字符串末尾的子字符串.<br>所以:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">小时数 = substr( $2, 1, length($2) - 3 )</div><div class="line">分钟数 = substr( $2, length($2) - 2 )</div></pre></td></tr></table></figure></p>
<p>[方法二]<br>改变输入列字段的切割方式, 使awk切割字段后分别将小时数及分钟数隔开于二个不同的字段.<br>字段分隔字符<code>FS</code> (field seperator) 是awk的内建变量,其默认值是<code>空白</code>及<code>tab</code>. awk每次切割字段时都会先参考<code>FS</code>的内容. 若把”<code>:</code>“也当成分隔字符, 则awk 便能自动把小时数及分钟数分隔成不同的字段.故令<code>FS = &quot;[ \t:]+&quot;</code> (注: <code>[ \t:]+</code> 为一Regular Expression )<br>Regular Expression 中使用中括号<code>[ ... ]</code>表示一个字符集合,用以表示任意一个位于两中括号间的字符.故可用”<code>[ \t:]</code>“表示 一个<code>空白</code>, <code>tab</code> 或 “<code>:</code>“。<br>Regular Expression中使用”<code>+</code>“形容其前方的字符可出现一次或一次以上.<br>故”<code>[ \t:]+</code>“表示由一个或多个 <code>空白</code>, <code>tab</code> 或 <code>:</code> 所组成的字符串.<br>设定<code>FS =&quot;[ \t:]+&quot;</code>后, 数据行如:<code>&quot;1034 7:26&quot;</code>将被分割成3个字段</p>
<p>第一栏 第二栏 第三栏<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$1</span> <span class="variable">$2</span> <span class="variable">$3</span></div><div class="line">1034 7 26</div></pre></td></tr></table></figure></p>
<p>明显地, awk程序中使用方法二比方法一更简洁方便. 本例子中采用方法二,也借此示范改变字段切割方式的用途.</p>
<p>编写awk程序<code>reformat3</code>, 如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"></div><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    FS= "[ \t:]+" #改变字段切割的方式</div><div class="line">    "date" | getline # Shell 执行 "date". getline 取得结果以$0记录</div><div class="line">    print " Today is " ,$2, $3 &gt; "today_rpt3"</div><div class="line">    print "========================="&gt;"today_rpt3"</div><div class="line">    print " ID Number Arrival Time" &gt; "today_rpt3"</div><div class="line">    close( "today_rpt3" )</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    #已更改字段切割方式, $2表到达小时数, $3表分钟数</div><div class="line">    arrival = HM_to_M($2, $3)</div><div class="line">    printf(" %s %s:%s %s\n", $1, $2, $3, arrival &gt; 480 ? "*": " " ) | "sort -k 1 &gt;&gt; today_rpt3"</div><div class="line">    total += arrival</div><div class="line">&#125;</div><div class="line"></div><div class="line">END &#123;</div><div class="line">    close("today_rpt3")</div><div class="line">    close("sort -k 1 &gt;&gt; today_rpt3")</div><div class="line">    printf(" Average arrival time : %d:%d\n",total/NR/60, (total/NR)%60 ) &gt;&gt; "today_rpt3"</div><div class="line">&#125;</div><div class="line"></div><div class="line">function HM_to_M( hour, min )&#123;</div><div class="line">    return hour*60 + min</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>并执行如下指令 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./reformat3 arr.dat</div></pre></td></tr></table></figure></p>
<p>执行后,文件 today_rpt3 的内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> Today is  09月 21日</div><div class="line">=========================</div><div class="line"> ID Number Arrival Time</div><div class="line"> 1005 8:12 *</div><div class="line"> 1006 7:45</div><div class="line"> 1008 8:01 *</div><div class="line"> 1012 7:46</div><div class="line"> 1025 7:27</div><div class="line"> 1028 7:49</div><div class="line"> 1029 7:57</div><div class="line"> 1034 7:26</div><div class="line"> 1042 7:59</div><div class="line"> 1051 7:51</div><div class="line"> 1052 8:05 *</div><div class="line"> 1101 7:32</div><div class="line"> Average arrival time : 7:49</div></pre></td></tr></table></figure></p>
<p>[说明:]<br>awk 中亦允许使用者自定函数. 函数定义方式请参考本程序, <code>function</code> 为 awk 的保留字.<br><code>HM_to_M()</code>这函数负责将所传入之小时及分钟数转换成以分钟为单位. 使用者自定函数时, 还有许多细节须留心, 如data scope,.. ( 请参考 第十节 Recursive Program)<br>awk中亦提供与 C 语言中相同的 Conditional Operator. 上式<code>printf()</code>中使用<code>arrival &gt;480 ? &quot;*&quot; : &quot; &quot;</code>即为一例若 <code>arrival</code> 大于 <code>480</code> 则<code>return &quot;*&quot;</code>, 否则<code>return &quot; &quot;</code>.<br><code>%</code>为awk的运算符(operator), 其作用与 C 语言中之<code>%</code>相同(取余数).<br><code>NR</code>(Number of Record) 为awk的内建变量. 表示awk执行该程序后所读入的记录笔数.</p>
<p>awk 中提供的<code>close()</code>指令, 语法如下(有二种) :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">close( filename )</div><div class="line">close( 置于pipe之前的<span class="built_in">command</span> )</div></pre></td></tr></table></figure></p>
<p>为何本程序使用了两个<code>close()</code>指令:<br>指令 <code>close(&quot;sort -k 1 &gt;&gt; today_rpt3&quot;)</code>, 其意思为 close 程序中置于<code>&quot;sort -k 1 &gt;&gt; today_rpt3&quot;</code>之前的 Pipe, 并立刻调用 Shell 来执行<code>&quot;sort -k 1 &gt;&gt; today_rpt3&quot;</code>. (若未执行这指令, awk必须于结束该程序时才会进行上述动作; 则这12笔sort后的数据将被 append 到文件 <code>today_rpt3</code> 中 “<code>Average arrival time : ...</code>“ 的后方)<br>因为 Shell 排序后的数据也要写到 <code>today_rpt3</code>, 所以awk必须先关闭使用中的<code>today_rpt3</code> 以使 Shell 正确将排序后的数据追加到<code>today_rpt3</code>否则2个不同的 process 同时打开一个文件进行输出将会产生不可预期的结果.<br>读者应留心上述两点,才可正确控制数据输出到文件中的顺序.<br>指令<code>close(&quot;sort -k 1 &gt;&gt; today_rpt3&quot;)</code>中字符串<code>&quot;sort -k 1 &gt;&gt; today_rpt3&quot;</code> 必须与 pipe <code>|</code> 后方的 Shell Command 名称一字不差, 否则awk将视为二个不同的 pipe.<br>读者可于<code>BEGIN{}</code>中先令变量 <code>Sys_call = &quot;sort -k 1 &gt;&gt; today_rpt3&quot;</code>,<br>程序中再一律以 <code>Sys_call</code> 代替该字符串.</p>
<h3 id="使用-getline-来读取数据"><a href="#使用-getline-来读取数据" class="headerlink" title="使用 getline 来读取数据"></a>使用 getline 来读取数据</h3><p>[范例:] 承上题,从文件中读取当月迟到次数, 并根据当日出勤状况更新迟到累计数.(按不同的月份累计于不同的文件)<br>[分析:]<br>程序中自动抓取系统日期的月份名称, 连接上”<code>late.dat</code>“, 形成累计迟到次数的文件名称(如: 09月late.dat,…), 并以变量<code>late_file</code>记录该文件名.<br>累计迟到次数的文件中的数据格式为: 员工代号(ID) 迟到次数<br>例如, 执行本程序前文件 09月late.dat 的内容为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1012 0</div><div class="line">1006 1</div><div class="line">1052 2</div><div class="line">1034 0</div><div class="line">1005 0</div><div class="line">1029 2</div><div class="line">1042 0</div><div class="line">1051 0</div><div class="line">1008 0</div><div class="line">1101 0</div><div class="line">1025 1</div><div class="line">1028 0</div></pre></td></tr></table></figure></p>
<p>编写程序 reformat4 如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"></div><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    Sys_Sort = "sort -k 1 &gt;&gt; today_rpt4"</div><div class="line">    Result = "today_rpt4"</div><div class="line">    # 改变字段切割的方式</div><div class="line">    FS = "[ \t:]+"</div><div class="line">    # 令 Shell执行"date"; getline 读取结果,并以$0记录</div><div class="line">    "date" | getline</div><div class="line">    print " Today is " , $2, $3 &gt;Result</div><div class="line">    print "=========================" &gt; Result</div><div class="line">    print " ID Number Arrival Time" &gt; Result</div><div class="line">    close( Result )</div><div class="line">    # 从文件按中读取迟到数据, 并用数组cnt[ ]记录. 数组cnt[ ]中以</div><div class="line">    # 员工代号为下标, 所对应的值为该员工之迟到次数.</div><div class="line">    late_file = $2"late.dat"</div><div class="line">    while( getline &lt; late_file &gt;0 ) cnt[$1] = $2</div><div class="line">    close( late_file )</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    # 已更改字段切割方式, $2表小时数,$3表分钟数</div><div class="line">    arrival = HM_to_M($2, $3)</div><div class="line">    if( arrival &gt; 480 )&#123;</div><div class="line">    mark = "*" # 若当天迟到,应再增加其迟到次数, 且令mark 为"*".</div><div class="line">    cnt[$1]++ &#125;</div><div class="line">    else mark = " "</div><div class="line"></div><div class="line">    # message 用以显示该员工的迟到累计数, 若未曾迟到message为空字符串</div><div class="line">    message = cnt[$1] ? cnt[$1] " times" : ""</div><div class="line">    printf("%s %2d:%2d %5s %s\n", $1, $2, $3, mark, message ) | Sys_Sort</div><div class="line">    total += arrival</div><div class="line">&#125;</div><div class="line"></div><div class="line">END &#123;</div><div class="line">    close( Result )</div><div class="line">    close( Sys_Sort )</div><div class="line">    printf(" Average arrival time : %d:%d\n", total/NR/60, (total/NR)%60 ) &gt;&gt; Result</div><div class="line">    #将数组cnt[ ]中新的迟到数据写回文件中</div><div class="line">    for( any in cnt )</div><div class="line">    print any, cnt[any] &gt; late_file</div><div class="line">&#125;</div><div class="line"></div><div class="line">function HM_to_M( hour, min )&#123;</div><div class="line">    return hour*60 + min</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>执行后, today_rpt4 之内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"> Today is  09月 21日</div><div class="line">=========================</div><div class="line"> ID Number Arrival Time</div><div class="line">1005  8:12     * 1 times</div><div class="line">1006  7:45       1 times</div><div class="line">1008  8: 1     * 1 times</div><div class="line">1012  7:46</div><div class="line">1025  7:27       1 times</div><div class="line">1028  7:49</div><div class="line">1029  7:57       2 times</div><div class="line">1034  7:26</div><div class="line">1042  7:59</div><div class="line">1051  7:51</div><div class="line">1052  8: 5     * 3 times</div><div class="line">1101  7:32</div><div class="line"> Average arrival time : 7:49</div></pre></td></tr></table></figure></p>
<p>09月late.dat 文件被修改为如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">1005 1</div><div class="line">1012 0</div><div class="line">1006 1</div><div class="line">1008 1</div><div class="line">1101 0</div><div class="line">1025 1</div><div class="line">1034 0</div><div class="line">1042 0</div><div class="line">1028 0</div><div class="line">1029 2</div><div class="line">1051 0</div><div class="line">1052 3</div></pre></td></tr></table></figure></p>
<p>说明:<br><code>late_file</code>是一变量, 用以记录迟到次数的文件的文件名.<br><code>late_file</code>之值由两部分构成, 前半部是当月月份名称(由调用”date”取得)后半部固定为”late.dat” 如: 09月late.dat.<br>指令<code>getline &lt; late_file</code>表示从<code>late_file</code>所代表的文件中读取一笔记录, 并存放于<code>$0</code>.<br>若使用者可自行把数据放入<code>$0</code>, awk会自动对这新置入 <code>$0</code> 的数据进行字段分割. 之后程序中可用<code>$1</code>, <code>$2</code>,..来表示该笔资料的第一栏,第二栏,..,<br>(注: 有少数awk版本不容许使用者自行将数据置于<code>$0</code>, 遇此情况可改用gawk或nawk)<br>执行<code>getline</code>指令时, 若成功读取记录,它会返回<code>1</code>. 若遇到文件结束, 它返回<code>0</code>; 无法打开文件则返回<code>-1</code>.<br>利用<code>while( getline &lt; filename &gt;0 ) {....}</code>可读入文件中的每一笔数据并予处理. 这是awk中用户自行读取数据文件的一个重要模式.<br>数组 <code>cnt[]</code> 以员工ID. 当下标(index), 其对应值表示其迟到的次数.<br>执行结束后, 利用<code>for(Variable in array ){...}</code>的语法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>( any <span class="keyword">in</span> cnt ) <span class="built_in">print</span> any, cnt[any] &gt; late_file</div></pre></td></tr></table></figure></p>
<p>将更新过的迟到数据重新写回记录迟到次数的文件. 该语法在前面曾有说明.</p>
<h2 id="处理多行的数据"><a href="#处理多行的数据" class="headerlink" title="处理多行的数据"></a>处理多行的数据</h2><p>awk 每次从数据文件中只读取一数据进行处理.<br>awk是依照其内建变量 <code>RS</code> (Record Separator) 的定义将文件中的数据分隔成一行一行的Record. <code>RS</code> 的默认值是”<code>\n</code>“ (换行符号), 故平常awk中一行数据就是一笔 Record. 但有些文件中一笔Record涵盖了多行数据, 这种情况下不能再以”<code>\n</code>“来分隔Records. 最常使用的方法是相邻的Records之间改以一个<code>空白行</code>来隔开. 在awk程序中, 令<code>RS = &quot;&quot;</code>(空字符串)后, awk把会空白行当成来文件中Record的分隔符. 显然awk对<code>RS = &quot;&quot;</code>另有解释方式,简略描述如下, 当<code>RS = &quot;&quot;</code> 时:数个并邻的空白行, awk仅视成一个单一的Record Saparator. (awk不会于两个紧并的空白行之间读取一笔空的Record)<br>awk会略过(skip)文件头或文件尾的空白行. 故不会因为这样的空白行,造成awk多读入了二笔空的数据.</p>
<p>请观察下例,首先建立一个数据文件<code>week.rpt</code>如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">张长弓</div><div class="line">GNUPLOT 入门</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">吴国强</div><div class="line">Latex 简介</div><div class="line">VAST-2 使用手册</div><div class="line">mathematic 入门</div><div class="line"></div><div class="line">李小华</div><div class="line">awk Tutorial Guide</div><div class="line">Regular Expression</div></pre></td></tr></table></figure></p>
<p>该文件的开头有数行空白行, 各笔Record之间使用一个或数个空白行隔开. 读者请细心观察,当<code>RS = &quot;&quot;</code> 时, awk读取该数据文件之方式.</p>
<p>编辑一个awk程序文件 make_report如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"></div><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    FS = "\n"</div><div class="line">    RS = ""</div><div class="line">    split( "一. 二. 三. 四. 五. 六. 七. 八. 九.", C_Number, " " )</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    printf("\n%s 报告人 : %s \n",C_Number[NR],$1)</div><div class="line">    for( i=2; i &lt;= NF; i++) printf(" %d. %s\n", i-1, $i)</div><div class="line">&#125; ' $*</div></pre></td></tr></table></figure></p>
<p>执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ make_report week.rpt</div></pre></td></tr></table></figure></p>
<p>屏幕产生结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">一. 报告人 : 张长弓</div><div class="line"> 1. GNUPLOT 入门</div><div class="line"></div><div class="line">二. 报告人 : 吴国强</div><div class="line"> 1. Latex 简介</div><div class="line"> 2. VAST-2 使用手册</div><div class="line"> 3. mathematic 入门</div><div class="line"></div><div class="line">三. 报告人 : 李小华</div><div class="line"> 1. awk Tutorial Guide</div><div class="line"> 2. Regular Expression</div></pre></td></tr></table></figure></p>
<p>[说明:]<br>本程序同时也改变字段分隔字符(<code>FS = &quot;\n&quot;</code>), 如此一笔数据中的每一行都是一个<code>field</code>. 例如: awk读入的第一笔 Record 为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">张长弓</div><div class="line">GNUPLOT 入门</div></pre></td></tr></table></figure></p>
<p>其中<code>$1</code>指的是”<code>张长弓</code>“, <code>$2</code>指的是”<code>GNUPLOT 入门</code>“<br>上式中的<code>C_Number[]</code>是一个数组(array), 用以记录中文数字. 例如: <code>C_Number[1] = &quot;一.&quot;</code>,<code>C_Number[2] = &quot;二.&quot;</code>这过程使用awk字符串函数 <code>split()</code> 来把中文数字放进数组<code>C_Number[]</code>中.<br>函数<code>split( )</code>用法如下:<br><code>split( 原字符串, 数组名, 分隔字符(field separator) )</code> : awk将依所指定的分隔字符(field separator)分隔原字符串成一个个的字段(field), 并以指定的数组记录各个被分隔的字段</p>
<h2 id="如何读取命令行上的参数"><a href="#如何读取命令行上的参数" class="headerlink" title="如何读取命令行上的参数"></a>如何读取命令行上的参数</h2><p>大部分的应用程序都允许使用者在命令之后增加一些选择性的参数.执行awk时这些参数大部分用于指定数据文件文件名, 有时希望在程序中能从命令行上得到一些其它用途的数据. 本小节中将叙述如何在awk程序中取用这些参数.</p>
<p>建立文件如下, 命名为<code>see_arg</code>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"></div><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    for( i=0; i&lt;ARGC ; i++)</div><div class="line">        print ARGV[i] # 依次印出awk所记录的参数</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>执行如下命令 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./see_arg first-arg second-arg</div></pre></td></tr></table></figure></p>
<p>结果屏幕出现 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">awk</div><div class="line">first-arg</div><div class="line">second-arg</div></pre></td></tr></table></figure></p>
<p>[说明:]<br><code>ARGC</code>,<code>ARGV[]</code> 为awk所提供的内建变量.<br><code>ARGC</code>: 为一整数. 代表命令行上, 除了选项<code>-v</code>,<code>-f</code> 及其对应的参数之外所有参数的数目.<br><code>ARGV[]</code>: 为一字符串数组.<code>ARGV[0]</code>,<code>ARGV[1]</code>,…<code>ARGV[ARGC-1]</code>.<br>分别代表命令行上相对应的参数.<br>例如, 当命令行为 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -vx=36 <span class="_">-f</span> program1 data1 data2</div></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="string">'&#123; print $1 ,$2 &#125;'</span> data1 data2</div></pre></td></tr></table></figure></p>
<p>其<code>ARGC</code> 之值为 3<br><code>ARGV[0]</code> 之值为 “awk”<br><code>ARGV[1]</code>之值为 “data1”<br><code>ARGV[2]</code> 之值为 “data2”  </p>
<p>命令行上的”<code>-f program1</code>“, “<code>-vx=36</code>“, 或程序部分<code>&#39;{ print $1, $2}&#39;</code>都不会列入 <code>ARGC</code> 及 <code>ARGV[]</code>中.<br>awk 利用<code>ARGC</code> 来判断应开启的数据文件个数.<br>但使用者可强行改变<code>ARGC</code>; 当 <code>ARGC</code> 之值被使用者设为 <code>1</code> 时; awk将被蒙骗,误以为命令行上并无数据文件文件名, 故不会以 <code>ARGV[1]</code>,<code>ARGV[2]</code>,..为文件名来打开文件读取数据; 但在程序中仍可通过<code>ARGV[1]</code>,<code>ARGV[2]</code>,..来取得命令行上的数据.</p>
<p>某一程序 test1.awk 如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BEGIN&#123;</div><div class="line">    number = ARGC <span class="comment">#先用number 记住实际的参数个数.</span></div><div class="line">    ARGC = 2 <span class="comment"># 自行更改 ARGC=2, awk将以为只有一个资料文件</span></div><div class="line">    <span class="comment"># 仍可藉由ARGV[ ]取得命令行上的资料.</span></div><div class="line">    <span class="keyword">for</span>( i=2; i&lt;number; i++) data[i] = ARGV[i]</div><div class="line">&#125;</div><div class="line">........</div></pre></td></tr></table></figure></p>
<p>于命令行上键入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk -f test1.awk data_file apple orange</div></pre></td></tr></table></figure></p>
<p>执行时 awk 会打开数据文件 <code>data_file</code> 以进行处理. 但不会打开以<code>apple</code>,<code>orange</code>为档名的文件(因为<code>ARGC</code>被改成<code>2</code>). 但仍可通过<code>ARGV[2]</code>,<code>ARGV[3]</code>取得命令行上的参数 <code>apple</code>,<code>orange</code></p>
<p>也可以用下列命令来达成上例的效果.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$awk</span> <span class="_">-f</span> <span class="built_in">test</span>2.awk -v data[2]=<span class="string">"apple"</span> -v data[3]=<span class="string">"orange"</span> data_file</div></pre></td></tr></table></figure></p>
<h2 id="编写可与用户交互的-awk-程序"><a href="#编写可与用户交互的-awk-程序" class="headerlink" title="编写可与用户交互的 awk 程序"></a>编写可与用户交互的 awk 程序</h2><p>执行awk程序时, awk会自动从文件中读取数据来进行处理, 直到文件结束.只要将awk读取数据的来源改成键盘输入,便可设计与awk 交互的程序了.</p>
<p>本节将提供一个该类程序的范例.<br>[范例:] 本节将编写一个英语生字测验的程序, 它将印出中文字意,再由使用者回答其英语生字.</p>
<p>首先编辑一个数据挡 test.dat (内容不限,格式如下)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">apple 苹果</div><div class="line">orange 柳橙</div><div class="line">banana 香蕉</div><div class="line">pear 梨子</div><div class="line">starfruit 杨桃</div><div class="line">bellfruit 莲雾</div><div class="line">kiwi 奇异果</div><div class="line">pineapple 菠萝</div><div class="line">watermelon 西瓜</div></pre></td></tr></table></figure></p>
<p>编辑awk程序”c2e”如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"></div><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    while( getline &lt; ARGV[1] ) &#123; #由指定的文件中读取测验数据</div><div class="line">        English[++n] = $1 # 最后, n 将表示题目之题数</div><div class="line">        Chinese[n] = $2</div><div class="line">    &#125;</div><div class="line">    ARGV[1] = "-" # "-"表示由stdin(键盘输入)</div><div class="line">    srand() # 以系统时间为随机数启始的种子</div><div class="line">    question() #产生考题</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;# awk自动读入由键盘上输入的数据(使用者回答的答案)</div><div class="line">    if($1 != English[ind] )</div><div class="line">        print "Try again!"</div><div class="line">    else&#123;</div><div class="line">        print "\nYou are right !! Press Enter to Continue --- "</div><div class="line">        getline</div><div class="line">        question()#产生考题</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function question()&#123;</div><div class="line">    ind = int(rand()* n) + 1 #以随机数选取考题</div><div class="line">    system("clear")</div><div class="line">    print " Press \"ctrl-d\" to exit"</div><div class="line">    printf("\n%s ", Chinese[ind] " 的英文生字是: ")</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>执行时键入如下指令 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$./c2e test.dat</div></pre></td></tr></table></figure></p>
<p>屏幕将产生如下的画面:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Press &quot;ctrl-d &quot; to exit</div><div class="line">莲雾 的英文生字是:</div></pre></td></tr></table></figure></p>
<p>若输入 <code>bellfruit</code><br>程序将产生<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">You are right !! Press Enter to Continue ---</div></pre></td></tr></table></figure></p>
<p>[说明:]<br>参数 <code>test.dat</code> (<code>ARGV[1]</code>) 表示储存考题的数据文件文件名. awk 由该文件上取得考题资料后, 将 <code>ARGV[1]</code> 改成”<code>-</code>“.<br>“<code>-</code>“表示由<code>stdin</code>(键盘输入) 数据. 键盘输入数据的结束符号<code>(End of file)</code>是<code>ctrl-d</code>. 当 awk 读到 <code>ctrl-d</code> 时就停止由<code>stdin</code>读取数据.</p>
<p>awk的数学函数中提供两个与随机数有关的函数.<br><code>srand()</code>: 以当前的系统时间作为随机数的种子<br><code>rand()</code>: 返回介于 0与1之间的(近似)随机数值.</p>
<h2 id="使用-awk-编写递归程序"><a href="#使用-awk-编写递归程序" class="headerlink" title="使用 awk 编写递归程序"></a>使用 awk 编写递归程序</h2><p>awk 中除了函数的参数列(Argument List)上的参数(Arguments)外,所有变量不管于何处出现,全被视为全局变量. 其生命持续至程序结束 — 该变量不论在function外或 function内皆可使用,只要变量名称相同所使用的就是同一个变量,直到程序结束.</p>
<p>因递归函数内部的变量, 会因它调用子函数(本身)而重复使用,故编写该类函数时, 应特别留心.</p>
<p>[例如:] 执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    x = 35</div><div class="line">    y = 45</div><div class="line">    test_variable( x )</div><div class="line">    printf("Return to main : arg1= %d, x= %d, y= %d, z= %d\n", arg1, x, y, z)</div><div class="line">&#125;</div><div class="line"></div><div class="line">function test_variable( arg1 )</div><div class="line">&#123;</div><div class="line">    arg1++ # arg1 为参数列上的参数, 是local variable. 离开此函数后将消失.</div><div class="line">    y ++ # 会改变主式中的变量 y</div><div class="line">    z = 55 # z 为该函数中新使用的变量, 主程序中变量 z 仍可被使用.</div><div class="line">    printf("Inside the function: arg1=%d,x=%d, y=%d, z=%d\n", arg1, x, y, z)</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<p>结果屏幕印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Inside the function: arg1=36,x=35, y=46, z=55</div><div class="line">Return to main : arg1= 0, x= 35, y= 46, z= 55</div></pre></td></tr></table></figure></p>
<p>由上可知:<br>函数内可任意使用主程序中的任何变量.函数内所启用的任何变量(除参数外), 于该函数之外依然可以使用.此特性优劣参半, 最大的坏处是式中的变量不易被保护, 特别是递归调用本身, 执行子函数时会破坏父函数内的变量.</p>
<p>一个变通的方法是: 在函数的参数列中虚列一些参数. 函数执行中使用这些虚列的参数来记录不想被破坏的数据,如此执行子函数时就不会破坏到这些数据. 此外 awk 并不会检查调用函数时所传递的参数个数是否一致.</p>
<p>例如，定义递归函数如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> demo( arg1 ) &#123; <span class="comment"># 最常见的错误例子</span></div><div class="line">    ........</div><div class="line">    <span class="keyword">for</span>(i=1; i&lt; 20 ; i++)&#123;</div><div class="line">        demo(x)</div><div class="line">        <span class="comment"># 又呼叫本身. 因为 i 是 global variable, 故执行完该子函数后</span></div><div class="line">        <span class="comment"># 原函数中的 i 已经被坏, 故本函数无法正确执行.</span></div><div class="line">        .......</div><div class="line">    &#125;</div><div class="line">    ..........</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可将上列函数中的<code>i</code>虚列在该函数的参数列上, 如此<code>i</code>便是一个局部变量, 不会因执行子函数而被破坏.</p>
<p>将上列函数修改如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> demo( arg1, i )</div><div class="line">&#123;</div><div class="line">    ......</div><div class="line">    <span class="keyword">for</span>(i=1; i&lt; 20; i++)</div><div class="line">    &#123;</div><div class="line">        demo(x)<span class="comment">#awk不会检查呼叫函数时, 所传递的参数个数是否一致</span></div><div class="line">        .....</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>$0</code>, <code>$1</code>,.., <code>NF</code>, <code>NR</code>,..也都是 global variable, 读者于递归函数中若有使用这些内建变量, 也应另外设立一些局部变量来保存,以免被破坏.</p>
<p>[范例:]以下是一个常见的递归调用范例. 它要求使用者输入一串元素(各元素间用空白隔开) 然后印出这些元素所有可能的排列.</p>
<p>编辑如下的awk式, 取名为 <code>permu</code><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line"></div><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    print "请输入排列的元素,各元素间请用空白隔开"</div><div class="line">    getline</div><div class="line">    permutation($0, "")</div><div class="line">    printf("\n共 %d 种排列方式\n", counter)</div><div class="line">&#125;</div><div class="line"></div><div class="line">function permutation( main_lst, buffer,     new_main_lst, nf, i, j )</div><div class="line">&#123;</div><div class="line">    $0 = main_lst # 把main_lst指定给$0之后awk将自动进行字段分割.</div><div class="line">    nf = NF # 故可用 NF 表示 main_lst 上存在的元素个数.</div><div class="line">    # BASE CASE : 当main_lst只有一个元素时.</div><div class="line">    if( nf == 1)&#123;</div><div class="line">        print buffer main_lst #buffer的内容再加上main_lst就是完成一次排列的结果</div><div class="line">        counter++</div><div class="line">        return</div><div class="line">    &#125;</div><div class="line">    # General Case : 每次从 main_lst 中取出一个元素放到buffer中</div><div class="line">    # 再用 main_lst 中剩下的元素 (new_main_lst) 往下进行排列</div><div class="line">    else for( i=1; i&lt;=nf ;i++)</div><div class="line">    &#123;</div><div class="line">        $0 = main_lst # $0为全局变量已被破坏, 故重新把main_lst赋给$0,令awk再做一次字段分割</div><div class="line">        new_main_lst = ""</div><div class="line">        for(j=1; j&lt;=nf; j++) # 连接 new_main_lst</div><div class="line">            if( j != i ) new_main_lst = new_main_lst " " $j</div><div class="line">        permutation( new_main_lst, buffer " " $i )</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>执行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ./permu</div></pre></td></tr></table></figure></p>
<p>屏幕上出现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">请输入排列的元素,各元素间请用空白隔开</div></pre></td></tr></table></figure></p>
<p>若输入 <code>1 2 3</code> 回车,结果印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> 1 2 3</div><div class="line"> 1 3 2</div><div class="line"> 2 1 3</div><div class="line"> 2 3 1</div><div class="line"> 3 1 2</div><div class="line"> 3 2 1</div><div class="line"></div><div class="line">共 6 种排列方式</div></pre></td></tr></table></figure></p>
<p>[说明:]<br>有些较旧版的awk,并不容许使用者指定<code>$0</code>之值. 此时可改用gawk, 或 nawk.否则也可自行使用<code>split()</code>函数来分割<code>main_lst</code>.<br>为避免执行子函数时破坏<code>new_main_lst, nf, i, j</code>故把这些变量也列于参数列上. 如此,<code>new_main_lst, nf, i, j</code> 将被当成局部变量,而不会受到子函数中同名的变量影响. 读者声明函数时,参数列上不妨将这些 “虚列的参数” 与真正用于传递信息的参数间以较长的空白隔开, 以便于区别.<br>awk 中欲将字符串<code>concatenation</code>(连接)时, 直接将两字符串并置即可(Implicit Operator).</p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN&#123;</div><div class="line">    A = "This "</div><div class="line">    B = "is a "</div><div class="line">    C = A B "key." # 变量A与B之间应留空白,否则"AB"将代表另一新变量.</div><div class="line">    print C</div><div class="line">&#125; '</div></pre></td></tr></table></figure></p>
<p>结果将印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">This is a key.</div></pre></td></tr></table></figure></p>
<p>awk使用者所编写的函数可再重用, 并不需要每个awk式中都重新编写.<br>将函数部分单独编写于一文件中, 当需要用到该函数时再以下列方式include进来.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="_">-f</span> 函数文件名 <span class="_">-f</span> awk主程序文件名 数据文件文件名</div></pre></td></tr></table></figure></p>
<h2 id="附录-A-──-Pattern"><a href="#附录-A-──-Pattern" class="headerlink" title="附录 A ── Pattern"></a>附录 A ── Pattern</h2><p>awk 通过判断 Pattern 之值来决定是否执行其后所对应的Actions.这里列出几种常见的Pattern:</p>
<h3 id="BEGIN"><a href="#BEGIN" class="headerlink" title="BEGIN"></a>BEGIN</h3><p><code>BEGIN</code> 为 awk 的保留字, 是一种特殊的 Pattern.<br><code>BEGIN</code> 成立(其值为true)的时机是: “awk 程序一开始执行, 尚未读取任何数据之前.” 所以在<code>BEGIN { Actions }</code>语法中, 其 Actions 部份仅于程序一开始执行时被执行一次. 当 awk 从数据文件读入数据行后, BEGIN 便不再成立, 故不论有多少数据行, 该 Actions 部份仅被执行一次.</p>
<p>一般常把 “与数据文件内容无关” 与 “只需执行ㄧ次” 的部分置于该Actions(以 <code>BEGIN</code> 为 Pattern)中.</p>
<p>例如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;</div><div class="line">    FS = <span class="string">"[ \t:]"</span> <span class="comment"># 于程序一开始时, 改变awk切割字段的方式</span></div><div class="line">    RS = <span class="string">""</span> <span class="comment"># 于程序一开始时, 改变awk分隔数据行的方式</span></div><div class="line">    count = 100 <span class="comment"># 设定变量 count 的起始值</span></div><div class="line">    <span class="built_in">print</span> <span class="string">" This is a title line "</span> <span class="comment"># 印出一行 title</span></div><div class="line">&#125;</div><div class="line">....... <span class="comment"># 其它 Pattern &#123; Actions &#125; .....</span></div></pre></td></tr></table></figure></p>
<p>有些awk程序甚至”不需要读入任何数据行”. 遇到这情况可把整个程序置于以 <code>BEGIN</code> 为 Pattern 的 Actions 中.</p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123; <span class="built_in">print</span> <span class="string">" Hello ! the Word ! "</span> &#125;</div></pre></td></tr></table></figure></p>
<p>注意: 执行该类仅含<code>BEGIN { Actions }</code>的程序时, awk 并不会开启任何数据文件进行处理.</p>
<h3 id="END"><a href="#END" class="headerlink" title="END"></a>END</h3><p><code>END</code> 为 awk 的保留字, 是另一种特殊的 Pattern.<br><code>END</code> 成立(其值为true)的时机与 <code>BEGIN</code> 恰好相反, 为:”awk 处理完所有数据, 即将离开程序时”平常读入数据行时, END并不成立, 故其对应的 Actions 并不被执行; 唯有当awk读完所有数据时, 该 Actions 才会被执行</p>
<p>注意 : 不管数据行有多少笔, 该 Actions 仅被执行一次.</p>
<h3 id="关系表达式"><a href="#关系表达式" class="headerlink" title="关系表达式"></a>关系表达式</h3><p>使用像 “A 关系运算符 B” 的表达式当成 Pattern.<br>当 A 与 B 存在所指定的关系(Relation)时, 该 Pattern 就算成立(true).</p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">length(<span class="variable">$0</span>) &lt;= 80 &#123; <span class="built_in">print</span> <span class="variable">$0</span> &#125;</div></pre></td></tr></table></figure></p>
<p>上式中<code>length($0)&lt;= 80</code>是一个 Pattern, 当<code>$0</code>(数据行)之长度小于等于80时该 Pattern 之值为true, 将执行其后的 Action (打印该数据行).</p>
<p>awk 中提供下列 关系运算符(Relation Operator)</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>含意</th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
</tr>
<tr>
<td>&gt;=</td>
<td>大于或等于</td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于或等于</td>
</tr>
<tr>
<td>==</td>
<td>等于</td>
</tr>
<tr>
<td>!=</td>
<td>不等于</td>
</tr>
<tr>
<td>~</td>
<td>match</td>
</tr>
<tr>
<td>!~</td>
<td>not match</td>
</tr>
</tbody>
</table>
<p>上列关系运算符除<code>~</code>(match)与<code>!~</code>(not match)外与 C 语言中之含意一致.</p>
<p><code>~</code>(match) 与<code>!~</code>(match) 在 awk 之含意简述如下:<br>若 A 为一字符串, B 为一正则表达式.<br><code>A ~B</code> 判断 字符串A 中是否 包含 能匹配(match)B式样的子字符串.<br><code>A !~B</code> 判断 字符串A 中是否 未包含 能匹配(match)B式样的子字符串.  </p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`<span class="variable">$0</span> ~ /program[0-9]+\.c/ &#123; <span class="built_in">print</span> <span class="variable">$0</span> &#125;`</div></pre></td></tr></table></figure></p>
<p><code>$0 ~ /program[0-9]+\.c/</code> 整个是一个 Pattern, 用来判断<code>$0</code>(数据行)中是否含有可 match <code>/program[0-9]+\.c/</code> 的子字符串, 若<code>$0</code>中含有该类字符串, 则执行 <code>print</code> (打印该行数据).</p>
<p>Pattern 中被用来比对的字符串为 <code>$0</code> 时(如本例), 可仅以正则表达式部分表示整个Pattern.</p>
<p>故本例的 Pattern 部分<code>$0 ~/program[0-9]+\.c/</code>可仅用<code>/program[0-9]+\.c/</code>表之(有关匹配及正则表达式请参考 附录 E )</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>直接使用正则表达式当成 Pattern; 此为 <code>$0 ~ 正则表达式</code> 的简写.<br>该 Pattern 用以判断<code>$0</code>(数据行) 中是否含有匹配该正则表达式的子字符串; 若含有该成立(true) 则执行其对应的 Actions.</p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">`/^[0-9]*$/ &#123; <span class="built_in">print</span> <span class="string">"This line is a integer !"</span> &#125;`</div></pre></td></tr></table></figure></p>
<p>与<code>$0 ~/^[0-9]*$/ { print &quot;This line is a integer !&quot; }</code> 相同</p>
<h3 id="混合-Pattern"><a href="#混合-Pattern" class="headerlink" title="混合 Pattern"></a>混合 Pattern</h3><p>之前所介绍的各种 Patterns, 其计算后结果为一逻辑值(True or False).awk 中逻辑值彼此间可通过<code>&amp;&amp;</code>(and), <code>||</code>(or),  <code>!</code>(not) 结合成一个新的逻辑值.故不同 Patterns 彼此可通过上述结合符号来结合成一个新的 Pattern. 如此可进行复杂的条件判断.</p>
<p>例 如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FNR &gt;= 23 &amp;&amp; FNR &lt;= 28 &#123; <span class="built_in">print</span> <span class="string">"     "</span> <span class="variable">$0</span> &#125;</div></pre></td></tr></table></figure></p>
<p>上式利用<code>&amp;&amp;</code>(and) 将两个 Pattern 求值的结果合并成一个逻辑值.<br>该式将数据文件中 第23行 到 28行 向右移5格(先输出5个空白字符)后输出.<br>(<code>FNR</code>为awk的内建变量, 请参考 附录 D )</p>
<h3 id="Pattern1-Pattern2"><a href="#Pattern1-Pattern2" class="headerlink" title="Pattern1, Pattern2"></a>Pattern1, Pattern2</h3><p>遇到这种 Pattern, awk 会帮您设立一个 switch(或flag).<br>当awk读入的数据行使得 Pattern1 成立时, awk 会打开(turn on)这 switch.<br>当awk读入的数据行使得 Pattern2 成立时, awk 会关上(turn off)这个 switch.  </p>
<p>该 Pattern 成立的条件是:<br>当这个 switch 被打开(turn on)时 (包括 Pattern1, 或 Pattern2 成立的情况)</p>
<p>例 如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FNR &gt;= 23 &amp;&amp; FNR &lt;= 28 &#123; <span class="built_in">print</span> <span class="string">"     "</span> <span class="variable">$0</span> &#125;</div></pre></td></tr></table></figure></p>
<p>可改写为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FNR == 23 , FNR == 28 &#123; <span class="built_in">print</span> <span class="string">"     "</span> <span class="variable">$0</span> &#125;</div></pre></td></tr></table></figure></p>
<p>说明:<br>当 <code>FNR &gt;= 23</code> 时, awk 就 turn on 这个 switch; 因为随着数据行的读入, awk不停的累加<code>FNR</code>. 当<code>FNR = 28</code>时,<code>Pattern2 (FNR == 28)</code> 便成立, 这时 awk 会关上这个 switch.<br>当 switch 打开的期间, awk 会执行 <code>print &quot;     &quot; $0</code><br>( FNR 为awk的内建变量, 请参考 附录 D )</p>
<h2 id="附录-B-──-Actions"><a href="#附录-B-──-Actions" class="headerlink" title="附录 B ── Actions"></a>附录 B ── Actions</h2><p>Actions 是由下列指令(statement)所组成:</p>
<ul>
<li>表达式 (function calls, assignments..)</li>
<li>print 表达式列表</li>
<li>printf(格式化字符串, 表达式列表)</li>
<li>if( 表达式 ) 语句 [else 语句]</li>
<li>while( 表达式 ) 语句</li>
<li>do 语句 while( 表达式 )</li>
<li>for( 表达式; 表达式; 表达式 ) 语句</li>
<li>for( variable in array ) 语句</li>
<li>delete</li>
<li>break</li>
<li>continue</li>
<li>next</li>
<li>exit [表达式]</li>
<li>语句</li>
</ul>
<p>awk 中大部分指令与 C 语言中的用法一致, 此处仅介绍较为常用或容易混淆的指令的用法.</p>
<h3 id="流程控制指令"><a href="#流程控制指令" class="headerlink" title="流程控制指令"></a>流程控制指令</h3><p><strong>if 指令</strong></p>
<p>语法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (表达式) 语句1 [<span class="keyword">else</span> 语句2 ]</div></pre></td></tr></table></figure></p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>( <span class="variable">$1</span> &gt; 25 )</div><div class="line">    <span class="built_in">print</span> <span class="string">"The 1st field is larger than 25"</span></div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="built_in">print</span> <span class="string">"The 1st field is not larger than 25"</span></div></pre></td></tr></table></figure></p>
<p>(a) 与 C 语言中相同, 若 表达式 计算(evaluate)后之值不为 0 或空字符串, 则执行 语句1; 否则执行 语句2.<br>(b) 进行逻辑判断的表达式所返回的值有两种, 若最后的逻辑值为<code>true</code>, 则返回1, 否则返回0.<br>(c) 语法中<code>else 语句2</code>以 [ ] 前后括住表示该部分可视需要而予加入或省略.</p>
<p><strong>while 指令</strong></p>
<p>语法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>( 表达式 ) 语句</div></pre></td></tr></table></figure></p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(match(buffer,/[0-9]+\.c/)) &#123;</div><div class="line">    <span class="built_in">print</span> <span class="string">"Find :"</span> substr( buffer,RSTART, RLENGTH)</div><div class="line">    buff = substr( buffer, RSTART + RLENGTH)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上列范例找出 <code>buffer</code> 中所有能匹配 <code>/[0-9]+.c/</code>(数字之后接上 “<code>.c</code>“的所有子字符串).</p>
<p>范例中 <code>while</code> 以函数 <code>match()</code> 所返回的值做为判断条件. 若 <code>buffer</code> 中还含有匹配指定条件的子字符串(match成功), 则 <code>match()</code> 函数返回<code>1</code>, <code>while</code> 将持续进行其后的语句.</p>
<p><strong>do-while 指令</strong></p>
<p>语法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span> 语句 <span class="keyword">while</span>(表达式)</div></pre></td></tr></table></figure></p>
<p>范例 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">do</span>&#123;</div><div class="line">    <span class="built_in">print</span> <span class="string">"Enter y or n ! "</span></div><div class="line">    getline data</div><div class="line">&#125; <span class="keyword">while</span>( data !~ /^[YyNn]$/)</div></pre></td></tr></table></figure></p>
<p>(a) 上例要求用户从键盘上输入一个字符, 若该字符不是Y, y, N, 或 n则会不停执行该循环, 直到读取正确字符为止.<br>(b) <code>do-while</code> 指令与 <code>while</code> 指令最大的差异是: <code>do-while</code> 指令会先执行<code>statement</code>而后再判断是否应继续执行. 所以, 无论如何其 <code>statement</code> 部分至少会执行一次.</p>
<p><strong>for Statement 指令(一)</strong></p>
<p>语法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(variable <span class="keyword">in</span>  array ) statement</div></pre></td></tr></table></figure></p>
<p>范例: 执行下列命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">    BEGIN&#123;</div><div class="line">        X[1]= 50; X[2]= 60; X["last"]= 70</div><div class="line">        for( any in X )</div><div class="line">            printf("X[%s] = %d\n", any, X[any] )</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<p>结果输出 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">X[last] = 70</div><div class="line">X[1] = 50</div><div class="line">X[2] = 60</div></pre></td></tr></table></figure></p>
<p>(a) 这个 <code>for</code> 指令, 专用以查找数组中所有的下标值, 并依次使用所指定的变量予以记录. 以本例而言, 变量 any 将逐次代表 “last”, 1 及2 .<br>(b) 以这个 <code>for</code> 指令, 所查找出的下标之值彼此间并无任何次续关系.<br>(c) 第5节中有该指令的使用范例, 及解说.</p>
<p><strong>for Statement 指令(二)</strong></p>
<p>语法 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(expression1; expression2; expression3) statement</div></pre></td></tr></table></figure></p>
<p>范例 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(ｉ=1; i&lt; =10; i++)  sum = sum + i</div></pre></td></tr></table></figure></p>
<p>说明:<br>(a) 上列范例用以计算 1 加到 10 的总和.<br>(b) <code>expression1</code> 常用于设定该 for 循环的起始条件, 如上例中的 <code>i=1</code><br><code>expression2</code> 用于设定该循环的停止条件, 如上例中的 <code>i &lt;= 10</code><br><code>expression3</code> 常用于改变 counter 之值, 如上例中的 <code>i++</code></p>
<p><strong>break 指令</strong></p>
<p><code>break</code> 指令用以强迫中断(跳离) <code>for</code>, <code>while</code>, <code>do-while</code> 等循环.</p>
<p>范例 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">while</span>(  getline &lt; <span class="string">"datafile"</span> &gt; 0 )</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>( <span class="variable">$1</span> == 0 )</div><div class="line">        <span class="built_in">break</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="built_in">print</span> <span class="variable">$2</span> / <span class="variable">$1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上例中, awk 不断地从文件 <code>datafile</code> 中读取资料, 当<code>$1</code>等于0时,就停止该执行循环.</p>
<p><strong>continue 指令</strong></p>
<p>循环中的 <code>statement</code> 进行到一半时, 执行 <code>continue</code> 指令来略过循环中尚未执行的<code>statement</code>.</p>
<p>范例 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>( index <span class="keyword">in</span> X_array)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>( index !~ /[0-9]+/ )  <span class="built_in">continue</span></div><div class="line">    <span class="built_in">print</span> <span class="string">"There is a digital index"</span>, index</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上例中若 <code>index</code> 不为数字则执行<code>continue</code>, 故将略过(不执行)其后的指令.</p>
<p>需留心 <code>continue</code> 与 <code>break</code> 的差异 : 执行 <code>continue</code> 只是掠过其后未执行的<code>statement</code>, 但并未跳离开该循环.</p>
<p><strong>next 指令</strong></p>
<p>执行 <code>next</code> 指令时, awk 将掠过位于该指令(next)之后的所有指令(包括其后的所有<code>Pattern { Actions }</code>), 接著读取下一笔数据行,继续从第一个 <code>Pattern {Actions}</code> 执行起.</p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/^[ \t]*$/  &#123;  <span class="built_in">print</span> <span class="string">"This is a blank line! Do nothing here !"</span></div><div class="line">    next</div><div class="line">&#125;</div><div class="line"><span class="variable">$2</span> != 0 &#123; <span class="built_in">print</span> <span class="variable">$1</span>, <span class="variable">$1</span>/<span class="variable">$2</span> &#125;</div></pre></td></tr></table></figure></p>
<p>上例中, 当 awk 读入的数据行为空白行时( match <code>/^[ \]*$/</code> ),除打印消息外只执行<code>next</code>, 故 awk 将略过其后的指令, 继续读取下一笔资料, 从头(第一个 <code>Pattern { Actions }</code>)执行起.</p>
<p><strong>exit 指令</strong></p>
<p>执行 <code>exit</code> 指令时, awk将立刻跳离(停止执行)该awk程序.</p>
<h3 id="awk-中的-I-O-指令"><a href="#awk-中的-I-O-指令" class="headerlink" title="awk 中的 I/O 指令"></a>awk 中的 I/O 指令</h3><p><strong>printf 指令</strong></p>
<p>该指令与 C 语言中的用法相同, 可借由该指令控制资料输出时的格式.</p>
<p>语法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">printf</span>(<span class="string">"format"</span>, item1, item2,.. )</div></pre></td></tr></table></figure></p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">id = <span class="string">"BE-2647"</span>;  ave = 89</div><div class="line"><span class="built_in">printf</span>(<span class="string">"ID# : %s   Ave Score : %d\n"</span>, id, ave)</div></pre></td></tr></table></figure></p>
<p>(a) 结果印出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ID# : BE-2647   Ave Score : 89</div></pre></td></tr></table></figure></p>
<p>(b) <code>format</code> 部分是由 一般的字串(String Constant) 及 格式控制字符(Formatcontrol letter, 其前会加上一个%字符)所构成. 以上式为例”<code>ID# :</code>“ 及 “<code>Ave Score :</code>“为一般字串.<code>%s</code> 及 <code>%d</code> 为格式控制字符.<br>(c) 打印时, 一般字串将被原封不动地打印出来. 遇到格式控制字符时,则依序把<code>format</code>后方之 <code>item</code> 转换成所指定的格式后进行打印.<br>(d) 有关的细节, 读者可从介绍 C 语言的书籍上得到较完整的介绍.</p>
<p>(e) <code>print</code>及<code>printf</code>两个指令, 其后可使用 <code>&gt;</code>或<code>&gt;&gt;</code>将输出到 <code>stdout</code> 的数据重定向到其它文件, 7.1 节中有完整的</p>
<p><strong>print 指令</strong></p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">id = <span class="string">"BE-267"</span>;  ave = 89</div><div class="line"><span class="built_in">print</span> <span class="string">"ID# :"</span>, id, <span class="string">"Ave Score :"</span>ave</div></pre></td></tr></table></figure></p>
<p>(a) 结果印出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ID# : BE-267 Ave Score :89</div></pre></td></tr></table></figure></p>
<p>(b) <code>print</code> 之后可接上字串常数(Constant String)或变量. 它们彼此间可用”,” 隔开.<br>(c) 上式中, 字串 “ID# :” 与变量 id 之间使用”<code>,</code>“隔开, 打印时两者之间会以自动<code>OFS</code>(请参考 附录D 內建变量<code>OFS</code>) 隔开. <code>OFS</code> 之值一般內定为 “一个空格”<br>(d) 上式中, 字串”<code>Ave Score :</code>“与变量<code>ave</code>之间并未以”<code>,</code>“隔开, awk会将这两者先当成字串concate在一起(变成”<code>Ave Score :89</code>“)后,再予打印</p>
<p><strong>getline 指令</strong></p>
<p>语法</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>由何处读取数据</th>
<th>数据读入后置于</th>
</tr>
</thead>
<tbody>
<tr>
<td>getline var <code>&lt;</code> file</td>
<td>所指定的 file</td>
<td>变量 var(var省略时,表示置于<code>$0</code>)</td>
</tr>
<tr>
<td>getline var</td>
<td>pipe 变量</td>
<td>变量 var(var省略时,表示置于<code>$0</code>)</td>
</tr>
<tr>
<td>getline var</td>
<td>见 注一</td>
<td>变量 var(var省略时,表示置于<code>$0</code>)</td>
</tr>
</tbody>
</table>
<p><code>getline</code> 一次读取一行资料, 若读取成功则<code>return 1</code>,若读取失败则<code>return -1</code>, 若遇到文件结束(EOF), 则return 0</p>
<p><strong>close  指令</strong></p>
<p>该指令用以关闭一个打开的文件, 或 pipe (见下例)</p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">BEGIN &#123;  <span class="built_in">print</span> <span class="string">"ID #   Salary"</span> &gt; <span class="string">"data.rpt"</span> &#125;</div><div class="line">&#123;  <span class="built_in">print</span> <span class="variable">$1</span> , <span class="variable">$2</span> * <span class="variable">$3</span>  | <span class="string">"sort -k 1 &gt; data.rpt"</span> &#125;</div><div class="line">END&#123;  close( <span class="string">"data.rpt"</span> )</div><div class="line">    close( <span class="string">"sort -k 1 &gt; data.rpt"</span> )</div><div class="line">    <span class="built_in">print</span> <span class="string">" There are"</span>, NR, <span class="string">"records processed."</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>说明:<br>(a) 上例中, 一开始执行<code>print &quot;ID #   Salary&quot; &gt; &quot;data.rpt&quot;</code>指令来输出一行抬头. 它使用 I/O Redirection (<code>&gt;</code>)将数据转输出到<code>data.rpt</code>, 故此时文件 <code>data.rpt</code> 是处於 Open 状态.<br>(b) 指令<code>print $1, $2 * $3</code> 不停的将输出的资料送往 pipe(<code>|</code>), awk在程序将结束时才会呼叫 shell 使用指令<code>&quot;sort -k 1 &gt; data.rpt&quot;</code> 来处理 pipe 中的数据; 并未立即执行, 这点与 Unix 中pipe的用法不尽相同.<br>(c) 最后希望於文件 <code>data.rpt</code> 的末尾处加上一行 “There are…..”.但此时, Shell尚未执行<code>&quot;sort -k 1 &gt; data.rpt&quot;</code> 故各数据行排序后的 ID 及 Salary 等数据尚未写入<code>data.rpt</code>. 所以得命令 awk 提前先通知 Shell 执行命令<code>&quot;sort -k 1 &gt; data.rpt&quot;</code> 来处理 pipe 中的资料. awk中这个动作称为 close pipe. 是由执行<code>close ( &quot;shell command&quot; )</code>来完成. 需留心 <code>close( )</code>指令中的 shell command 需与”<code>|</code>“后方的 shell command 完全相同(一字不差), 较佳的方法是先以该字串定义一个简短的变量, 程序中再以此变量代替该shell command<br>(d) 为什么执行 <code>close(&quot;data.rpt&quot;)</code> ?  因为 <code>sort</code> 完后的资料也将写到<code>data.rpt</code>,而该文件正为awk所打开使用(write)中, 故awk程式中应先关闭<code>data.rpt</code>. 以免造成因二个 processes 同时打开一个文件进行输出(write)所产生的错误.</p>
<p><strong>system 指令</strong></p>
<p>该指令用以执行Shell上的 command.</p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DataFile = <span class="string">"invent.rpt"</span></div><div class="line">system( <span class="string">"rm "</span> DataFile )</div></pre></td></tr></table></figure></p>
<p>说明:<br>(a) <code>system(&quot;字符串&quot;)</code>指令接受一个字符串当成Shell的命令. 上例中, 使用一个字串常数”<code>rm</code>“ 连接(concate)一个变量 <code>DataFile</code> 形成要求 Shell 执行的命令.Shell 实际执行的命令为 “<code>rm invent.rpt</code>“.</p>
<p><strong>“<code>|</code>“ pipe指令</strong></p>
<p>“<code>|</code>“ 配合 awk 输出指令, 可把 output 到 stdout 的资料继续转送给Shell 上的某一命令当成input的资料.</p>
<p>“<code>|</code>“  配合 awk <code>getline</code> 指令, 可呼叫 Shell 执行某一命令, 再以 awk 的 <code>getline</code> 指令将该命令的所产生的资料读进 awk 程序中.</p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123; <span class="built_in">print</span> <span class="variable">$1</span>, <span class="variable">$2</span> * <span class="variable">$3</span>  | <span class="string">"sort -k 1 &gt; result"</span> &#125;</div><div class="line"><span class="string">"date"</span> |  getline  Date_data</div></pre></td></tr></table></figure></p>
<p>读者请参考7.2 节,其中有完整的范例说明.</p>
<h3 id="awk-释放所占用的记忆体的指令"><a href="#awk-释放所占用的记忆体的指令" class="headerlink" title="awk 释放所占用的记忆体的指令"></a>awk 释放所占用的记忆体的指令</h3><p>awk 程式中常使用数组(Array)来记忆大量数据, <code>delete</code> 指令便是用来释放数组中的元素所占用的内存空间.</p>
<p>范例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>( any <span class="keyword">in</span> X_arr )</div><div class="line">    delete X_arr[any]</div></pre></td></tr></table></figure></p>
<p>读者请留心, <code>delete</code> 指令一次只能释放数组中的一个元素.</p>
<h3 id="awk-中的数学运算符-Arithmetic-Operators"><a href="#awk-中的数学运算符-Arithmetic-Operators" class="headerlink" title="awk 中的数学运算符(Arithmetic Operators)"></a>awk 中的数学运算符(Arithmetic Operators)</h3><p>+(加), -(減), *(乘), /(除), %(求余数), ^(指数) 与 C 语言中用法相同</p>
<h3 id="awk-中的赋值运算符-Assignment-Operators"><a href="#awk-中的赋值运算符-Assignment-Operators" class="headerlink" title="awk 中的赋值运算符(Assignment Operators)"></a>awk 中的赋值运算符(Assignment Operators)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">=, +=, -=, *= , /=, %=, ^=</div></pre></td></tr></table></figure>
<p><code>x += 5</code> 的意思为<code>x = x + 5</code>, 其余类推.</p>
<h3 id="awk-中的条件运算符-Conditional-Operator"><a href="#awk-中的条件运算符-Conditional-Operator" class="headerlink" title="awk 中的条件运算符(Conditional  Operator)"></a>awk 中的条件运算符(Conditional  Operator)</h3><p>语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">判断条件 ? value1 : value2</div></pre></td></tr></table></figure></p>
<p>若 判断条件 成立(true) 则返回 value1, 否则返回 value2.</p>
<h3 id="awk-中的逻辑运算符-Logical-Operators"><a href="#awk-中的逻辑运算符-Logical-Operators" class="headerlink" title="awk 中的逻辑运算符(Logical Operators)"></a>awk 中的逻辑运算符(Logical Operators)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&amp;&amp;( and ), ||(or), !(not)</div></pre></td></tr></table></figure>
<p>Extended Regular Expression 中使用 “<code>|</code>“ 表示 or 请勿混淆.</p>
<h3 id="awk-中的关系运算符-Relational-Operators"><a href="#awk-中的关系运算符-Relational-Operators" class="headerlink" title="awk 中的关系运算符(Relational Operators)"></a>awk 中的关系运算符(Relational Operators)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;, &gt;=, &lt;, &lt; =, ==, !=, ~, !~</div></pre></td></tr></table></figure>
<h3 id="awk-中其它的运算符"><a href="#awk-中其它的运算符" class="headerlink" title="awk 中其它的运算符"></a>awk 中其它的运算符</h3><p>+(正号), -(负号),  ++(Increment Operator), –(Decrement Operator)</p>
<h3 id="awk-中各运算符的运算级"><a href="#awk-中各运算符的运算级" class="headerlink" title="awk 中各运算符的运算级"></a>awk 中各运算符的运算级</h3><p>按优先高低排列:</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>$</code></td>
<td>(栏位运算元, 例如: <code>i=3</code>; <code>$i</code>表示第3栏)</td>
</tr>
<tr>
<td>^</td>
<td>(指数运算)</td>
</tr>
<tr>
<td>+, -, !</td>
<td>(正,负号,及逻辑上的 not)</td>
</tr>
<tr>
<td>*, /, %</td>
<td>(乘,除,余数)</td>
</tr>
<tr>
<td>+, -</td>
<td>(加,減)</td>
</tr>
<tr>
<td>&gt;, &gt;=, <code>&lt;</code>, <code>&lt;=</code>, ==, !=</td>
<td>(关系运算符)</td>
</tr>
<tr>
<td>~, !~</td>
<td>(match, not match)</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>(逻辑上的 and)</td>
</tr>
<tr>
<td>\</td>
<td>\</td>
<td></td>
<td>(逻辑上的 or )</td>
</tr>
<tr>
<td>?:</td>
<td>(条件运算符)</td>
</tr>
<tr>
<td>=, +=, -=, *=, /=, %=, ^=</td>
<td>(赋值运算符)</td>
</tr>
</tbody>
</table>
<h2 id="附录C-──-awk-的內建函数-Built-in-Functions"><a href="#附录C-──-awk-的內建函数-Built-in-Functions" class="headerlink" title="附录C ── awk 的內建函数(Built-in Functions)"></a>附录C ── awk 的內建函数(Built-in Functions)</h2><h3 id="字串函数"><a href="#字串函数" class="headerlink" title="字串函数"></a>字串函数</h3><p><strong>index(原字串, 找寻的子字串)</strong></p>
<p>若原字串中含有欲找寻的子字串,则返回该子字串在原字串中第一次出现的位置,若未曾出现该子字串则返回<code>0</code>.</p>
<p>例如执行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk  <span class="string">'BEGIN&#123; print index("8-12-94","-") &#125;'</span></div></pre></td></tr></table></figure></p>
<p>结果印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2</div></pre></td></tr></table></figure></p>
<p><strong>length(字串): 返回该字串的长度.</strong></p>
<p>例如执行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk  <span class="string">'BEGIN &#123; print length("John") &#125;'</span></div></pre></td></tr></table></figure></p>
<p>结果印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">4</div></pre></td></tr></table></figure></p>
<p><strong>match(原字串, 用以找寻比对的正则表达式)</strong></p>
<p>awk会在原字串中找寻合乎正则表达式的子字串. 若合乎条件的子字串有多个, 则以原字串中最左方的子字串为准.</p>
<p>awk找到该字串后会依此字串为依据进行下列动作:<br>设定awk內建变量<code>RSTART</code>,<code>RLENGTH</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> RSTART =  合条件的子字串在原字串中的位置.</div><div class="line">        =  0 ; 若未找到合条件的子字串.</div><div class="line"></div><div class="line">RLENGTH = 合条件的子字串长度.</div><div class="line">        = -1 ; 若未找到合条件的子字串.</div></pre></td></tr></table></figure></p>
<p>返回 <code>RSTART</code> 之值.</p>
<p>例如执行 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">' BEGIN &#123;</span></div><div class="line">    match( "banana", /(an)+/ )</div><div class="line">    print RSTART, RLENGTH</div><div class="line">&#125; '</div></pre></td></tr></table></figure></p>
<p>执行结果输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">2 4</div></pre></td></tr></table></figure></p>
<p><strong>split(原字串, 数组名称, 分隔字符)</strong></p>
<p>awk将依所指定的分隔字符(field separator)来分隔原字串成一个个的栏位(field),并以指定的数组记录各个被分隔的栏位.</p>
<p>例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ArgLst = &quot;5P12p89&quot;</div><div class="line">split(ArgLst, Arr, /[Pp]/)</div></pre></td></tr></table></figure></p>
<p>执行后: Arr[1]=5,  Arr[2]=12,  Arr[3]=89</p>
<p><strong>sprintf(格式字符串, 项1, 项2, …)</strong></p>
<p>该函数的用法与 awk 或 C 的输出函数<code>printf()</code>相同. 所不同的是<code>sprintf()</code>会将要求印出的结果当成一个字串返回. 一般最常使用<code>sprintf()</code>来改变资料格式. 如: x 为一数值资料, 若欲将其变成一个含二位小数的资料,可执行如下指令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = 28</div><div class="line">x = sprintf(<span class="string">"%.2f"</span>,x)</div></pre></td></tr></table></figure></p>
<p>执行后 <code>x = &quot;28.00&quot;</code></p>
<p><strong>sub(比对用的正则表达式, 将替換的新字串, 原字串)</strong></p>
<p><code>sub()</code>将原字串中第一个(最左边)合乎所指定的正则表达式的子字串改以新字串取代.<br>第二个参数”将替換的新字串”中可用”<code>&amp;&quot;</code>来代表”合於条件的子字串”</p>
<p>承上例,执行下列指令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A = <span class="string">"a6b12anan212.45an6a"</span></div><div class="line">sub( /(an)+[0-9]*/, <span class="string">"[&amp;]"</span>, A)</div><div class="line"><span class="built_in">print</span> A</div></pre></td></tr></table></figure></p>
<p>结果输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ab12[anan212].45an6a</div></pre></td></tr></table></figure></p>
<p><code>sub()</code>不仅可执行替换(replacement)的功用,当第二个参数为空字串(“”)时,<code>sub()</code>所执行的是”去除指定字串”的功用.</p>
<p>通过<code>sub()</code>与<code>match()</code>的搭配使用,可逐次取出原字串中合乎指定条件的所有子字串.</p>
<p>例如执行下列程式:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    data = "p12-P34 P56-p61"</div><div class="line">    while( match( data ,/[0-9]+/) &gt; 0) &#123;</div><div class="line">        print substr(data, RSTART, RLENGTH )</div><div class="line">        sub(/[0-9]+/,"",data)</div><div class="line">    &#125;</div><div class="line">&#125;'</div></pre></td></tr></table></figure></p>
<p>结果输出 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">12</div><div class="line">34</div><div class="line">56</div><div class="line">61</div></pre></td></tr></table></figure></p>
<p><code>sub()</code>中第三个参数(原字串)若未指定,则其预设值为<code>$0</code>.<br>可用 <code>sub(/[9-0]+/,&quot;digital&quot;)</code> 表示<code>sub(/[0-9]+/,&quot;digital&quot;,$0 )</code></p>
<p><strong>gsub(比对用的正则表达式, 将替換的新字串, 原字串)</strong></p>
<p>这个函数与<code>sub()</code>一样,同样是进行字串取代的函数. 唯一不同点是</p>
<ul>
<li>gsub()会取代所有合条件的子字串.</li>
<li>gsub()会返回被取代的子字串个数.</li>
</ul>
<p>请参考<code>sub()</code>.</p>
<p><strong>substr(字串, 起始位置 [,长度])</strong></p>
<p>返回从起始位置起,指定长度的子字串. 若未指定长度,则返回起始位置到字串末尾的子字串.</p>
<p>执行下例<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="string">'BEGIN &#123; print substr("User:Wei-Lin Liu", 6)&#125;'</span></div></pre></td></tr></table></figure></p>
<p>结果印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Wei-Lin Liu</div></pre></td></tr></table></figure></p>
<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p><strong>int(x): 返回x的整数部分(去掉小数).</strong></p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int(7.8) 将返回 7</div><div class="line">int(-7.8) 将返回 -7</div></pre></td></tr></table></figure></p>
<p><strong>sqrt(x): 返回x的平方根.</strong></p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sqrt(9) 将返回 3</div></pre></td></tr></table></figure></p>
<p>若 x 为负数,则执行<code>sqrt(x)</code>时将造成 Run Time Error [译者注: 我这里没有发生错误,返回的是”nan”]</p>
<p><strong>exp(x): 将返回e的x次方.</strong></p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">exp(1) 将返回 2.71828</div></pre></td></tr></table></figure></p>
<p><strong>log(x): 将返回x以e为底的对数值.</strong></p>
<p>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">log</span>(exp(1))  将返回 1</div></pre></td></tr></table></figure></p>
<p>若<code>x&lt; 0</code> ,则执行<code>sqrt(x)</code>时将造成 Run Time Error. [译者注: 我这里也没有发生错误,返回的是”nan”]</p>
<p><strong>sin(x): x 须以弧度为单位, sin(x)将返回x的sin函数值.</strong></p>
<p><strong>cos(x): x 须以弧度为单位, cos(x)将返回x的cos函数值</strong></p>
<p><strong>atan2(y,x): 返回 y/x 的tan反函数之值, 返回值系以弧度为单位.</strong></p>
<p><strong>rand(): 返回介于0与1之间的(近似)随机数值; 0 &lt; rand() &lt;1.</strong></p>
<p>除非使用者自行指定<code>rand()</code>函数起始的种子, 否则每次执行awk程式时, <code>rand()</code>函数都将使用同一个內定的种子,来产生随机数.</p>
<p><strong>srand([x]): 指定以<code>x</code>为<code>rand( )</code>函数起始的种子.</strong></p>
<p>若省略了<code>x</code>,则awk会以执行时的日期与时间为<code>rand()</code>函数起始的种子.</p>
<h2 id="附录D-──-awk-的內建变量-Built-in-Variables"><a href="#附录D-──-awk-的內建变量-Built-in-Variables" class="headerlink" title="附录D ── awk 的內建变量 Built-in Variables"></a>附录D ── awk 的內建变量 Built-in Variables</h2><p>因內建变量的个数不多, 此处按其相关性分类说明, 并未按其字母顺序排列.</p>
<p><strong>ARGC</strong></p>
<p>ARGC表示命令行上除了选项<code>-F</code>, <code>-v</code>, <code>-f</code> 及其所对应的参数之外的所有参数的个数.若将”awk程式”直接写於命令列上, 则 <code>ARGC</code> 亦不将该”程式部分”列入计算.</p>
<p><strong>ARGV</strong></p>
<p>ARGV数组用以记录命令列上的参数.</p>
<p>例: 执行下列命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk  -F\t -v a=8 <span class="_">-f</span> prg.awk  file1.dat file2.dat</div></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk  -F\t -v a=8 <span class="string">'&#123; print $1 * a &#125;'</span> file1.dat file2.dat</div></pre></td></tr></table></figure></p>
<p>执行上列任一程式后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ARGC    =  3</div><div class="line">ARGV[0] = &quot;awk&quot;</div><div class="line">ARGV[1] = &quot;file1.dat&quot;</div><div class="line">ARGV[2] = &quot;file2.dat&quot;</div></pre></td></tr></table></figure></p>
<p>读者请留心: 当 <code>ARGC = 3</code> 时, 命令列上仅指定了 2 个文件.</p>
<p>注:</p>
<p><code>-F\t</code> 表示以 <code>tab</code> 为栏位分隔字符 <code>FS</code>(field seporator).</p>
<p><code>-v a=8</code> 是用以初始化程序中的变量<code>a</code>.</p>
<p><strong>FILENAME</strong></p>
<p>FILENAME用以表示目前正在处理的文件档名.</p>
<p><strong>FS</strong></p>
<p>栏位分隔字符.</p>
<p><strong>$0</strong></p>
<p>表示目前awk所读入的数据行.</p>
<p><strong>$1,$2..</strong></p>
<p>分別表示所读入的数据行之第一栏, 第二栏,..</p>
<p>说明:<br>当awk读入一笔数据行 <code>&quot;A123  8:15&quot;</code> 时,会先以<code>$0</code>记录.<br>故 <code>$0 = &quot;A123  8:15&quot;</code></p>
<p>若程序中进一步使用了<code>$1</code>, <code>$2</code>.. 或 <code>NF</code> 等內建变量时, awk 才会自动分割<code>$0</code>.<br>以便取得栏位相关的资料. 切割后各个栏位的资料会分別以<code>$1</code>, <code>$2</code>, <code>$3</code>…予以记录.</p>
<p>awk內定(default)的 栏位分隔字符(<code>FS</code>) 为 空白字符(空格及tab).</p>
<p>以本例而言, 读者若未改变<code>FS</code>, 则分割后:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">第一栏($1)=&quot;A123&quot;`,  第二栏($2)=&quot;8:15&quot;`.</div></pre></td></tr></table></figure></p>
<p>使用者可用正则表达式自行定义<code>FS</code>. awk每次需要分割数据行时, 会参考目前FS的值.</p>
<p>例如:<br>令<code>FS = &quot;[ :]+&quot;</code> 表示任何由 <code>空白&quot; &quot;</code> 或 <code>冒号&quot;:&quot;</code> 所组成的字串都可当成分隔字符, 则分割后:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">第一栏($1) = &quot;A123&quot;, 第二栏($2) = &quot;8&quot;, 第三栏($3) = &quot;15&quot;</div></pre></td></tr></table></figure></p>
<p><strong>NR</strong></p>
<p>NR 表从 awk 开始执行该程序后所读取的数据行数.</p>
<p><strong>FNR</strong></p>
<p><code>FNR</code> 与 <code>NR</code> 功用类似. 不同的是awk每打开一个新的文件, <code>FNR</code> 便从 0 重新累计</p>
<p><strong>NF</strong></p>
<p>NF表目前的数据行所被切分的栏位数.</p>
<p>awk 每读入一笔资料后, 在程序中可以 <code>NF</code> 来得知该行数据包含的栏位个数.在下一笔资料被读入之前, <code>NF</code> 并不会改变. 但使用者若自行使用<code>$0</code>来记录数据,例如: 使用 <code>getline</code>, 此时 <code>NF</code> 将代表新的 <code>$0</code> 上所记载的资料的栏位个数.</p>
<p><strong>OFS</strong></p>
<p><code>OFS</code>输出时的栏位分隔字符. 预设值 <code>&quot; &quot;(一个空白)</code>, 详见下面说明.</p>
<p><strong>ORS</strong></p>
<p><code>ORS</code>输出时数据行的分隔字符. 预设值 <code>&quot;\n&quot;(跳行)</code>, 见下面说明.</p>
<p><strong>OFMT</strong></p>
<p><code>OFMT</code>数值资料的输出格式. 预设值”<code>%.6g</code>“(若须要时最多印出6位小数)</p>
<p>当使用 <code>print</code> 指令一次印出多项资料时,<br>例如: <code>print $1, $2</code><br>输出时, awk会自动在 <code>$1</code> 与 <code>$2</code> 之间补上一个 <code>OFS</code> 之值  </p>
<p>每次使用 <code>print</code> 输出后, awk 会自动补上 <code>ORS</code> 之值.</p>
<p>使用 <code>print</code> 输出数值数据时, awk 将采用 <code>OFMT</code> 之值为输出格式.<br>例如 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ awk <span class="string">'BEGIN &#123; print 2/3,1; OFS=":"; OFMT="%.2g"; print 2/3,1 &#125;'</span></div></pre></td></tr></table></figure></p>
<p>输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">0.666667 1</div><div class="line">0.67:1</div></pre></td></tr></table></figure></p>
<p>程序中通过改变<code>OFS</code>和<code>OFMT</code>的值, 改变了指令 <code>print</code> 的输出格式.</p>
<p><strong>RS</strong></p>
<p><code>RS</code> (Record Separator): awk从文件上读取资料时, 将根据 <code>RS</code> 的定义把资料切割成许多Records,而awk一次仅读入一个Record,以进行处理.</p>
<p><code>RS</code> 的预设值是 “<code>\n</code>“. 所以一般 awk 一次仅读入一行资料.</p>
<p>有时一个Record含括了几行资料(Multi-line Record). 这情況下不能再以”<code>\n</code>“来分隔相邻的Records, 可改用 <code>空白行</code> 来分隔.<br>在awk程式中,令 <code>RS = &quot;&quot;</code> 表示以 <code>空白行</code> 来分隔相邻的Records.</p>
<p><strong>RSTART</strong></p>
<p><code>RSTART</code>与使用字串函数<code>match()</code>有关的变量,详见下面说明.</p>
<p><strong>RLENGTH</strong></p>
<p><code>RLENGTH</code>与使用字串函数<code>match()</code>有关之变量.</p>
<p>当使用者使用 <code>match(...)</code> 函数后, awk会将 <code>match(...)</code> 执行的结果以<code>RSTART</code>, <code>RLENGTH</code> 记录.<br>请参考 附录 C awk的內建函数 match().</p>
<p><strong>SUBSEP</strong></p>
<p><code>SUBSEP</code>(Subscript Separator)数组下标的分隔字符,<br>预设值为”<code>\034</code>“实际上, awk中的 数组 只接受 <code>字串</code> 当它的下标,如: <code>Arr[&quot;John&quot;]</code>.</p>
<p>但使用者在 awk 中仍可使用 <code>数字</code> 当阵列的下标, 甚至可使用多维的数组<code>(Multi-dimenisional Array)</code>如: <code>Arr[2,79]</code></p>
<p>事实上, awk 在接受<code>Arr[2,79]</code> 之前, 就已先把其下标转换成字串<code>&quot;2\03479&quot;</code>, 之后便以<code>Arr[&quot;2\03479&quot;]</code>代替<code>Arr[2,79]</code>.</p>
<p>可参考下例 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'BEGIN &#123;</span></div><div class="line">    Arr[2,79] = 78</div><div class="line">    print  Arr[2,79]</div><div class="line">    print  Arr[ 2 , 79 ]</div><div class="line">    print  Arr["2\03479"]</div><div class="line">    idx = 2 SUBSEP 79</div><div class="line">    print Arr[idx]</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>执行结果输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">78</div><div class="line">78</div><div class="line">78</div><div class="line">78</div></pre></td></tr></table></figure></p>
<h2 id="附录E-──-正则表达式-Regular-Expression-简介"><a href="#附录E-──-正则表达式-Regular-Expression-简介" class="headerlink" title="附录E ── 正则表达式(Regular Expression) 简介"></a>附录E ── 正则表达式(Regular Expression) 简介</h2><h3 id="为什么要使用正则表达式"><a href="#为什么要使用正则表达式" class="headerlink" title="为什么要使用正则表达式"></a>为什么要使用正则表达式</h3><p>UNIX 中提供了许多 指令 和 tools, 它们具有在文件中 查找(Search)字串或替换(Replace)字串 的功能. 像 grep, vi , sed, awk,…</p>
<p>不论是查找字串或替换字串, 都得先告诉这些指令所要查找(被替换)的字串为何.若未能预先明确知道所要查找(被替换)的字串为何, 只知该字串存在的范围或特征时,例如:<br>(一) 找寻 <code>&quot;T0.c&quot;</code>,<code>&quot;T1.c&quot;</code>,<code>&quot;T2.c&quot;</code>….<code>&quot;T9.c&quot;</code> 当中的任一字串.<br>(二) 找寻至少存在一个 “A” 的任意字串.<br>这情況下, 如何告知执行查找字串的指令所要查找的字串为何.<br>例 (一) 中, 要查找任一在 “<code>T</code>“ 与 “<code>.c</code>“ 之间存在一个阿拉伯数字的字串;当然您可以列举的方式, 一一把所要找寻的字串告诉执行命令的指令. 但例 (二) 中合乎该条件的字串有无限种可能, 势必无法一一列举.此时,便需要另一种字串表示的方法(协定).</p>
<h3 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h3><p>正则表达式(以下简称 Regexp)是一种字串表达的方式. 可用以指定具有某特征的所有字串.<br>注: 为区別于一般字串, 本附录中代表 Regexp 的字串之前皆加 “Regexp”. awk 程式中常以<code>/..../</code>括住 <code>Regexp</code>; 以区別于一般字串.</p>
<h3 id="组成正则表达式的元素"><a href="#组成正则表达式的元素" class="headerlink" title="组成正则表达式的元素"></a>组成正则表达式的元素</h3><p>普通字符 除了<code>. * [ ] + ? ( ) \  ^ $</code>外之所有字符.</p>
<p>由普通字符所组成的Regexp其意义与原字串字面意义相同.<br>例如: Regexp “<code>the</code>“ 与一般字串的 “<code>the</code>“ 代表相同的意义.</p>
<p><code>.</code> (Meta character): 用以代表任意一字符.</p>
<p>须留心 UNIX Shell 中使用”<code>*</code>“表示 Wild card, 可用以代表任意长度的字串.而 Regexp 中使用 “<code>.</code>“ 来代表一个任意字符.(注意: 并非任意长度的字串)Regexp 中 “<code>*</code>“ 另有其它涵意, 并不代表任意长度的字串.</p>
<p><code>^</code> 表示该字串必须出现于行首.</p>
<p><code>$</code> 表示该字串必须出现于行末.</p>
<p>例如:<br>Regexp <code>/^The/</code> 用以表示所有出现于行首的字串 “<code>The</code>“.<br>Regexp <code>/The$/</code> 用以表示所有出现于行末字串 “<code>The</code>“.</p>
<p><code>\</code> 将特殊字符还原成字面意义的字符(Escape character)</p>
<p>Regexp 中特殊字符将被解释成特定的意义. 若要表示特殊字符的字面(literal meaning)意义时,在特殊字符之前加上”<code>\</code>“即可.</p>
<p>例如:<br>使用Regexp来表示字串 “a.out”时, 不可写成 <code>/a.out/</code>.</p>
<p>因为”<code>.</code>“是特殊字符, 表任一字符. 可符合 Regexp <code>/a.out/</code> 的字串将不只 “<code>a.out</code>“ 一个; 字串 “<code>a2out</code>“, “<code>a3out</code>“, “<code>aaout</code>“ …都符合 Regexp <code>/a.out/</code> 正确的用法为: <code>/a\.out/</code></p>
<p><code>[...]</code>字符集合, 用以表示两中括号间所有的字符当中的任一个.</p>
<p>例如:<br>Regexp <code>/[Tt]/</code> 可用以表示字符 “<code>T</code>“ 或 “<code>t</code>“. 故 Regexp <code>/[Tt]he/</code> 表示字串 “<code>The</code>“ 或 “<code>the</code>“.</p>
<p>字符集合 <code>[...]</code> 內不可随意留空白.</p>
<p>例如: Regexp <code>/[ Tt ]/</code> 其中括号內有空白字符, 除表示”<code>T</code>“, “<code>t</code>“ 中任一个字符, 也可代表一个 <code>&quot; &quot;(空白字符)</code></p>
<p><code>-</code> 字符集合中可使用 “<code>-</code>“ 来指定字符的区间, 其用法如下:<br>Regexp <code>/[0-9]/</code> 等价于 <code>/[0123456789]/</code> 用以表示任意一个阿拉伯数字.<br>同理 Regexp <code>/[A-Z]/</code> 用以表示任意一个大写英文字母.</p>
<p>但应留心:<br>Regexp <code>/[0-9a-z]/</code> 并不等于 <code>/[0-9][a-z]/</code>; 前者表示一个字符, 后者表示二个字符.<br>Regexp <code>/[-9]/</code> 或 <code>/[9-]/</code> 只代表字符 “<code>9</code>“或 “<code>-</code>“.</p>
<p><code>[^...]</code> 使用<code>[^..]</code>产生字符集合的补集(complement set).</p>
<p>其用法如下:<br>例如: 要指定 “<code>T</code>“ 或 “<code>t</code>“ 之外的任一个字符, 可用 <code>/[^Tt]/</code> 表之.<br>同理 Regexp <code>/[^a-zA-Z]/</code> 表示英文字母之外的任一个字符.</p>
<p>须留心 “<code>^</code>“ 的位置: “<code>^</code>“ 必须紧接於”<code>[</code>“之后, 才代表字符集合的补集<br>例如:Regexp <code>/[0-9\^]/</code> 只是用以表示一个阿拉伯数字或字符”<code>^</code>“.</p>
<p><code>*</code> 形容字符重复次数的特殊字符.</p>
<p>“<code>*</code>“ 形容它前方之字符可出现 1 次或多次, 或不出现(0次).</p>
<p>例如:<br>Regexp <code>/T[0-9]*\.c/</code> 中 <code>*</code> 形容其前 <code>[0-9]</code> (一个阿拉伯数字)出现的次数可为 0 次或 多次. 故Regexp <code>/T[0-9]*\.c/</code> 可用以表示”<code>T.c</code>“, “<code>T0.c</code>“, “<code>T1.c</code>“…”<code>T19.c</code>“</p>
<p><code>+</code> 形容其前的字符出现一次或一次以上.</p>
<p>例如:<br>Regexp <code>/[0-9]+/</code> 用以表示一位或一位以上的数字.</p>
<p><code>?</code> 形容其前的字符可出现一次或不出现.</p>
<p>例如:<br>Regexp <code>/[+-]?[0-9]+/</code> 表示数字(一位以上)之前可出现正负号或不出现正负号.</p>
<p><code>(...)</code> 用以括住一群字符,且将之视成一个group(见下面说明)</p>
<p>例如:<br>Regexp <code>/12+/</code> 表示字串 “<code>12</code>“, “<code>122</code>“, “<code>1222</code>“, “<code>12222</code>“,…<br>Regexp <code>/(12)+/</code> 表示字串 “<code>12</code>“, “<code>1212</code>“, “<code>121212</code>“, “<code>12121212</code>“….<br>上式中 <code>12</code> 以<code>( )</code>括住, 故 “<code>+</code>“ 所形容的是<code>12</code>, 重复出现的也是<code>12</code>.</p>
<p><code>|</code> 表示逻辑上的”<code>或</code>“(or)</p>
<p>例如:<br>Regexp <code>/Oranges?|apples?|water/</code> 可用以表示:  字串 “<code>Orange</code>“, “<code>Oranges</code>“ 或 “<code>apple</code>“, “<code>apples</code>“  或 “<code>water</code>“</p>
<h3 id="match是什么"><a href="#match是什么" class="headerlink" title="match是什么?"></a>match是什么?</h3><p>讨论 Regexp 时, 经常遇到 “某字串匹配( match )某 Regexp”的字眼. 其意思为: “这个 Regexp 可被解释成该字串”.</p>
<p>[例如]:<br>字串 “<code>the</code>“ 匹配(match) Regexp <code>/[Tt]he/</code>.<br>因为 Regexp <code>/[Tt]he/</code> 可解释成字串 “<code>the</code>“ 或 “<code>The</code>“, 故字串 “<code>the</code>“ 或 “<code>The</code>“ 都匹配(match) Regexp <code>/[Th]he/</code>.</p>
<h3 id="awk-中提供二个关系运算符-Relational-Operator-见注一"><a href="#awk-中提供二个关系运算符-Relational-Operator-见注一" class="headerlink" title="awk 中提供二个关系运算符(Relational Operator,见注一) ~ !~"></a>awk 中提供二个关系运算符(Relational Operator,见注一) <code>~</code> <code>!~</code></h3><p>它们也称之为 match, not match. 但函义与一般常称的 match 略有不同.</p>
<p>其定义如下:<br>A  表一字串, B 表一 Regular Expression<br>只要 A 字串中存在有子字串可 match (一般定义的 match) Regexp  B , 则 <code>A ~ B</code> 就算成立, 其值为 true, 反之则为 false.</p>
<p><code>!~</code> 的定义与<code>~</code>恰好相反.</p>
<p>例如:<br>“<code>another</code>“ 中含有子字串 “<code>the</code>“ 可 match Regexp <code>/[Tt]he/</code> , 所以<br><code>&quot;another&quot; ~ /[Tt]he/</code> 之值为 <code>true</code>.</p>
<p>[注一]: 有些论著不把这两个运算符( <code>~</code>, <code>!~</code>)与 Relational Operators 归为一类.</p>
<h3 id="应用-Regular-Expression-解题的简例"><a href="#应用-Regular-Expression-解题的简例" class="headerlink" title="应用 Regular Expression 解题的简例"></a>应用 Regular Expression 解题的简例</h3><p>下面列出一些应用 Regular Expression 的简例, 部分范例中会更改<code>$0</code>之值, 若您使用的 awk 不允许用户更改<code>$0</code>时, 请改用 gawk.</p>
<p>例1:<br>将文件中所有的字串 “Regular Expression” 或 “Regular expression” 换成 “Regexp”<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">&#123; gsub(/Regular[ \t]+[Ee]xpression/, "Regexp")</div><div class="line">    print</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>例2:<br>去除文件中的空白行(或仅含空白字符或tab的行)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'$0 !~ /^[ \t]*$/ &#123; print &#125;'</span> $*</div></pre></td></tr></table></figure></p>
<p>例3:<br>在文件中具有 <code>ddd-dddd</code> (电话号码型态,<code>d</code>表<code>digital</code>)的字串前加上”<code>TEL:</code>“<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">&#123; gsub(/[0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]/, "TEL: &amp;")</div><div class="line">    print</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>例4:<br>从文件的 Fullname 中分离出 路径 与 档名<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN&#123;</div><div class="line">    Fullname = "/usr/local/bin/xdvi"</div><div class="line">    match(Fullname, /.*\//)</div><div class="line">    path = substr(Fullname, 1, RLENGTH-1)</div><div class="line">    name = substr(Fullname, RLENGTH+1)</div><div class="line">    print "path :", path, "  name :", name</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>结果印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">path : /usr/local/bin   name : xdvi</div></pre></td></tr></table></figure></p>
<p>例5:<br>将某一数值改以现金表示法表示(整数部分每三位加一撇,且含二位小数)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">BEGIN &#123;</div><div class="line">    Number = 123456789</div><div class="line">    Number = sprintf("$%.2f",Number)</div><div class="line">    while(match(Number, /[0-9][0-9][0-9][0-9]/))</div><div class="line">        sub(/[0-9][0-9][0-9][.,]/, ",&amp;", Number)</div><div class="line">    print Number</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
<p>结果输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$123,456,789.00</div></pre></td></tr></table></figure></p>
<p>例6:<br>把文件中所有具”<code>program数字.f</code>“形态的字串改为”<code>[Ref: program数字.c]</code>“<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">awk <span class="string">'</span></div><div class="line">&#123;</div><div class="line">    while(match($0, /program[0-9]+\.f/)) &#123;</div><div class="line">        Replace = "[Ref: "substr($0, RSTART, RLENGTH-2)".c]"</div><div class="line">        sub( /program[0-9]+\.f/, Replace)</div><div class="line">    &#125;</div><div class="line">    print</div><div class="line">&#125;</div><div class="line">' $*</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[sed 函数参数]]></title>
      <url>http://jarsonfang.github.io/etesting/Tools/sed-awk/sed-functions/</url>
      <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">fhc2007@fhc2007-desktop:~$ sed --help</div><div class="line">用法: sed [选项]... &#123;脚本(如果没有其他脚本)&#125; [输入文件]...</div><div class="line"></div><div class="line">  -n, --quiet, --silent</div><div class="line">                 取消自动打印模式空间</div><div class="line">  <span class="_">-e</span> 脚本, --expression=脚本</div><div class="line">                 添加“脚本”到程序的运行列表</div><div class="line">  <span class="_">-f</span> 脚本文件, --file=脚本文件</div><div class="line">                 添加“脚本文件”到程序的运行列表</div><div class="line">  -i[扩展名], --in-place[=扩展名]</div><div class="line">                 直接修改文件(如果指定扩展名就备份文件)</div><div class="line">  <span class="_">-l</span> N, --line-length=N</div><div class="line">                 指定“l”命令的换行期望长度</div><div class="line">  --posix</div><div class="line">                 关闭所有 GNU 扩展</div><div class="line">  -r, --regexp-extended</div><div class="line">                 在脚本中使用扩展正则表达式</div><div class="line">  <span class="_">-s</span>, --separate</div><div class="line">                 将输入文件视为各个独立的文件而不是一个长的连续输入</div><div class="line">  -u, --unbuffered</div><div class="line">                 从输入文件读取最少的数据，更频繁的刷新输出</div><div class="line">      --help     打印帮助并退出</div><div class="line">      --version  输出版本信息并退出</div></pre></td></tr></table></figure>
<p><span style="color:#ff0000">如果没有 -e, –expression, -f 或 –file 选项，那么第一个非选项参数被视为sed脚本。其他非选项参数被视为输入文件，如果没有输入文件，那么程序将从标准输入读取数据。</span></p>
<p><strong>注：-n 参数和 -i 参数不要一起使用。</strong></p>
<p>本章将以一节一个函数参数的方式 ,介绍所有 sed 提供的函数参数 , 其中有</p>
<p>|<a href="#s">s</a>|<a href="#d">d</a>|<a href="#a">a</a>|<a href="#i">i</a>|<a href="#c">c</a>|<a href="#p">p</a>|<a href="#l">l</a>|<a href="#r">r</a>|<a href="#w">w</a>|<a href="#y">y</a>|<a href="#!">!</a>|<a href="#n">n</a>|<a href="#q">q</a>|<a href="#equal">=</a>|<a href="#com">#</a>|<a href="#Next">N</a>|<a href="#Delete">D</a>|<a href="#Print">P</a>|<a href="#h">h</a>|<a href="#Hold">H</a>|<a href="#g">g</a>|<a href="#Gg">G</a>|<a href="#x">x</a>|<a href="#b">b</a>|<a href="#t">t</a>|</p>
<p>另外 , 在各节中 , 首先简单介绍函数参数功能 , 接着说明函数参数与位址参数配合的格式 ,而其中也一并描述 sed 执行此函数参数的工作情形。<br><a id="more"></a></p>
<h3 id="s"><a href="#s" class="headerlink" title="s"></a><a name="s">s</a></h3><p>函数参数 <code>s</code> 表示替换(substitute)文件内字串。其指令格式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]s/pattern/replacemen/[flag]</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>s</code> 最多与两个位址参数配合。</li>
<li>关於 “<code>s/pattern/replacement/[flag]</code>“ 有下面几点说明:</li>
</ol>
<ul>
<li>pattern : 它为 reguler expression 字串。它表示文件中要被替换的字串。</li>
<li><p>replacement : 它为一般字串。但其内出现下列<span style="color:red">元字符</span>有特别意义 :</p>
<ul>
<li><p><code>&amp;</code> : 代表其前 pattern 字串。例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'s/test/&amp; my car/'</span> 资料档名</div></pre></td></tr></table></figure>
<p>指令中 , <code>&amp;</code> 代表 pattern 字串 “<code>test</code>“。故执行後 , 资料档的 “<code>test</code>“ 被替换成 “<code>test my car</code>“。</p>
</li>
<li><p><code>n</code> : 代表 pattern 中被第 <code>n</code> (<code>n</code> 是从 1 到 9 的数字)个 <code>()</code> 所括起来的字串。例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'s/(test) (my) (car)/[2 3 1]/'</span> 资料档名</div></pre></td></tr></table></figure>
<p>指令中 , <code>1</code> 表示 “<code>test</code>“、<code>2</code> 表示 “<code>my</code>“、<code>3</code> 表示 “<code>car</code>“ 字串。故执行後 , 资料档的 “<code>test my car</code>“被替换成 “<code>[my car test]</code>“。（注解：<code>()</code> 与 <code>1 ... 9</code> 合用）</p>
</li>
<li>\ : 可用它来还原一些特殊符号(如上述的 &amp; 和 \ )本身字面上的意义（<span style="color:red">转义</span>） , 或用它来<span style="color:red">代表换行</span>。</li>
</ul>
</li>
<li><p>flag : 主要用它来控制一些替换情况 :</p>
<ul>
<li>当 flag 为 <code>g</code> 时 , 代表替换所有符合(match)的字串 。</li>
<li>当 flag 为十进位数字 <code>m</code> 时 , 代表替换行内第 <code>m</code> 个符合的字串。</li>
<li>当 flag 为 <code>p</code> 时 , 代表替换第一个符合 pattern 的字串後 , 将资料输出标准输出档。</li>
<li>当 flag 为 <code>w wfile</code> 时 , 代表替换第一个符合 pattern 的字串後 , 输出到 <code>wfile</code> 档内(如果 <code>wfile</code> 不存在 , 则会重新开启名为 <code>wfile</code> 的档案)。</li>
<li>当没有 flag 时 , 则将资料行内第一个符合 pattern 的字串以 replacement 字串来替换 。</li>
</ul>
</li>
<li><p>delimiter : 在 “<code>/pattern/replace/[flag]</code>“ 中 “<code>/</code>“ 被当成 delimiter。除了空白(blank)、换行(newline) 之外 ,使用者可用任何字元作为 delimiter。例如下述编辑指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s<span class="comment">#/usr#/usr1#g</span></div></pre></td></tr></table></figure>
<p>上述命令中”<code>#</code>“为 delimiter。如果用 “<code>/</code>“ 做 delimiter , 则 sed 会将 pattern 与 replacement中的 “<code>/</code>“ 当成 delimiter 而发生错误。</p>
</li>
</ul>
<h4 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 替换 <code>input.dat</code> 档(後面如果没有特别指定 , 均假设文件档名为 <code>input.dat</code>)内 “<code>1996</code>“ 字串成 “<code>1997</code>“ , 同时将这些资料行存入 <code>year97.dat</code> 档内。</p>
<p><strong>说明:</strong> 用函数参数 <code>s</code> 指示 sed 将 “<code>1996</code>“ 字串替换成 “<code>1997</code>“ , 另外用 <code>s</code> argument 中的 flag <code>w</code> 指示 sed 将替换过的资料行存入 <code>year97.dat</code> 档内。</p>
<p><strong>sed 命令列:</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'s/1996/1997/w year97.dat'</span> input.dat</div></pre></td></tr></table></figure></p>
<p>数字标志很少使用，在这种情况下，正则表达式在一行上重复匹配，而只需对其中某个位置的匹配进行替换。例如，某输入行也许包含 <code>[tab]</code>（制表符）输入，也许包含多个制表位。假设每行有3个制表符，并且要用“&gt;”替换第二个制表位，则可以使用下面的替换命令来完成该功能：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s/[tab]/&gt;/2</div></pre></td></tr></table></figure></p>
<p>“<code>[tab]</code>“表示一个真正的制表符，而制表符在屏幕上是不可见的。如果输入是一行的文件，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Column1[tab]column2[tab]Column3[tab]Column4</div></pre></td></tr></table></figure></p>
<p>对这个文件运行以上脚本产生的输出如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Column1[tab]column2&gt;Column3[tab]Column4</div></pre></td></tr></table></figure></p>
<p>注意，如果没有数字标志，则替换命令只替换第一个制表符（因此“<code>1</code>”可以被看作是默认的数字标志）。<br>我们可以对前面的示例做一些改动，用换行符取代每行上的第二个制表符。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s/[tab]/</div><div class="line">/2</div></pre></td></tr></table></figure></p>
<p>注意，在反斜杠后面不允许有空格。这个脚本产生下面的结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Column1[tab]column2</div><div class="line">Column3[tab]Column4</div></pre></td></tr></table></figure></p>
<h3 id="d"><a href="#d" class="headerlink" title="d"></a><a name="d">d</a></h3><p>函数参数 d 表示删除资料行 , 其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]d</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明:</p>
<ol>
<li>函数参数 <code>d</code> 最多与两个位址参数配合。</li>
<li><p>sed 执行删除动作情况如下 :</p>
<ol>
<li>将 pattern space 内符合位址参数的资料删除。</li>
<li>将下一笔资料读进 pattern space 。</li>
<li>重新执行 sed script。</li>
</ol>
</li>
</ol>
<p>补遗：删除命令是一个可以改变脚本中的控制流的命令。这是因为一旦执行这个命令，那么在“空的”模式空间（注：不允许在被删除的行上进行进一步操作）中就不会再有命令执行。所以，<span style="color:red">删除命令会导致读取新的输入行，而编辑脚本则从头开始新的一轮</span>。重要的是：如果某行匹配了模式中地址（地址参数），那么就删除整个行，而不只是删除行中匹配的部分（要删除行的一部分，可以使用替换命令并指定一个空的替换）。</p>
<h3 id="a"><a href="#a" class="headerlink" title="a"></a><a name="a">a</a></h3><p>函数参数 <code>a</code> 表示将资料添加到文件中。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1]a 使用者所输入的资料</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明:</p>
<ol>
<li>函数参数 <code>a</code> 最多与一个位址参数配合。</li>
<li>函数参数 <code>a</code> 紧接着 “\“ 字元用来表示此行结束 , 使用者所输入的资料必须从下一行输入。如果资料超过一行 , 则须在每行的结尾加入”<code>\n</code>“。</li>
<li>sed 执行添加动作情况如下: 当 pattern space 内资料输出後 , sed 跟着输出使用者所输入的资料。</li>
</ol>
<h4 id="范例-1"><a href="#范例-1" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 添加 “<code>多工作业系统</code>“ 在含 “<code>UNIX</code>“ 字串的资料行後。假设 input.dat 档的内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UNIX</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 用函数参数 a 将所输入的资料添加在含 “UNIX” 字串的资料行後。</p>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;/UNIX/a\</div><div class="line">多工作业系统</div><div class="line">&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令後, 其输出结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UNIX</div><div class="line">多工作业系统</div></pre></td></tr></table></figure></p>
<p>多行资料输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;/UNIX/a\</div><div class="line">多工\n作业系统</div><div class="line">&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令后，其输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">UNIX</div><div class="line">多工</div><div class="line">作业系统</div></pre></td></tr></table></figure></p>
<p>当然，上述命令也可以在一行中输入：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;/UNIX/a 多工\n作业系统&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>命令结果同上。</p>
<h3 id="i"><a href="#i" class="headerlink" title="i"></a><a name="i">i</a></h3><p>函数参数 <code>i</code> 表示将资料插入文件中。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1]i 使用者所输入的资料</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明:</p>
<ol>
<li>函数参数 <code>i</code> 最多与一个位址参数配合。</li>
<li>函数参数 <code>i</code> 紧接着 “\“ 字元用来表示此行结束, 使用者所输入的资料必须从下一行输入。如果资料超过一行 , 则须在每行的结尾加入”<code>\n</code>“。</li>
<li>sed 执行插入动作的情况如下: 在 pattern space 内资料输出前 , sed 先输出使用者所输入的资料。</li>
</ol>
<h4 id="范例-2"><a href="#范例-2" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 将 “<code>文章版权属於中央研究院</code>“ 插在 <code>input.dat</code> 档中含 “<code>院长: 李远哲</code>“ 的资料行之前。假设 <code>input.dat</code> 档内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">院长: 李远哲</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 用函数参数 <code>i</code> 将资料行 “<code>文章版权属於中央研究院</code>“ 插在含 “<code>院长: 李远哲</code>“ 的资料行之前。</p>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;/院长：李远哲/i\</div><div class="line">文章版权属於中央研究院</div><div class="line">&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令後的输出如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">文章版权属於中央研究院</div><div class="line">院长: 李远哲</div></pre></td></tr></table></figure></p>
<h3 id="c"><a href="#c" class="headerlink" title="c"></a><a name="c">c</a></h3><p>函数参数 <code>c</code> 表示改变文件中的资料。其格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]c 使用者所输入的资料</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明:</p>
<ol>
<li>函数参数 <code>c</code> 最多与两个位址参数配合。</li>
<li>函数参数 <code>c</code> 紧接着 “\“ 字元用来表示此行结束, 使用者所输入的资料必须从下一行输入。如果资料超过一行 , 则须在每行的结尾加入”\n”。</li>
<li>sed 执行改变动作的情况: 在 pattern space 内资料输出时, sed 改变它成为使用者所输入的资料。</li>
</ol>
<p>补遗：更改命令清除模式空间，它在空间模式中与删除命令有同样的效果。脚本中在更改命令之后的其他命令没有被提供。<br>插入命令和追加命令不影响模式空间的内容。提供的文本将不匹配脚本中后续命令中的任何地址，那些命令也不影响该文本。不管什么更改改变了模式空间，所提供的文本仍然会正确输出。当默认的输出受到抑制时也是这样——所提供的文本将被输出，即时模式空间不是那样的。而且，所提供的文本不影响 sed 的内部行计数器。</p>
<h3 id="p"><a href="#p" class="headerlink" title="p"></a><a name="p">p</a></h3><p>函数参数 p 表示印出模式空间中的资料。其指令格式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]p</div></pre></td></tr></table></figure></p>
<p>对於上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>p</code> 最多与两个位址参数配合。</li>
<li>sed 执行印出动作的情况如下: sed 拷备一份 pattern space 内容至标准输出档。</li>
</ol>
<p>除非抑制（<code>-n</code>）默认的输出，否则打印命令将输出行的重复复制。当抑制默认的输出或者当通过程序的流程控制来避免到达脚本的底部时，可能会使用它。</p>
<h3 id="l"><a href="#l" class="headerlink" title="l"></a><a name="l">l</a></h3><p>函数参数 <code>l</code> , 除可将模式空间资料中的 nonprinting character（非打印字符） 显示为两个数字的ASCII 代码（GNU sed 显示某些字符，例如，回车符，使用的是 ANSI C 转义序列，而不是八进制。）外 , 其於均与函数参数 <code>p</code> 相同。例如 , 将下面 input.dat 档中的 <code>^[</code> 以 ASCII 码印出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The Great ^[ is a movie starring Steve McQueen.</div></pre></td></tr></table></figure></p>
<p>（在 vi 中的插入模式下通过键入 CTRL-V（大小写无关），然后按下 ESC 键，产生字符 ^[ ，类似的，按下回车键可产生字符 ^M，按下 CTRL-A（大小写无关），产生字符 ^A，其余类推。）</p>
<p>执行命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;l&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>後, 则输出结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The Great 33 is a movie starring Steve McQueen.</div><div class="line">The Great     is a movie starring Steve McQueen.</div></pre></td></tr></table></figure></p>
<p>上述第二行资料为 sed 的自动输出。</p>
<p>（在 sed 中不能用 ASCII 值匹配字符（也不能匹配八进制数值），所以，使用 sed 替换（或删除）文档中的非打印字符，得用 vi 来编辑 sed 的编辑命令脚本，使用命令脚本来执行 sed 而无法在命令行上输入 sed 的命令参数。）</p>
<h3 id="r"><a href="#r" class="headerlink" title="r"></a><a name="r">r</a></h3><p>函数参数 <code>r</code> 表示读入文件的内容到模式空间。其指令格式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1]r file</div></pre></td></tr></table></figure></p>
<p>对於上述格式有下面几点说明:</p>
<ol>
<li>函数参数 <code>r</code> 最多与一个位址参数配合。</li>
<li>在指令中, 函数参数 <code>r</code> 与文件名称间, 必须有一空格（空格后到换行符前的每个字符都被当做文件名，因此，前导的和嵌入的空格也是文件名的一部分）。</li>
<li>sed 执行读入动作的情况如下: 在 pattern space 内资料输出後, sed 读入由 file 指定的文件的内容跟着输出。当 file 不存在时, sed 照样执行其它指令而不会有任何错误讯息产生。</li>
</ol>
<h3 id="w"><a href="#w" class="headerlink" title="w"></a><a name="w">w</a></h3><p>函数参数 <code>w</code> 表示将模式空间的内容写入文件。其指令格式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]w file</div></pre></td></tr></table></figure></p>
<p>对於上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>w</code> 最多与两个位址参数配合。</li>
<li>在指令中, 函数参数 <code>w</code> 与文件名称间 , 必须有一空格（空格后到换行符前的每个字符都被当做文件名，因此，前导的和嵌入的空格也是文件名的一部分）。</li>
<li>sed 执行写出动作的情况如 : 将 pattern space 内资料写入文件 file。资料写入时 , 会取代(overwrite)原来文件内的资料（如果一个脚本中有多个指令写到同一个文件中，那么每个写命令都将内容追加到这个文件中）。另外, 当文件不存在时, sed 会重新产生(creat)它。</li>
</ol>
<h3 id="y"><a href="#y" class="headerlink" title="y"></a><a name="y">y</a></h3><p>函数参数 <code>y</code> 表示转换资料中的字元。其指令格式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]y /xyz.../abc.../</div></pre></td></tr></table></figure></p>
<p>对於上述格式有下面几点说明 :</p>
<ol>
<li>函数参数最多配合两个位址参数。</li>
<li>指令中, <code>/abc.../xyz.../</code>(x、y、z、a、b、c 代表某些字元) 为 <code>y</code> 的 argument 。其中 <code>abc...</code> 与 <code>xyz...</code> 的字元个数必须相同。</li>
<li>sed 执行转换时, 将 pattern space 内资料内的 <code>a</code> 字元转换成 <code>x</code> 字元 、<code>b</code> 字元转换成 <code>y</code> 字元 、<code>c</code> 字元转换成 <code>z</code> 字元 …。</li>
</ol>
<h4 id="范例-3"><a href="#范例-3" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 将 <code>input.dat</code> 档中的小写字母改成大写。假设 <code>input.dat</code> 档的内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Sodd&apos;s Second Law:</div><div class="line">        Sooner or later, the worst possible set of</div><div class="line">        circumstances is bound to occur.</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 利用函数参数 <code>y</code> 指示 sed 做字母大小的转换。</p>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;</div><div class="line">y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/</div><div class="line">&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令输出结果如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SODD&apos;S SECOND LAW:</div><div class="line">      SOONER OR LATER, THE WORST POSSIBLE SET OF</div><div class="line">      CIRCUMSTANCES IS BOUND TO OCCUR.</div></pre></td></tr></table></figure></p>
<h3 id=""><a href="#" class="headerlink" title="!"></a><a name="!">!</a></h3><p>函数参数 <code>!</code> 表示不执行函数参数。当有如下指令时 ,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]! 函数参数</div></pre></td></tr></table></figure></p>
<p>表示, 对符合位址参数之资料不执行函数参数。例如删除 , 除了含有 “regular” 字串的资料行外，所有资料行, 则执行 <code>!</code> 后的删除命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;/regular/!d&apos; input.dat</div></pre></td></tr></table></figure></p>
<h3 id="n"><a href="#n" class="headerlink" title="n"></a><a name="n">n</a></h3><p>函数参数 <code>n</code> 表示读入下一行资料。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]n</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>n</code> 最多配合两个位址参数。</li>
<li><p>sed 执行读入下一行动作的情况如下 :</p>
<ol>
<li>输出在 pattern space 的资料（默认输出）。</li>
<li>将下一笔资料读到 pattern space。</li>
<li>执行<span style="color:red">下一个</span>编辑指令(不用返回到脚本的顶端)。</li>
</ol>
</li>
</ol>
<p>补遗：<code>next</code> 命令改变了正常的流控制（正常情况下，直到到达脚本的底部才会输出模式空间的内容，总是在读入新行之后从脚本的顶端开始）。实际上，<code>next</code> 命令导致输入的下一行取代模式空间中的当前行。脚本中的后续命令应用于替换后的行，而不是当前行。<span style="color:red">如果没有抑制默认输出，那么在替换发生之前会打印当前行</span>。在较长的脚本中，必须记住<span style="color:red">出现在 next 命令之前的命令不会应用于新的输入行，而出现在其后面的命令不应用于旧的输入行</span>。</p>
<h4 id="范例-4"><a href="#范例-4" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 输出 <code>input.dat</code> 档内偶数行资料。假设 <code>input.dat</code> 档内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">The</div><div class="line">UNIX</div><div class="line">Operation</div><div class="line">System</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 在命令列上</p>
<ul>
<li>以选项 <code>-n</code> , 将资料输出的控制权转给指令。</li>
<li>利用函数参数 <code>n</code> 将下一行资料(偶数行)取代 pattern space 内的资料行(奇数行)。</li>
<li>利用函数参数 <code>p</code> 将 pattern space 内的资料(偶数行)输出。<br>最後 , 整个输出只有原先档内的偶数行资料。</li>
</ul>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n -e &apos;n&apos; -e &apos;p&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令後, 输出的结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">UNIX</div><div class="line">System</div></pre></td></tr></table></figure></p>
<h3 id="q"><a href="#q" class="headerlink" title="q"></a><a name="q">q</a></h3><p>函数参数 <code>q</code> 表示跳离 sed 。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1]q</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>q</code> 最多配合一个位址参数。</li>
<li>sed 执行跳离动作时 , 它停止读取新的输入行（并停止将它们发送到输出）。</li>
</ol>
<p>（退出命令 <code>q</code> 只适用于单行的地址。一旦找到和 address 匹配的行，那么脚本就结束。注：需要小心的是，在将编辑操作写回到原始文件的任何程序中不要使用 <code>q</code> 命令。在执行 <code>q</code> 命令之后，就不会再产生输出。在想要编辑文件的一部分并保留剩余部分不改变的情况下，不要使用 <code>q</code> 命令。这种情况下使用 <code>q</code> 时初学者常犯的非常危险的错误。）</p>
<p>示例，下面一行命令使用退出命令从文件中打印前100行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sed &apos;100q&apos; test</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>它打印每一行，直到它到达行100并且退出。在这点上，这个命令的功能与 UNIX 的 <code>head</code> 命令类似。<br><code>quit</code> 的另一个可能的用法是从文件中提取了想要的内容后退出脚本。</p>
<h4 id="范例-5"><a href="#范例-5" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong>  对文件档执行 <code>script_file</code> 内的编辑指令 , 除非遇到 “<code>Linux</code>“ 字串。</p>
<p><strong>说明:</strong>  无论 <code>script_file</code> 内是何种指令 , 使用者只要在命令列上用指令<code>/Linux/q</code> , 函数参数 <code>q</code> 会强迫 sed 遇到 “<code>Linux</code>“ 时做跳离动作。</p>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;/Linux/q&apos; -f script_file input.dat</div></pre></td></tr></table></figure></p>
<h3 id="-1"><a href="#-1" class="headerlink" title="="></a><a name="equal">=</a></h3><p>函数参数 <code>=</code> 表示印出资料的行号。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]=</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>=</code> 最多配合两个位址参数。</li>
<li>执行时, 行号将在资料输出前先输出。</li>
</ol>
<h4 id="范例-6"><a href="#范例-6" class="headerlink" title="范例:"></a>范例:</h4><p><strong>题目:</strong> 印出 <code>input.dat</code> 档内资料行数。假设 <code>input.dat</code> 的内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The UNIX</div><div class="line">Operating System</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 用函数参数 <code>=</code> 来印出资料的行数。</p>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;=&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令後 , 输出的结果如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">The UNIX</div><div class="line">2</div><div class="line">Operating System</div></pre></td></tr></table></figure></p>
<h3 id="-2"><a href="#-2" class="headerlink" title="#"></a><a name="com">#</a></h3><p><span style="color:red">在 script file 内 , 函数参数 <code>#</code> 後的文字为注解。当注解文字超过多行时 , 其行间须以 “\n” 换行字元相隔</span>。在 sed 的System V版本中，注释只允许出现在第一行。而 GNU sed 则可以在脚本的任何地方放置注释，甚至是跟在命令行的后面。注释行的第一个字符必须是“#”号。<span style="color:red">如果跟在<code>#</code>后面的下一个字符是<code>n</code>，那么脚本不会自动产生输出。这和指定命令行选项 <code>-n</code> 是等价的。跟在 <code>n</code> 后面的其余内容被看做是注释。在POSIX标准中，采用这种方式的 <code>#n</code> 必须是文件的前两个字符</span>。</p>
<p>到此为止，前面介绍的命令（函数参数）可归类为基本的 sed 命令，下面将要介绍的这些命令可归类为 sed 的高级命令。sed 的高级命令可分成3个组：</p>
<ol>
<li>处理多行模式空间（<code>N</code>、<code>D</code>、<code>P</code>）。</li>
<li>采用保持空间来保存模式空间的内容并使它可用于后续的命令（<code>H</code>、<code>h</code>、<code>G</code>、<code>g</code>、<code>x</code>）。</li>
<li>编写使用分支和条件指令的脚本来更改控制流（<code>:</code>、<code>b</code>、<code>t</code>）。</li>
</ol>
<h3 id="多行模式空间"><a href="#多行模式空间" class="headerlink" title="多行模式空间"></a>多行模式空间</h3><p>在前面的正则表达式讨论中，我们强调模式匹配是面向行的。像 grep 这样的程序尝试在单个输入行上匹配一个模式。这就使它很难匹配一个在一行的结尾处开始，并在下一行的开始处结束的短语。其他一些模式只有当在多行上匹配才有意义。<br>sed 能查看模式空间的多个行。这就允许匹配模式扩展到多行上。下面我们将要介绍创建多行模式空间并处理它的内容的命令。这里的 3 个多行命令（<code>N</code>、<code>D</code>、<code>P</code>）对应于前面介绍的小写字母的基本命令（<code>n</code>、<code>d</code>、<code>p</code>）。</p>
<h3 id="N"><a href="#N" class="headerlink" title="N"></a><a name="Next">N</a></h3><p>函数参数 <code>N</code> 表示添加下一笔资料在 pattern space 内。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]N</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>N</code> 最多配合两个位址参数。</li>
<li>sed 执行时, 将下一行资料读入并添加在 pattern space 内, 资料行间以换行字元(embedded newline character)分隔。此外 , 在替换时 , 换行字元可用转义序列 <code>\n</code> 来匹配。</li>
</ol>
<p><span style="color:red">在多行模式空间中，元字符“<code>^</code>”匹配模式空间中的第一个字符，而不匹配换行符后面的字符。同样，“<code>$</code>”只匹配模式空间中最后的换行符，而不匹配任何嵌入的换行符。</span>在执行 <code>Next</code> 命令之后，控制将被传递给脚本中的后续命令（同 <code>next</code> ）。<code>Next</code> 命令与 <code>next</code> 命令不同，<code>next</code> 输出模式空间的内容，然后读取新的输入行。<code>next</code> 命令不创建多行模式空间。</p>
<h4 id="范例-7"><a href="#范例-7" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 将下述两行资料合。假设 <code>input.dat</code> 的内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The UNIX</div><div class="line">Operating System</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 先利用函数参数 <code>N</code> 将两行资料置於 pattern space 内 , 在利用函数参数 <code>s/\n/ /</code> 将两行资料间的分隔符 <code>\n</code> 以空白替代 , 如此两行资料变成一行输出。</p>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;N&apos; -e &apos;s/\n/ /&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令後 , 其输出的结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The UNIX Operating System</div></pre></td></tr></table></figure></p>
<h3 id="D"><a href="#D" class="headerlink" title="D"></a><a name="Delete">D</a></h3><p>函数参数 <code>D</code> 表示删除 pattern space 内的第一行资料（删除模式空间中直到第一个嵌入的换行符的这部分内容）。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]D</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>D</code> 最多配合两个位址参数。</li>
<li>函数参数 <code>D</code> 与 <code>d</code> 的比较如下 :</li>
</ol>
<ul>
<li>当 pattern space 内只有一资料行时 , <code>D</code> 与 <code>d</code> 作用相同。</li>
<li><p>当 pattern space 内有多行资料行时</p>
<ul>
<li><code>D</code> 表示只删除 pattern space 内第一行资料 ; <code>d</code> 则全删除。</li>
<li><code>D</code> 表示执行删除后 , pattern space 内不添加下一笔资料 , 而将剩下的资料重新执行 sed script （返回到脚本的顶端，将这些指令应用于模式空间剩余的内容）; <code>d</code> 则读入下一行后重新执行 sed script（返回到脚本的顶端）。</li>
</ul>
</li>
</ul>
<h3 id="P"><a href="#P" class="headerlink" title="P"></a><a name="Print">P</a></h3><p>函数参数 <code>P</code> 表示印出 pattern space 内的第一行资料（输出多行模式空间的第一部分，直到第一个嵌入的换行符为止）。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]P</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>P</code> 最多配合两个位址参数。</li>
<li><code>P</code> 与 <code>p</code> , 除了面对的 pattern space 内的资料行数不同外 , 其它均相同。</li>
</ol>
<p><span style="color:red">在执行完脚本的最后一个命令之后，模式空间的内容自动输出（<code>-n</code> 选项或 <code>#n</code> 抑制这个默认的动作）</span>。因此当默认的输出被抑制或者脚本中的控制流更改，以至不能达到脚本的底部时，需要使用打印命令（<code>P</code> 或 <code>p</code>）。<code>Print</code> 命令经常出现在 <code>Next</code> 命令之后和 <code>Delete</code> 命令之前。这 3 个命令能建立一个输入/输出循环，用来维护两行的模式空间，但是一次只输出一行。这个循环的目的是只输出模式空间的第一行，然后<span style="color:red">返回到脚本的顶端</span>将所有的命令应用于模式空间的第二行。没有这个循环，当执行脚本中的最后一个命令时，模式空间中的这两行都被输出。</p>
<h4 id="范例-8"><a href="#范例-8" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 输出 <code>input.dat</code> 档内奇数行资料。假设 <code>input.dat</code> 档内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">The</div><div class="line">UNIX</div><div class="line">System</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 在命令列上</p>
<ul>
<li>以选项 <code>-n</code>, 将资料输出的控制权转给指令。</li>
<li>利用函数参数 <code>N</code> 将偶数行添加至 pattern space 内奇数行後。</li>
<li>利用函数参数 <code>P</code> 将 pattern space 内的第一行(奇数行)输出。</li>
</ul>
<p>在奇数行输出後 , pattern space 内剩下的资料行(偶数行)则被放弃输出。最後 , 整个输出只有原先的奇数行资料。</p>
<p><strong>sed 命令列:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n -e &apos;N&apos; -e &apos;P&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>执行上述命令後, 输出的结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The</div><div class="line">System</div></pre></td></tr></table></figure></p>
<h3 id="模式空间与保持空间"><a href="#模式空间与保持空间" class="headerlink" title="模式空间与保持空间"></a>模式空间与保持空间</h3><p>模式空间的内容可以<span style="color:red">复制</span>到保持空间，而且保持空间的内容也可以<span style="color:red">复制</span>到模式空间。有一组命令用于在保持空间和模式空间之间移动数据。保持空间用于临时存储。单独的命令不能寻址保持空间或者更改它的内容。</p>
<p>保持空间最常见的用途是，当改变模式空间中的原始内容时，用于保留当前输入行的<span style="color:red">副本</span>。影响模式空间的命令有：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>缩写</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hold</td>
<td>h 或 H</td>
<td>将模式空间的内容复制或追加到保持空间</td>
</tr>
<tr>
<td>Get</td>
<td>g 或 G</td>
<td>将保持空间的内容复制或追加到模式空间</td>
</tr>
<tr>
<td>Exchang</td>
<td>x</td>
<td>交换模式空间和保持空间的内容</td>
</tr>
</tbody>
</table>
<p>hold(<code>h</code>，<code>H</code>)命令将数据移至保持空间，而 get(<code>g</code>，<code>G</code>)命令将保持空间的数据移回到模式空间。同一命令的小写字母和大写字母之间的差别是，小写字母命令改写目的缓存区的内容，而大写字母命令追加缓存区的现有内容。</p>
<p>hold（小写）命令用模式空间的内容取代保持空间的内容。get（小写）命令用保持空间的内容取代模式空间的内容。<br>Hold（大写）命令在保持空间的内容之后放置一个换行符，且后面跟随模式空间的内容（即使保持空间是空的，换行符也被追加到保持空间）。Get（大写）命令在模式空间的内容之后放置一个换行符，且后面跟随保持空间的内容。</p>
<p>交换命令交换两个缓存区的内容。对两个缓存区没有副作用。</p>
<h3 id="h"><a href="#h" class="headerlink" title="h"></a><a name="h">h</a></h3><p>函数参数 <code>h</code> 表示暂存 pattern space 的资料至 hold space。其指令格式如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]h</div></pre></td></tr></table></figure></p>
<p>对上述格式有下面几点说明 :</p>
<ol>
<li>函数参数 <code>h</code> 最多配合两个位址参数。</li>
<li>sed 执行暂存动作时 , 会盖掉(overwrite) hold space 内原来的资料。</li>
<li>当 sed 全部执行结束时 , hold space 内资料会自动清除。</li>
</ol>
<h3 id="H"><a href="#H" class="headerlink" title="H"></a><a name="Hold">H</a></h3><p>函数参数 <code>H</code> 与 <code>h</code> 唯一差别是 , sed 执行 <code>h</code> 时 , 资料盖掉(overwrite) hold space 内原来的资料 ,而 <code>H</code> , 资料则是 “添加(append)” 在 hold space 原来资料後。</p>
<h3 id="g"><a href="#g" class="headerlink" title="g"></a><a name="g">g</a></h3><p>函数参数 <code>g</code> 表示与函数参数 <code>h</code> 相反的动作 , 它表示将 hold space 内资料放回 pattern space内。其指令格式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]g</div></pre></td></tr></table></figure></p>
<p>函数参数 g 最多配合两个位址参数。<br>sed 执行放回动作时 , 资料盖掉(overwrite) pattern space 内原来的资料。</p>
<h3 id="G"><a href="#G" class="headerlink" title="G"></a><a name="Gg">G</a></h3><p>函数参数 <code>G</code> 与 <code>g</code> 唯一差别是 , sed 执行 <code>g</code> 时 , 资料盖掉(overwrite) pattern space 内原来的资料 , 而 <code>G</code> , 资料则是 “添加(append)” 在 pattern space 原来资料後。</p>
<h3 id="x"><a href="#x" class="headerlink" title="x"></a><a name="x">x</a></h3><p>函数参数 <code>x</code> 表示交换 hold space 与 pattern space 内的资料。其指令格式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[, address2]]x</div></pre></td></tr></table></figure></p>
<p>函数参数 <code>x</code> 大部份与其它处理 hold space 的函数参数一起配合。例如 , 将 <code>input.dat</code> 档内第 1 行资料取代第 3 行资料。此时 , 用函数参数 <code>h</code> 与 <code>x</code> 来配合。其中 , 以函数参数 <code>h</code> 将第 1 资料存入 hold space ;当第 3 行资料出现在pattern space , 以函数参数 <code>x</code> 交换 hold space 与 pattern space 的内容。如此 , 第 3 行资料就被第 1 资料替代。其命令列如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;1h&apos; -e &apos;3x&apos; input.dat</div></pre></td></tr></table></figure></p>
<h3 id="高级流程控制指令"><a href="#高级流程控制指令" class="headerlink" title="高级流程控制指令"></a>高级流程控制指令</h3><p>分支（<code>b</code>）和测试（<code>t</code>）命令将脚本中的控制转移到包含特殊标签的行。如果没有指定标签，则将控制转移到脚本的结尾处。分支命令用于无条件转移，测试命令用于有条件转移，它们只有当替换命令改变当前行时才会执行。<br>标签是任意不多于7个字符的序列（GNU sed 允许标签为任意长度）。标签本身占据一行并以冒号开始：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:mylabel</div></pre></td></tr></table></figure></p>
<p>在冒号和标签之间不允许有空格。行结尾处的空格将被认为是标签的一部分。当在分支命令或测试命令中指定标签时，在命令和标签之间允许有空格：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">b mylabel</div></pre></td></tr></table></figure></p>
<p>注意，不要在标签后面插入空格。</p>
<h3 id="b-label"><a href="#b-label" class="headerlink" title="b :label"></a><a name="b">b :label</a></h3><p>函数参数 <code>:</code> 与函数参数 <code>b</code> 可在 sed script 内建立类似 BASIC 语言中 GOTO 指令的功能。其中 , 函数参数 <code>:</code> 建立标记;函数参数 <code>b</code> 将下一个执行的指令 branch 到标记处执行。函数参数 <code>:</code> 与 <code>b</code> , 在 script file 内配合的情况如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">     .</div><div class="line">     .</div><div class="line">     .</div><div class="line">编辑指令m1</div><div class="line">:记号</div><div class="line">编辑指令m2</div><div class="line">     .</div><div class="line">     .</div><div class="line">     .</div><div class="line">[address1[, address2]]b [记号]</div></pre></td></tr></table></figure></p>
<p>其中, 当 sed 执行至指令<code>[address1[, address2]]b [记号]</code>时 , 如 pattern space 内的资料符合位址参数 , 则 sed 将下一个执行的位置 branch 至由 <code>:记号</code>设定的标记处 , 也就是再由 “<code>编辑指令 m2</code>“ … 执行。另外 , 如果指令中函数参数 <code>b</code> 後没有记号 , 则 sed 将下一个执行的指令 branch 到 script file 的最後 , 利用此可使 sed script 内有类似 C 语言中的 case statement 结构。</p>
<h4 id="范例-9"><a href="#范例-9" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 将 <code>input.dat</code> 档内资料行的开头字母重覆印 40 次。假设 <code>input.dat</code> 档的内容如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A</div><div class="line">B</div><div class="line">C</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> 用指令 <code>b p1</code> 与 <code>:p1</code> 构成执行增加字母的回圈(loop) , 同时在字母出现 40 个时 , 也用指令 <code>b</code> 来跳出圈。下面就以档内第一行资料 “<code>A</code>“ 为例 , 描述它如何连续多添加 39 个 “<code>A</code>“ 在同一行:</p>
<ul>
<li>用指令 <code>s/A/AA/</code> 将 “<code>A</code>“ 替换成 “<code>AA</code>“。</li>
<li>用指令 <code>b p1</code> 与 <code>:p1</code> 构成回圈(loop) , 它目的使上述动作被反覆的执行。每执行一次圈 , 则资料行上的 “<code>A</code>“ 就多出一个。例如 , 第一次圈资料行变成 “<code>AA</code>“ , 第二次圈资料行变成 “<code>AAA</code>“ …。</li>
<li>用指令 <code>[ABC]\{40\}/b</code> （注解：<code>\{重复次数\}</code> 、<code>\{下限,上限\}</code>）来作为停止回圈的条件。当资料行有连续 40 个 <code>A</code> 出现时 , 函数参数 <code>b</code> 将执行的指令跳到最後 , 停止对此行的编辑。</li>
</ul>
<p>同样, 对其它资料行也如同上述的方式执行。</p>
<p><strong>sed 命令列如下:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;&#123;</div><div class="line">:p1</div><div class="line">/A/s/A/AA/</div><div class="line">/B/s/B/BB/</div><div class="line">/C/s/C/CC/</div><div class="line">/[ABC]\&#123;40\&#125;/b</div><div class="line">b p1</div><div class="line">&#125;&apos; input.dat</div></pre></td></tr></table></figure></p>
<p>命令结果输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA</div><div class="line">BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB</div><div class="line">CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC</div></pre></td></tr></table></figure></p>
<h3 id="t"><a href="#t" class="headerlink" title="t"></a><a name="t">t</a></h3><p>基本上, 函数参数 <code>t</code> 与 函数参数 <code>b</code> 的功能类似 , 除了在执行 <code>t</code> 的 branch 前 , 会先去测试其前的替换指令有没有执行替换成功外。在 script file 内的情况如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">     .</div><div class="line">     .</div><div class="line">     .</div><div class="line">编辑指令m1</div><div class="line">:记号</div><div class="line">编辑指令m2</div><div class="line">     .</div><div class="line">     .</div><div class="line">     .</div><div class="line">s/.../.../</div><div class="line">[address1[, address2]]t [记号]</div><div class="line">编辑指令m3</div></pre></td></tr></table></figure></p>
<p>其中 , 与函数参数 <code>b</code> 不同处在於, 执行函数参数 <code>t</code> branch 时, 会先检查其前一个替换指令成功与否。如成功, 则执行 branch; 不成功, 则不 branch, 而继续执行下一个编辑指令, 例如上面的<code>编辑指令m3</code>。</p>
<h4 id="范例-10"><a href="#范例-10" class="headerlink" title="范例"></a>范例</h4><p><strong>题目:</strong> 将 <code>input.dat</code> 档中资料 <code>A1</code> 替换成<code>C1</code>、<code>C1</code> 替换成<code>B1</code>、<code>B1</code> 替换成<code>A1</code>。<code>input.dat</code> 档的内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">代号</div><div class="line">B1</div><div class="line">A1</div><div class="line">B1</div><div class="line">C1</div><div class="line">A1</div><div class="line">C1</div></pre></td></tr></table></figure></p>
<p><strong>说明:</strong> <code>input.dat</code> 档中全部资料行只需要执行一次替换动作 , 但为避免资料被替换多次 , 所以利用函数参数 <code>t</code> 在 sed script 内形成一类似 C 语言中 case statement 结构 , 使每行资料替换一次後能立即用函数参数 <code>t</code> 跳离替换编辑。</p>
<p><strong>sed 命令列:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">sed -e &apos;&#123;</div><div class="line">s/A1/C1/</div><div class="line">t</div><div class="line">s/C1/B1/</div><div class="line">t</div><div class="line">s/B1/A1/</div><div class="line">t</div><div class="line">&#125;&apos; input.dat</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[sed 学习手册]]></title>
      <url>http://jarsonfang.github.io/etesting/Tools/sed-awk/sed-manual/</url>
      <content type="html"><![CDATA[<h2 id="sed-简要介绍"><a href="#sed-简要介绍" class="headerlink" title="sed 简要介绍"></a>sed 简要介绍</h2><p>Sed(Stream EDitor)为 UNIX 系统上提供将编辑工作自动化的编辑器 , 使用者无需直接编辑资料。使用者可利用 sed 所提供 20 多种不同的<span style="color:red;">函数[参数] </span>, 组合它们完成不同的编辑动作。此外 ,由於 sed 都以行为单位编辑文件 , 故其亦是行编辑器(line editor)。<br> 一般 sed 最常用在编辑那些需要不断重覆某些编辑动作的文件上, 例如将文件中的某个字串替换成另一个字串等等。这些相较於一般 UNIX 编辑器(交互式的, 如 vi、emacs)用手动的方式修改文件, sed 用起来较省力。</p>
<p>sed 是一个非交互式上下文(context)编辑器,它被设计在下列三种情况下发挥作用:</p>
<ol>
<li>编辑那些对舒适的交互式编辑而言太大的文件。</li>
<li>在编辑命令太复杂而难于在交互模式下键入的时候，编辑任何大小的文件。</li>
<li>要在对输入的一趟扫描中有效的进行多个”全局”(global)编辑函数。</li>
</ol>
<p>因为每次只把输入的某些行驻留在内存中, 并且不使用临时文件,所以可编辑的文件的有效大小,只受限于输入和输出要同时共存于次级存储的要求。可以单独的建立复杂的编辑脚本并作为给 sed 的命令文件。对于复杂的编辑,这节省了可观的键入和随之而来的错误。从命令文件运行 sed 高效于作者所知道的任何交互式编辑器,甚至包括能用预先写好的脚本驱动的编辑器。</p>
<p>相较于交互式编辑器而言,根本性的损失是缺乏相对地址(由于操作是每次一行的),和缺乏对命令如期运行的立即验证。<br><a id="more"></a></p>
<h2 id="sed-如何工作"><a href="#sed-如何工作" class="headerlink" title="sed 如何工作"></a>sed 如何工作</h2><p>如同其它 UNIX 命令, sed 由标准输入读入编辑文件并由标准输出送出结果。下图表示 sed将资料行 “<code>Unix</code>“ 替换成 “<code>UNIX</code>“,<br><img src="/etesting/Tools/sed-awk/sed-manual/sed.gif" alt="sed.gif" title=""><br>在图中, 上方 standard input 为标准输入, 是读取资料之处; standard output 为标准输出, 是送出结果之处;中间 sed 方块的下面两个虚线方块表示 sed 的工作流程。其中, 左边虚线方块表示 sed 将标准输入资料置入pattern space, 右边虚线方块表示 sed 将 pattern space 中编辑完毕後的资料送到标准输出。</p>
<p>在虚线方块中, 两个实线方块分别表示 pattern space 与 sed script。其中, pattern space 为一缓区, 它是sed 工作场所; 而 sed script 则表示一组执行的编辑指令。</p>
<p>在图中, 左边虚线方块 “Unix” 由标准输入置入 pattern space; 接着 , 在右边虚线方块中, sed执行 sed script 中的编辑指令<code>s/Unix/UNIX/</code>, 结果 “Unix” 被替换成 “UNIX”, 之後, “UNIX” 由pattern space 送到标准输出。</p>
<p>总合上述所言, 当 sed 由标准输入读入一行资料并放入 pattern space 时, sed 依照 sed script 的编辑指令逐一对 pattern space 内的资料执行编辑, 之後, 再由 pattern space 内的结果送到标准输出, 接着再将下一行资料读入。如此重复执行上述动作 , 直至读完所有资料行为止。</p>
<p>sed 维护一种模式空间（patter space），即一个工作区或临时缓冲区，当应用编辑命令时将在那里存储单个输入行。sed 还维护了称为保持空间(hold space)的另一个临时缓冲区，可以将模式空间的内容复制到保持空间并在以后检索它们。</p>
<h2 id="使用-sed"><a href="#使用-sed" class="headerlink" title="使用 sed"></a>使用 sed</h2><p>sed 命令列可分成编辑指令与文件档部份。其中, 编辑指令负责控制所有的编辑工作; 文件档表示所处理的档案。sed 的编辑指令均由<span style="color:#ff0000">位址(address)</span>与<span style="color:#ff0000">函数(function)</span>两部份组成, 其中, 在执行时, sed 利用它的<span style="color:red;">位址参数</span>来决定编辑的对象; 而用它的<span style="color:red;">函数[参数]</span>编辑。</p>
<p>此外, sed 编辑指令, 除了可在命令列上执行, 也可在档案内执行。其中差别只是在命令列上执行时, 其前必须加上选项 <code>-e</code>; 而在档案内时, 则只需在其档名前加上选项 <code>-f</code>。另外, sed 执行编辑指令是依照它们在命令列上或档内的次序。</p>
<p>下面各节, 将介绍执行命令列上的编辑指令、sed 编辑指令、执行档案内的编辑指令、执行多个档案的编辑、及执行 sed 输出控制。</p>
<h3 id="执行命令列上的编辑指令"><a href="#执行命令列上的编辑指令" class="headerlink" title="执行命令列上的编辑指令"></a>执行命令列上的编辑指令</h3><p>当编辑指令在命令列上执行时, 其前必须加上选项 <code>-e</code> 。其命令格式如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'编辑指令 1'</span> <span class="_">-e</span> <span class="string">'编辑指令 2'</span> ... 文件档</div></pre></td></tr></table></figure></p>
<p>其中, 所有编辑指令都紧接在选项 <code>-e</code> 之後, 并置於两个 “<code>&#39;</code>“ 特殊字元间。另外, 命令上编辑指令的执行是由左而右。</p>
<p>一般编辑指令不多时, 使用者通常直接在命令上执行它们。例如, 删除 <code>yel.dat</code> 内 <code>1</code> 至<code>10</code> 行资料 , 并将其馀文字中的 “<code>yellow</code>“ 字串改成 “<code>black</code>“ 字串。此时 , 可将编辑指令直接在命令上执行 , 其命令如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'1,10d'</span> <span class="_">-e</span> <span class="string">'s/yellow/black/g'</span> yel.dat</div></pre></td></tr></table></figure></p>
<p>在命令中 , 编辑指令 ‘<code>1,10d</code>‘ 执行删除 <code>1</code> 至 <code>10</code> 行资料 ; 编辑指令 ‘<code>s/yellow/black/g</code>‘，”<code>yellow</code>“ 字串替换(substitute)成 “<code>black</code>“ 字串。</p>
<h3 id="sed-的编辑指令"><a href="#sed-的编辑指令" class="headerlink" title="sed 的编辑指令"></a>sed 的编辑指令</h3><p> sed 编辑指令的格式如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address1[,address2]]<span class="keyword">function</span>[argument]</div></pre></td></tr></table></figure></p>
<p>其中 , 位址参数 <code>address1</code> 、<code>address2</code> 为行数或 regular expression 字串 , 表示所执行编辑的资料行 ; 函数参数 <code>function[argument]</code> 为 sed 的内定函数 , 表示执行的编辑动作。</p>
<p>下面两小节 , 将仔细介绍位址参数的表示法与有哪些函数参数供选择。</p>
<p><strong>位址(address)参数的表示法</strong></p>
<p>实际上 , 位址参数表示法只是将要编辑的资料行 , 用它们的行数或其中的字串来代替表示它们。下面举几个例子说明(指令都以函数参数 d 为例) :</p>
<ul>
<li>删除档内第 10 行资料 , 则指令为 <code>10d</code></li>
<li>删除含有 “man” 字串的资料行时 , 则指令为 <code>/man/d</code></li>
<li>删除档内第 10 行到第 200 行资料, 则指令为 <code>10,200d</code></li>
<li>删除档内第 10 行到含 “man” 字串的资料行 , 则指令为 <code>10,/man/d</code></li>
</ul>
<p>接下来 , 以位址参数的内容与其个数两点 , 完整说明指令中位址参数的表示法(同样也以函数参数 <code>d</code> 为例)。</p>
<ul>
<li><p>位址参数的内容:</p>
<ul>
<li>位址为十进位数字 （行地址）: 此数字表示行号。当指令执行时 , 将对符合此行号的资料执行函数参数指示的编辑动作。例如 ,删除资料档中的第 15 行资料 , 则指令为 <code>15d</code>。其馀类推 ,如删除资料档中的第 m 行资料 , 则指令为 <code>md</code> 。行号是由 sed 维护的内部行数。该计数器不会因为多个输入文件而重置。因此，不管指定多少个输入文件，在<span style="color:red">输入流</span>（多个文件（流）构成一个输入流，文件个数不同，输入流的大小也会不同）中也只有一行<code>1</code>。同样，输入流也只有一个最后的行。可以使用寻址符号 <code>$</code> 指定。下面的示例删除输入流的最后一行：<code>$d</code>（<code>$</code> 符号不应该和正则表达式中使用的 <code>$</code> 相混淆，在这里表示行的结束）</li>
<li>位址为 regular expression（模式地址）: 当资料行中有符合 regular expression 所表示的字串时 , 则执行函数参数指示的编辑动作。另外 ,在regular expression 前後必须加上 “<code>/</code>“。例如指令为 <code>/t.*t/d</code> , 表示删除所有含两 “<code>t</code>“ 字母的资料行。其中 , “<code>.</code>“表示任意字元; “<code>*</code>“ 表示其前字元可重复任意次 , 它们结合 “<code>.*</code>“ 表示两 “<code>t</code>“ 字母间的任意字串。</li>
</ul>
</li>
<li><p>位址参数的个数 : 在指令中 , <span style="color:red">如果没有指定位址参数</span> , 表示全部资料行执行函数参数所指示的编辑动作;<span style="color:red"> 如果只有一位址参数</span> , 表示只有符合位址的资料行才编辑 ; <span style="color:red">如果指定了由逗号分隔的两个位址参数 </span>, 如 <code>address1,address2</code> 时 ,表示对资料区执行编辑 , <code>address1</code> 代表起始资料行 , <code>address2</code> 代表结束资料行（即编辑命令应用于第一个地址的第一行和它后面的行，直到匹配第二个地址的行（包括此行）。你可以把第一个地址看做是启用动作，并把第二个地址看做是禁用动作。sed 没有办法先行决定第二个地址是否会匹配。一旦匹配了第一个地址，这个（些）动作就将应用于这些行。于是编辑命令应用于“所有”随后的行直到第二个地址被匹配。）。<span style="color:red">如果地址后面跟有感叹号(!)</span>，那么编辑命令就应用于<span style="color:red">不匹配</span>该地址的所有的行。对於上述内容 , 以下面例子做具体说明。</p>
<ol>
<li>例如指令为<code>d</code>其表示删除档内所有资料行。</li>
<li>例如指令为<code>5d</code>其表示删除档内第五行资料。</li>
<li>例如指令为<code>1,/apple/d</code>其表示删除资料区 , 由档内第一行至内有 “<code>apple</code>“ 字串的资料行。</li>
<li>例如指令为<code>/apple/,/orange/d</code>其表示删除资料区 , 由档内含有 “<code>apple</code>“ 字串至含有 “<code>orange</code>“ 字串的资料行</li>
<li>例如指令为<code>/regular/!d</code>其表示删除所有的不包含“<code>regular</code>”字符串的资料行。</li>
</ol>
</li>
</ul>
<p><strong>有哪些函数(function)参数</strong></p>
<p>下表中介绍所有 sed 的函数参数的功能。</p>
<table>
<thead>
<tr>
<th>函数参数</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>:label</td>
<td>建立script file内指令互相参考的位置</td>
</tr>
<tr>
<td>#</td>
<td>建立注解</td>
</tr>
<tr>
<td>{ }</td>
<td>集合有相同位址参数的指令</td>
</tr>
<tr>
<td>!</td>
<td>不执行函数参数</td>
</tr>
<tr>
<td>=</td>
<td>印出资料行数（line number）</td>
</tr>
<tr>
<td>a\</td>
<td>添加使用者输入的资料</td>
</tr>
<tr>
<td>b label</td>
<td>将执行的指令跳至由 : 建立的参考位置</td>
</tr>
<tr>
<td>c\</td>
<td>以使用者输入的资料取代资料</td>
</tr>
<tr>
<td>d</td>
<td>删除资料</td>
</tr>
<tr>
<td>D</td>
<td>删除 pattern space 内第一个 newline 字母 \n 前的资料</td>
</tr>
<tr>
<td>g</td>
<td>从 hold space 中拷贝资料</td>
</tr>
<tr>
<td>G</td>
<td>拷贝 hold space 中的资料添加到 pattern space</td>
</tr>
<tr>
<td>h</td>
<td>从 pattern space 中拷贝资料到 hold space</td>
</tr>
<tr>
<td>H</td>
<td>拷贝 pattern space 中的资料添加到 hold space</td>
</tr>
<tr>
<td>I</td>
<td>印出资料中的 nonprinting character 的ASCII码值</td>
</tr>
<tr>
<td>i\</td>
<td>插入添加使用者输入的资料行</td>
</tr>
<tr>
<td>n</td>
<td>读入下一笔资料</td>
</tr>
<tr>
<td>N</td>
<td>添加下一笔资料到 pattern space</td>
</tr>
<tr>
<td>p</td>
<td>印出资料</td>
</tr>
<tr>
<td>P</td>
<td>印出 pattern space 内第一个 newline 字母 \n 前的资料</td>
</tr>
<tr>
<td>q</td>
<td>跳出 sed 编辑</td>
</tr>
<tr>
<td>r</td>
<td>读入文档内容</td>
</tr>
<tr>
<td>s</td>
<td>替换字串</td>
</tr>
<tr>
<td>t label</td>
<td>先执行一替换编辑命令，如果替换成功，则将编辑指令跳至 :label 处执行</td>
</tr>
<tr>
<td>w</td>
<td>写资料到文档</td>
</tr>
<tr>
<td>x</td>
<td>交换 hold space 与 pattern space 中的内容</td>
</tr>
<tr>
<td>y</td>
<td>转换(transform)字元</td>
</tr>
</tbody>
</table>
<p>虽然 , sed 只有上表所述几个拥有基本编辑功能的函数 , 但由指令中位址参数和指令与指令间的配合 , 也能使sed 完成大部份的编辑任务。</p>
<h3 id="执行档案内的编辑指令"><a href="#执行档案内的编辑指令" class="headerlink" title="执行档案内的编辑指令"></a>执行档案内的编辑指令</h3><p>当执行的指令太多 , 在命令列上撰写起来十分混乱 , 此时 , 可将这些指令整理储存在档案  (譬如档名为 <code>script_file</code> )内 , 用选项 <code>-f script_file</code> , 则让 sed 执行 <code>script_file</code> 内的编辑指令。其命令的格示如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-f</span> script_file 文件档</div></pre></td></tr></table></figure></p>
<p>其中 , 执行 <code>script_file</code> 内编辑指令的顺序是由上而下。例如上一节的例子 , 其可改成如下命令:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-f</span> ysb.scr yel.dat</div></pre></td></tr></table></figure></p>
<p>其中 , <code>ysb.scr</code> 档的内容如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">1,10d</div><div class="line">s/yellow/black/g</div></pre></td></tr></table></figure></p>
<p>另外 , 在命令列上可混合使用选项 <code>-e</code> 与 <code>-f</code> , sed 执行指令顺序依然是由命令列的左到右,如执行至 <code>-f</code> 後档案内的指令 , 则由上而下执行。</p>
<h3 id="执行多个文件档的编辑"><a href="#执行多个文件档的编辑" class="headerlink" title="执行多个文件档的编辑"></a>执行多个文件档的编辑</h3><p>在 sed 命令列上 , 一次可执行编辑多个文件档 , 它们跟在编辑指令之後。例如 , 替换 <code>white.dat</code>、<code>red.dat</code>、<code>black.dat</code> 档内的 “<code>yellow</code>“ 字串成 “<code>blue</code>“ , 其命令如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'s/yellow/blue/g'</span> white.dat red.dat black.dat</div></pre></td></tr></table></figure></p>
<p>上述命令执行时 , sed 依 <code>white.dat</code>、<code>red.dat</code>、<code>black.dat</code> 顺序 , 执行编辑指令 <code>s/yellow/blue/</code> ,进行字串的替换。</p>
<h3 id="执行输出的控制"><a href="#执行输出的控制" class="headerlink" title="执行输出的控制"></a>执行输出的控制</h3><p>在命令列上的选项 <code>-n</code> 表示输出由编辑指令控制。由前章内容得知 , sed 会 “自动的”将资料由 pattern space 输送到标准输出档。但藉着选项 <code>-n</code> , 可将 sed 这 “自动的” 的动作改成 “被动的” 由它所执行的编辑指令来决定结果是否输出。</p>
<p>由上述可知 , 选项 <code>-n</code> 必须与编辑指令一起配合 , 否则无法获得结果。例如 , 印出<code>white.dat</code>档内含有 “<code>white</code>“ 字串的资料行 , 其命令如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n <span class="_">-e</span> <span class="string">'/white/p'</span> white.dat</div></pre></td></tr></table></figure></p>
<p>上面命令中 , 选项 <code>-n</code> 与编辑指令 <code>/white/p</code>  一起配合控制输出。其中 ，选项 <code>-n</code> 将输出控制权移给编辑指令；<code>/white/p</code> 将资料行中含有 “<code>white</code>“ 字串印出萤幕。</p>
<h2 id="范例"><a href="#范例" class="headerlink" title="范例"></a>范例</h2><p>一般在实际使用编辑器的过程中 , 常需要执行替换文件中的字串、搬移、删除、与搜寻资料行等等动作。当然 , 一般交谈式编辑器(如 vi、emacs)都能做得到上述功能 , 但文件一旦有大量上述编辑需求时 , 则用它们编辑十分没有效率。本章将用举例的方式说明如何用 sed 自动执行这些编辑功能。此外 , 在本章范例中 , 均以下述方式描述文件的需求 :</p>
<blockquote>
<p>将文件中…资料 , 执行…(动作)</p>
</blockquote>
<p>如此 , 目的是为了能将它们迅速的转成编辑指令。其中 , “<code>...资料</code>“ 部份 , 转成指令中的<code>位址参数</code>表示 ;”<code>执行...动作</code>“ 部份 , 则转成<code>函数参数</code>表示 。另外 ,将一个地址嵌套在另一个地址中（内层地址必须在外层地址的作用范围之内），或者 “执行…动作” 要由数个函数参数表示时, 则可利用 “<code>{</code>“与 “<code>}</code>“ 集合这些函数参数（注：左大括号必须在行末，而且右大括号本身必须单独占一行。要确保在大括号之后没有空格。）, 其指令形式如下 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">位址参数&#123;</div><div class="line">   函数参数 1</div><div class="line">   函数参数 2</div><div class="line">   函数参数 3</div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上述指令表示 , 将对符合位址参数的资料 , 依次执行函数参数 1、函数参数 2、函数参数 3 … 表示的动作。</p>
<p>下面各节 , 分别举例说明 sed 替换资料、移动、删除资料、及搜寻资料的命令。</p>
<h3 id="替换文件中的资料"><a href="#替换文件中的资料" class="headerlink" title="替换文件中的资料"></a>替换文件中的资料</h3><p>sed 可替换文件中的字串、资料行、甚至资料区。其中 , 表示替换字串的指令中的函数参数为 <code>s</code> ;表示替换资料行、或资料区的指令中的函数参数为 <code>c</code> 。上述情况以下面三个例子说明。</p>
<p>例一. 将文件中含 “<code>machine</code>“ 字串的资料行中的 “<code>phi</code>“ 字串 , 替换成为 “<code>beta</code>“ 字串。其命令列如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'/machine/s/phi/beta/g'</span> input.dat (以後文件档都以 input.dat 代表)</div></pre></td></tr></table></figure></p>
<p>例二. 将文件中第 5 行资料 , 替换成句子 “Those who in quarrels interpose, must often wipe a bloody nose.”。其命令列如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'5c</span></div><div class="line">Those must often wipe a bloody nose.</div><div class="line">' input.dat</div></pre></td></tr></table></figure></p>
<p>例三. 将文件中 1 至 100 行的资料区 , 替换成如下两行资料 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">How are you?</div><div class="line">data be deleted!</div></pre></td></tr></table></figure></p>
<p>则其命令列如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'1,100c</span></div><div class="line">How are you?</div><div class="line">data be deleted!</div><div class="line">' input.dat</div></pre></td></tr></table></figure></p>
<h3 id="搬动文件中的资料"><a href="#搬动文件中的资料" class="headerlink" title="搬动文件中的资料"></a>搬动文件中的资料</h3><p>使用者可用 sed 中的 hold space 暂存编辑中的资料、用函数参数 <code>w</code> 将文件资料搬动到它档内储存、或用函数参数 <code>r</code> 将它档内容搬到文件内。Hold space 是 sed 用来暂存 pattern space 内资料的暂存器 , 当 sed 执行函数参数<code>h</code>、<code>H</code> 时 , 会将 pattern space 资料暂存到 hold space ;当执行函数参数<code>x</code>、<code>g</code>、<code>G</code> 时 , 会将暂存的资料取到 pattern space 。下面举三个例子说明。</p>
<p>例一. 将文件中的前 100 资料 , 搬到文件中第 300 後输出。其命令列如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-f</span> mov.scr 文件档</div></pre></td></tr></table></figure></p>
<p>mov.scr 档的内容为<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">1,100&#123;</div><div class="line">H</div><div class="line">d</div><div class="line">&#125;</div><div class="line">300G</div></pre></td></tr></table></figure></p>
<p>其中 ,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">1,100&#123;</div><div class="line">H</div><div class="line">d</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它表示将文件中的前 100 资料 , 先储存在 hold space 之後删除 ;指令 <code>300G</code> 表示 , 将 hold space 内的资料 , 添加在文件中的第 300 行资料後输出。</p>
<p>例二. 将文件中含 “<code>phi</code>“ 字串的资料行 , 搬至 <code>mach.inf</code> 档中储存。其命令列如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'/phi/w mach.inf'</span> 文件档</div></pre></td></tr></table></figure></p>
<p>例三. 将 <code>mach.inf</code> 档内容 , 搬至文件中含 “<code>beta</code>“ 字串的资料行。其命令列如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'/beta/r mach.inf'</span> 文件档</div></pre></td></tr></table></figure></p>
<p>另外 , 由於 sed 是一 stream 编辑器 , 故理论上输出後的文件资料不可能再搬回来编辑。</p>
<h3 id="删除文件中的资料"><a href="#删除文件中的资料" class="headerlink" title="删除文件中的资料"></a>删除文件中的资料</h3><p>因为 sed 是一行编辑器 , 所以 sed 很容易删除个别资料行或整个资料区。一般用函数参数 <code>d</code> 或 <code>D</code> 来表示。下面举两个例子说明。</p>
<ul>
<li><p>将文件内所有空白行全部删除。其命令列为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'/^$/d'</span> 文件档</div></pre></td></tr></table></figure>
<p>regular expression <code>^$</code> 表示空白行。 其中 , <code>^</code> 限制其後字串必须在行首; <code>$</code> 限制其前字串必须在行尾。</p>
</li>
<li><p>将文件内连续的空白行 , 删除它们成为一行。其命令列为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-e</span> <span class="string">'/^$/&#123;</span></div><div class="line">N</div><div class="line">/^$/D</div><div class="line">&#125;' 文件档</div></pre></td></tr></table></figure>
<p>其中 , 函数参数 <code>N</code> 表示 , 将空白行的下一行资料添加至 pattern space 内。函数参数 <code>/^$/D</code> 表示 ,当添加的是空白行时 , 删除第一行空白行 , 而且剩下的空白行则再重新执行指令一次。指令重新执行一次 , 删除一行空白行 ,如此反覆直至空白行後添加的为非空白行为止 , 故连续的空白行最後只剩一空白行被输出。</p>
</li>
</ul>
<h3 id="搜寻文件中的资料"><a href="#搜寻文件中的资料" class="headerlink" title="搜寻文件中的资料"></a>搜寻文件中的资料</h3><p>sed 可以执行类似 UNIX 命令 grep 的功能。理论上 , 可用 regular expression 。例如 , 将文件中含有 “<code>gamma</code>“ 字串的资料行输出。则其命令列如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed -n <span class="_">-e</span> <span class="string">'/gamma/p'</span> 文件档</div></pre></td></tr></table></figure></p>
<p>但是 , sed 是行编辑器 , 它的搜寻基本上是以一行为单位。因此 , 当一些字串因换行而被拆成两部份时 , 一般的方法则不可行。此时 , 就必须以合两行的方式来搜寻这些资料。其情况如下面例子:</p>
<p>例. 将文件中含 “<code>omega</code>“ 字串的资料输出。其命令列如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sed <span class="_">-f</span> gp.scr 文件档</div></pre></td></tr></table></figure></p>
<p><code>gp.scr</code> 档的内容如下 :<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/omega/b</div><div class="line">N</div><div class="line">h</div><div class="line">s/.*n//</div><div class="line">/omega/b</div><div class="line">g</div><div class="line">D</div></pre></td></tr></table></figure></p>
<p>在上述 sed script , 因藉着函数参数 <code>b</code> 形成类似 C 语言中的 case statement 结构 , 使得 sed 可分别处理当资料内含 “<code>omega</code>“ 字串 ; 当 “<code>omega</code>“ 字串被拆成两行 ; 以及资料内没有”<code>omega</code>“ 字串的情况。接下来就依上述的三种情况 , 将 sed script 分成下面三部份来讨论。</p>
<ol>
<li><p>当资料内含 “<code>omega</code>“ , 则执行编辑指令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/omega/b</div></pre></td></tr></table></figure>
<p>它表示当资料内含 “<code>omega</code>“ 字串时 , sed 不用再对它执行後面的指令 , 而直接将它输出。</p>
</li>
<li><p>当资料内没有”<code>omega</code>“ , 则执行编辑指令如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">N</div><div class="line">h</div><div class="line">s/.*n//</div><div class="line">/omega/b</div></pre></td></tr></table></figure>
<p>其中 , 函数参数 <code>N</code> , 它表示将下一行资料读入使得 pattern space 内含前後两行资料 。函数参数 <code>h</code> , 它表示将 pattern space 内的前後两行资料存入 hold space 。函数参数 <code>s/.*n//</code> , 它表示将 pattern space 内的前後两行资料合成一行。<code>/omega/b</code> , 它表示如果合後的资料内含 “<code>omega</code>“ 字串 , 则不用再执行它之後的指令 , 而将此资料自动输出 。</p>
</li>
<li><p>当合并後的资料依旧不含 “<code>omega</code>“ , 则执行编辑指令如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">g</div><div class="line">D</div></pre></td></tr></table></figure>
<p>其中 , 函数参数 <code>g</code> , 它表示将 hold space 内合前的两行资料放回 pattern space。 函数参数 <code>D</code> , 它表示删除两行资料中的第一行资料 , 并让剩下的那行资料 , 重新执行 sed script 。如此 ,无论是资料行内或行间的字串才可搜寻完全。</p>
</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[sed & awk 概述]]></title>
      <url>http://jarsonfang.github.io/etesting/Tools/sed-awk/sed-awk-overview/</url>
      <content type="html"><![CDATA[<p>摘自《sed与awk》 Dale Dougberty&amp;Arnold Robbins 著</p>
<p>如果你正要开始学习 sed 与 awk，最好从了解它们的共同点入手：</p>
<ul>
<li>它们都使用相似的语法来调用。</li>
<li>它们都是面向字符流的，都是从文本文件中<span style="color:red">一次一行</span>的读取输入,并将输出直接送到标准输出端。</li>
<li>它们都使用正则表达式进行模式匹配。</li>
<li>它们允许用户在脚本中指定指令。</li>
</ul>
<p>它们有如此多的共同点，原因之一是它们都起源于相同的行编辑器—— ed。下面首先对 ed 做简短介绍，再介绍 sed 和 awk 是如何一步步形成<span style="color:red">可编程的编辑器</span>的。sed 和 awk 的区别在于它们控制所做的工作时所用的指令不同。这是一个主要的区别，而且这影响了这些程序最适于处理的任务类型。<br><a id="more"></a></p>
<h2 id="awk-起源于-sed-和-grep-而不是-ed"><a href="#awk-起源于-sed-和-grep-而不是-ed" class="headerlink" title="awk 起源于 sed 和 grep 而不是 ed"></a>awk 起源于 sed 和 grep 而不是 ed</h2><p>可以将 awk 的起源追溯到 sed 和 grep，并且经由这两个程序追溯到 ed（最初的UNIX行编辑器）。</p>
<p>如果使用过行编辑器，那么理解 sed 和 awk 的行定位就会更容易。如果使用过 vi（全屏幕的编辑器），那么你一定熟悉由底层的行编辑器 ex（它依次是 ed 中的特征的扩展集）衍生的大量命令。</p>
<p>下面来看一些使用行编辑器 ed 的基本操作。不要担心，这只是帮助你了解 sed 和 awk 的练习，而不是想让你相信行编辑器的奇妙。这个练习中出现的 ed 命令和稍后要学的 sed 命令相同。你可以自由地使用 ed 做实验，以便对它如何工作有一个了解。</p>
<p>使用行编辑器，每次可以处理一行。知道处于文件中的哪一行是很重要的。当使用 ed 打开文件时，它显示了文件中的字符个数并定位在<span style="color:red">最后一行</span>。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ ed <span class="built_in">test</span></div><div class="line">339</div></pre></td></tr></table></figure></p>
<p>没有提示符。如果输入了 ed 不理解的命令，它将打印一个问号作为错误消息。可以输入打印命令 p 来显示当前的行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">p</div><div class="line">label on the first box.</div></pre></td></tr></table></figure></p>
<p>默认情况下，一个命令只影响当前的行。要进行一项编辑工作，首先要移至想要编辑的行，然后应用相应的命令。要移到某一行，就要指定它的地址（address）。一个地址可以由一个行号、一个指示文件中特定位置的符号或一个正则表达式组成。通过输入行号 1 可以转到第一行，然后输入删除命令来删除那一行。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">You might think of a regular expression</div><div class="line">d</div></pre></td></tr></table></figure></p>
<p>输入“<code>1</code>”使第一行成为当前行，并在屏幕上显示它。ed 中的删除命令是<code>d</code>，上例中是删除当前行。与移至某行然后再对它进行编辑不同的是，可以将标识命令对象的某一行或某些行的地址，放在编辑命令的前面作为命令的前缀。例如，如果输入“<code>1d</code>”，那么第一行就被删除。</p>
<p>还可以将一个正则表达式作为一个地址。为了删除包含单词“<code>regular</code>”的行，可以使用下面的命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/regular/d</div></pre></td></tr></table></figure></p>
<p>其中的斜杠界定的对象是正则表达式，“<code>regular</code>”是想要匹配的字符串。这个命令删除包含“<code>regular</code>”的第一行并且使跟在它后面的这一行成为当前行。<br><span style="color:red">注：确信(be sure)你已经理解了使用删除命令来删除整个行。它不只是删除那一行上的单词“<code>regular</code>”。</span><br>要删除包含这个正则表达式的所有行，可以在命令前面加上字母<code>g</code>，表示该命令是一个全局命令。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g/regular/d</div></pre></td></tr></table></figure></p>
<p>全局命令使匹配正则表达式的所有行成为特定命令的对象。</p>
<p>迄今为止只是使用了删除文本的命令，替代文本（用文中的一部分取代另一部分）更为有趣。ed 中的替换命令 <code>s</code> 是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[address]s/pattern/replacement/flag</div></pre></td></tr></table></figure></p>
<p><code>pattern</code> 是一个正则表达式，并用 <code>replacement</code> 替代当前行中与这个正则表达式匹配的字符串。例如，下面的命令用“<code>complex</code>”取代当前行上第一次出现的“<code>regular</code>”。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s/regular/complex/</div></pre></td></tr></table></figure></p>
<p>由于没有指定地址，所以它只影响当前行上的<span style="color:red">第一次出现</span>。如果当前行上没有找到“<code>regular</code>”则出现一个错误。为了寻找同一行上的多次出现，必须指定 <code>g</code> 作为标志：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s/regular/complex/g</div></pre></td></tr></table></figure></p>
<p>这个命令改变了当前行上的所有的出现。必须指定地址从而使该命令不只是对当前行操作。下面的替换命令指定了一个地址：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/regular/s/regular/complex/g</div></pre></td></tr></table></figure></p>
<p>这个命令影响文件中与这个地址匹配的<span style="color:red">第一行</span>。记住，第一个“<code>regular</code>”是一个地址，第二个是匹配替换命令的模式。要将它应用于所有的行，必须使用全局命令，即在地址前放置<code>g</code>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g/regular/s/regular/complex/g</div></pre></td></tr></table></figure></p>
<p>现在，这个替换应用于所有的地方，即所有行上的所有出现。<br><span style="color:red">注：注意“<code>g</code>”的不同含义。开始处的“<code>g</code>”是全局命令，意味着对所有与地址匹配的行进行改变。结尾处的“<code>g</code>”是一个标志，意味着改变一行上的每个出现，不只是第一个。</span></p>
<p><span style="color:red">地址和模式不必相同。</span>例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g/regular expression/s/regular/complex/g</div></pre></td></tr></table></figure></p>
<p>表示在包含字符串“<code>regular expression</code>”的任意行上，用“<code>complex</code>”代替“<code>regular</code>”。<br><span style="color:red">如果地址和模式相同，那么可以通过指定两个连续的定界符（<code>//</code>）来告诉 ed。</span><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g/regular/s//complex/g</div></pre></td></tr></table></figure></p>
<p>在这个例子中，“<code>regular</code>”被指定为“地址”，同时应用相应的地址匹配替换模式。</p>
<p>PS：到此为止，也不难理解 vi 中的“搜索及替换”命令了。</p>
<p><span style="color:red">vi 编辑器中的“搜索及替换”命令：</span></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/pattern</code></td>
<td>从光标开始处向文件尾搜索pattern</td>
</tr>
<tr>
<td><code>?pattern</code></td>
<td>从光标开始处向文件首搜索pattern</td>
</tr>
<tr>
<td><code>n</code></td>
<td>在同一方向重复上一次搜索命令</td>
</tr>
<tr>
<td><code>N</code></td>
<td>在反方向上重复上一次搜索命令</td>
</tr>
<tr>
<td><code>:s/p1/p2/g</code></td>
<td>将当前行中所有p1均用p2替换<br>（如果去掉结尾处的“g”标志，则只是替换当前行中p1的第一次出现）</td>
</tr>
<tr>
<td><code>:n1,n2 s/p1/p2/g</code></td>
<td>将第n1至n2行中所有p1均用p2替换<br>（如果去掉结尾处的“g”标志，则只是替换匹配的每一行中p1的第一次出现）</td>
</tr>
<tr>
<td><code>:g/p1/s//p2/g</code></td>
<td>将文件中所有p1均用p2替换</td>
</tr>
</tbody>
</table>
<p><span style="color:red">类似的 UNIX 实用工具 grep 来源于 ed 中的下面的全局命令：</span><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g/re/p</div></pre></td></tr></table></figure></p>
<p>（PS：估计这也是程序名称“grep”的由来吧）</p>
<p>它表示“<code>全局正则表达式打印</code>”。grep 是从 ed 中提取并可用做外部程序的行编辑命令。它是执行一个编辑命令的“硬连接（hard-wired）”。将正则表达式作为命令行上的一个参数并将它用做要打印的行的地址。如下例所示，寻找匹配“<code>box</code>”的行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ grep <span class="string">'box'</span> <span class="built_in">test</span></div><div class="line">You are given a series of boxes,the first one labeled <span class="string">"A"</span>,</div><div class="line">label on the first box.</div></pre></td></tr></table></figure></p>
<p>它打印匹配正则表达式的所有的行。</p>
<p>注：在使用正则表达式作为命令行上的一个参数时，假如模式中包含有可以由 shell 解释的空格或任意字符（例如<code>$</code>和<code>*</code>），那么必须用<strong>单引号</strong>括住。这也是在命令行上使用正则表达式时的一个良好习惯——正则表达式要正确地传递到使用它的程序而不只是由 shell 解释。</p>
<p>ed 的一个更有趣的特征是脚本化编辑工作的能力，将编辑命令放在独立的文件中并将它们作为行编辑器的输入。例如，如果将一系列命令放到名为 <code>ed-script</code> 的文件中，下面的命令将执行这个脚本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ed <span class="built_in">test</span> &lt; ed-script</div></pre></td></tr></table></figure></p>
<p>这个特征使 ed 成为可编程的编辑器。也就是说，你可以脚本化任何手动执行的操作。</p>
<h2 id="ed、sed、awk"><a href="#ed、sed、awk" class="headerlink" title="ed、sed、awk"></a>ed、sed、awk</h2><p>sed 是作为特殊目的的编辑器而创建的，用于专门执行脚本；与 ed 不同，它不能交互地使用。sed 与 ed 的主要区别在于它是面向字符流的。<span style="color:red">默认情况下，到 sed 的所有输入都会经过相应的处理，并转为标准输出。输入文件本身不发生改变。如果确实想改变输入文件，一般使用 shell 机制进行输出重定向（注：不要将来自命令的输出重定向到输入文件，否则会改写输入文件。甚至可能在 sed 处理这个文件之前发生，并破坏你的数据。），当你对所做的编辑工作满意时，用修改后的版本代替最初的文件。 </span></p>
<p>ed 不是面向字符流的，并且文件本身会发生改变。ed 脚本必须包含保存文件并退出编辑器的命令。它不产生到达屏幕的输出，但由特殊命令生成的东西除外。</p>
<p>sed 的字符流定位对如何应用寻址有重要的影响。在 ed 中没有指定地址的命令只影响当前行。sed 遍历文件，每次一行，这样每一行都成为当前行，而且每一行都应用这个命令。结果是 sed 对文件中的每一行应用了没有地址的命令。</p>
<p>看一下下面的替换命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">s/regular/complex/</div></pre></td></tr></table></figure></p>
<p>如果在 ed 中交互式的输入这个命令，则用“<code>complex</code>”取代当前行上第一次出现的“<code>regular</code>”。在 ed 脚本中，如果这是脚本中的第一个命令，那么它就只是应用于文件的最后一行（ed 的默认当前行）。然而，在 sed 脚本中，相同的命令应用于所有的行。也就是说，sed 命令是隐式的全局命令。在 sed 中，上一个示例的命令和 ed 中如下所示的全局命令结果相同。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g/regular/s//complex/</div></pre></td></tr></table></figure></p>
<p><span style="color:red">注：理解 ed 中的当前行寻址与 sed 中全局行寻址之间的区别是很重要的。在 ed 中，使用寻址扩大受命令影响的行数；在 sed 中，使用寻址限制受命令影响的行数。</span></p>
<p>awk 是作为可编程的编辑器而开发的，同 sed 一样，它也是面向字符流的，并且解释编辑命令的脚本。awk 与 sed 不同的地方是它废弃了行编辑器的命令集。它提供了仿效 C 语言的程序设计语言，例如，<code>print</code> 语句取代 <code>p</code> 命令；但延续了寻址的概念，例如：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/regular/ &#123;<span class="built_in">print</span>&#125;</div></pre></td></tr></table></figure></p>
<p>用于打印匹配“<code>regular</code>”的那些行。大括号（<code>{}</code>）用于包围应用于同一个地址的一个或多个语句。</p>
<p>在脚本中使用程序设计语言的优点是，它提供了更多的方式来控制可编程的编辑器所做的事情。awk 提供了表达式、条件语句、循环和其他程序设计结构。</p>
<p>awk 最独特的特征之一是它分析或拆分每个输入行，并生成可用于脚本处理的独立的单词（一个编辑器，例如 vi，也识别单词，允许一个单词一个单词的移动，或者使一个单词成为操作对象，但是这些特征只能在交互式下使用）。虽然 awk 是作为可编程的编辑器设计的，但它还可以完成许多其他任务。</p>
<p>更多的关于 sed &amp; awk ，请详读《sed &amp; awk》 Dale Dougberty &amp; Arnold Robbins 著</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[开发者日常使用的 Git 命令]]></title>
      <url>http://jarsonfang.github.io/etesting/Tools/VCS/everyday-git/</url>
      <content type="html"><![CDATA[<p>原文链接： <a href="https://www.kernel.org/pub/software/scm/git/docs/everyday.html" target="_blank" rel="external">Everyday GIT With 20 Commands Or So</a>   翻译： <a href="http://blog.jobbole.com" target="_blank" rel="external"> 伯乐在线 </a> - <a href="http://blog.jobbole.com/author/cjpan/" target="_blank" rel="external">cjpan</a><br>译文链接： <a href="http://blog.jobbole.com/54184/" target="_blank" rel="external">http://blog.jobbole.com/54184/</a> （下文在原译文基础上有修正补充）</p>
<p><span style="color:red;">原文（英）最后更新时间：Last updated 2013-02-15 15:53:17 UTC</span></p>
<p>这些命令分四种类型：①不需要和其他开发者协作的独立开发者，会经常用到 <code>git init</code>、<code>git show branch</code>、<code>git commit</code> 等命令；②需要和其他人协作的开发者，会常用到 <code>git clone</code>、<code>git push</code>、<code>git pull</code>、<code>git format patch</code>；③在项目中负责接收其他开发者发来更新的核心开发者，会常用到 <code>git am</code>、<code>git pull</code>、<code>git format patch</code>、<code>git revert</code>、<code>git push</code>；④ 代码仓库管理员常用 <code>git daemon</code>、<code>git shell</code> ……</p>
<p>对于任何想做提交的人来说，甚至对于某位单独工作的人来说，【个人开发者（单独开发）】部分命令都是必不可少的。如果你和别人一起工作，你也会需要【个人开发者（参与者）】部分列出的命令。</p>
<p>除了上述的部分，担当【集成人员】角色的人需要知道更多命令。【代码库管理】命令帮助系统管理员负责管理，以及向git代码库提交内容。<br><a id="more"></a></p>
<h2 id="个人开发者（单独开发）Individual-Developer-Standalone"><a href="#个人开发者（单独开发）Individual-Developer-Standalone" class="headerlink" title="个人开发者（单独开发）Individual Developer (Standalone)"></a>个人开发者（单独开发）Individual Developer (Standalone)</h2><p>单独的个人开发者不会与他人交换修补程序，只用到下列命令，独自在单独的代码库上工作：</p>
<ul>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-init.html" target="_blank" rel="external">git-init(1)</a> 创建新代码库。to create a new repository.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-show-branch.html" target="_blank" rel="external">git-show-branch(1)</a> 查看你在哪里。to see where you are.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-log.html" target="_blank" rel="external">git-log(1)</a> 查看发生过什么。to see what happened.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-checkout.html" target="_blank" rel="external">git-checkout(1)</a>和<a href="https://www.kernel.org/pub/software/scm/git/docs/git-branch.html" target="_blank" rel="external">git-branch(1)</a> 切换分支。to switch branches.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-add.html" target="_blank" rel="external">git-add(1)</a> 管理索引文件。to manage the index file.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-diff.html" target="_blank" rel="external">git-diff(1)</a>和<a href="https://www.kernel.org/pub/software/scm/git/docs/git-status.html" target="_blank" rel="external">git-status(1)</a> 查看你正在做什么。to see what you are in the middle of doing.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-commit.html" target="_blank" rel="external">git-commit(1)</a> 将推进当前分支。to advance the current branch.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-reset.html" target="_blank" rel="external">git-reset(1)</a>和<a href="https://www.kernel.org/pub/software/scm/git/docs/git-checkout.html" target="_blank" rel="external">git-checkout(1)</a> （带路径名参数）放弃（撤销）修改。to undo changes.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-merge.html" target="_blank" rel="external">git-merge(1)</a> 合并本地分支。to merge between local branches.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-rebase.html" target="_blank" rel="external">git-rebase(1)</a> 维护主题分支。to maintain topic branches.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-tag.html" target="_blank" rel="external">git-tag(1)</a> 给已知点打标签。to mark known point.</li>
</ul>
<h3 id="实例-Examples"><a href="#实例-Examples" class="headerlink" title="实例 Examples"></a>实例 Examples</h3><p><strong>用Tar包作为一个新代码库的起始点</strong><br>Use a tarball as a starting point for a new repository.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ tar zxf frotz.tar.gz</div><div class="line">$ <span class="built_in">cd</span> frotz</div><div class="line">$ git init</div><div class="line">$ git add . &lt;1&gt;</div><div class="line">$ git commit -m <span class="string">"import of frotz source tree."</span></div><div class="line">$ git tag v2.43 &lt;2&gt;</div></pre></td></tr></table></figure></p>
<ol>
<li>添加现目录下的所有文件。</li>
<li>打一个轻量的无注释的标签。</li>
</ol>
<p><strong>创建一个主题分支并开发</strong><br>Create a topic branch and develop.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b alsa-audio &lt;1&gt;</div><div class="line">$ edit/compile/<span class="built_in">test</span></div><div class="line">$ git checkout -- curses/ux_audio_oss.c &lt;2&gt;</div><div class="line">$ git add curses/ux_audio_alsa.c &lt;3&gt;</div><div class="line">$ edit/compile/<span class="built_in">test</span></div><div class="line">$ git diff HEAD &lt;4&gt;</div><div class="line">$ git commit <span class="_">-a</span> <span class="_">-s</span> &lt;5&gt;</div><div class="line">$ edit/compile/<span class="built_in">test</span></div><div class="line">$ git reset --soft HEAD^ &lt;6&gt;</div><div class="line">$ edit/compile/<span class="built_in">test</span></div><div class="line">$ git diff ORIG_HEAD &lt;7&gt;</div><div class="line">$ git commit <span class="_">-a</span> -c ORIG_HEAD &lt;8&gt;</div><div class="line">$ git checkout master &lt;9&gt;</div><div class="line">$ git merge alsa-audio &lt;10&gt;</div><div class="line">$ git <span class="built_in">log</span> --since=<span class="string">'3 days ago'</span> &lt;11&gt;</div><div class="line">$ git <span class="built_in">log</span> v2.43.. curses/ &lt;12&gt;</div></pre></td></tr></table></figure></p>
<ol>
<li>创建(create)一个主题分支。</li>
<li>还原(revert)你在<code>curses/ux_audio_oss.c</code>文件里搞砸了的修改。</li>
<li>如果你添加一个新文件，你需要告诉git；之后，如果你使用<em><code>git commit -a</code></em>， 删除和修改就会被(git)捕获。</li>
<li>查看你正在提交什么修改。</li>
<li>提交所有的你已测试文件，包括你的签名。</li>
<li>撤回最后一次提交，保留工作区（working tree）内容。</li>
<li>查看自从上一个不成熟提交后的修改。</li>
<li>沿用原先写过的（注释）信息，重做在之前步骤中撤销了的提交。</li>
<li>切换到主干（master）分支。</li>
<li>合并一个主题分支到主分支。</li>
<li>回顾提交记录；其他限制输出的形式也可以合并包含（combined and include）： <em><code>--max-count=10</code></em>(显示10个提交)，<em><code>--until=2005-12-10</code></em> 等。</li>
<li>只查看从<em><code>v2.43</code></em>标签开始以来影响到<em><code>curses/</code></em>目录的修改。</li>
</ol>
<h2 id="个人开发者（参与开发）Individual-Developer-Participant"><a href="#个人开发者（参与开发）Individual-Developer-Participant" class="headerlink" title="个人开发者（参与开发）Individual Developer (Participant)"></a>个人开发者（参与开发）Individual Developer (Participant)</h2><p>作为一个团体项目里的参与角色，开发人员需要学习如何与他人沟通，除了那些单独开发者需要掌握的命令以外，还要使用这些命令。</p>
<ul>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-clone.html" target="_blank" rel="external">git-clone(1)</a> 从上游代码库填充你的本地代码库。<br>from the upstream to prime your local repository.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-pull.html" target="_blank" rel="external">git-pull(1)</a>和<a href="https://www.kernel.org/pub/software/scm/git/docs/git-fetch.html" target="_blank" rel="external">git-fetch(1)</a> 从“origin”得到最新的上游代码库。<br>from “origin” to keep up-to-date with the upstream.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-push.html" target="_blank" rel="external">git-push(1)</a> 共享代码库，如果你采用cvs风格的代码库工作流的话。<br>to shared repository, if you adopt CVS style shared repository workflow.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-format-patch.html" target="_blank" rel="external">git-format-patch(1)</a> 准备e-mail提交，如果你使用Linux内核风格的公共论坛工作流的话。<br>to prepare e-mail submission, if you adopt Linux kernel-style public forum workflow.</li>
</ul>
<h3 id="实例-Examples-1"><a href="#实例-Examples-1" class="headerlink" title="实例 Examples"></a>实例 Examples</h3><p><strong>复制上游代码库并在其上工作，提交修改到上游代码库。</strong><br>Clone the upstream and work on it. Feed changes to upstream.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ git <span class="built_in">clone</span> git://git.kernel.org/pub/scm/.../torvalds/linux-2.6 my2.6</div><div class="line">$ <span class="built_in">cd</span> my2.6</div><div class="line">$ edit/compile/<span class="built_in">test</span>; git commit <span class="_">-a</span> <span class="_">-s</span> &lt;1&gt;</div><div class="line">$ git format-patch origin &lt;2&gt;</div><div class="line">$ git pull &lt;3&gt;</div><div class="line">$ git <span class="built_in">log</span> -p ORIG_HEAD.. arch/i386 include/asm-i386 &lt;4&gt;</div><div class="line">$ git pull git://git.kernel.org/pub/.../jgarzik/libata-dev.git ALL &lt;5&gt;</div><div class="line">$ git reset --hard ORIG_HEAD &lt;6&gt;</div><div class="line">$ git gc &lt;7&gt;</div><div class="line">$ git fetch --tags &lt;8&gt;</div></pre></td></tr></table></figure></p>
<ol>
<li>按需重复。(repeat as needed)</li>
<li>从你的分支中提取补丁文件，用于电子邮件提交。</li>
<li><em><code>git pull</code></em>命令默认从“<em><code>origin</code></em>”里取得内容并合并到当前的分支中去。</li>
<li>在<code>pull</code>之后，立即查看在上游仓库中自上次检出之后提交的修改（日志），仅查看关注的部分。</li>
<li>从一个指定代码库的一个指定分支获取内容并合并。</li>
<li>撤销（revert）<code>pull</code>操作。</li>
<li>从撤销的<code>pull</code>操作中回收残存的对象。（代码库清理）</li>
<li>不时地，从<em><code>origin</code></em>中获取官方的标签，并保存于<em><code>.git/refs/tags/</code></em>。</li>
</ol>
<p><strong>推送到另一个代码库</strong><br>Push into another repository.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">satellite$ git <span class="built_in">clone</span> mothership:frotz frotz &lt;1&gt;</div><div class="line">satellite$ <span class="built_in">cd</span> frotz</div><div class="line">satellite$ git config --get-regexp <span class="string">'^(remote|branch)\.'</span> &lt;2&gt;</div><div class="line">remote.origin.url mothership:frotz</div><div class="line">remote.origin.fetch refs/heads/*:refs/remotes/origin/*</div><div class="line">branch.master.remote origin</div><div class="line">branch.master.merge refs/heads/master</div><div class="line">satellite$ git config remote.origin.push \</div><div class="line">           master:refs/remotes/satellite/master &lt;3&gt;</div><div class="line">satellite$ edit/compile/<span class="built_in">test</span>/commit</div><div class="line">satellite$ git push origin &lt;4&gt;</div><div class="line"></div><div class="line">mothership$ <span class="built_in">cd</span> frotz</div><div class="line">mothership$ git checkout master</div><div class="line">mothership$ git merge satellite/master &lt;5&gt;</div></pre></td></tr></table></figure></p>
<ol>
<li><code>mothership</code>机器的<code>home</code>目录下有一个<code>frotz</code>代码库；复制它（clone from it）以在<code>satellite</code>机器上开始一个代码库。</li>
<li>复制（<code>clone</code>）操作默认设定这些配置变量。它安排<em><code>git pull</code></em>去抓取并保存<code>mothership</code>机器上的分支到本地的<em><code>remotes/origin/*</code></em> 跟踪分支。</li>
<li>安排<em><code>git push</code></em>去推送本地的主（<em><code>master</code></em>）分支到<code>mothership</code>机器的<em><code>remotes/satellite/master</code></em>分支</li>
<li><code>push</code>操作会在<code>mothership</code>机器的<em><code>remotes/satellite/master</code></em>的远程跟踪分支上存储我们的工作。你可以用此作为一个备份方法。</li>
<li>在<code>mothership</code>机器上，将<code>satellite</code>机器上已完成的工作合并到<code>master</code>分支中。</li>
</ol>
<p><strong>分支的特定标签</strong><br>Branch off of a specific tag.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git checkout -b private2.6.14 v2.6.14 &lt;1&gt;</div><div class="line">$ edit/compile/<span class="built_in">test</span>; git commit <span class="_">-a</span></div><div class="line">$ git checkout master</div><div class="line">$ git format-patch -k -m --stdout v2.6.14..private2.6.14 |</div><div class="line">  git am -3 -k &lt;2&gt;</div></pre></td></tr></table></figure></p>
<ol>
<li>创建一个私有分支，基于熟知（但稍许过时的）标签。</li>
<li>在还没有正式“合并（merging）”的情况下，向前移植<code>private2.6.14</code>分支所有的修改到<code>master</code>分支上。</li>
</ol>
<h2 id="集成人员-Integrator"><a href="#集成人员-Integrator" class="headerlink" title="集成人员 Integrator"></a>集成人员 Integrator</h2><p>在一个团队项目中担任集成者的是一名相当重要的人员，他/她接收其他人的修改，评审并集成然后发布最终结果供其他人使用；除了参与者需要的那些命令之外，还需要使用以下这些命令。</p>
<ul>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-am.html" target="_blank" rel="external">git-am(1)</a> 采用你的贡献者邮寄过来的补丁文件。<br>to apply patches e-mailed in from your contributors.*   <a href="https://www.kernel.org/pub/software/scm/git/docs/git-pull.html" target="_blank" rel="external">git-pull(1)</a> 从你的可信任的助手处合并内容。<br>to merge from your trusted lieutenants.</li>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-format-patch.html" target="_blank" rel="external">git-format-patch(1)</a> 准备并向你的贡献者发送建议选项。<br>to prepare and send suggested alternative to contributors.<em>   <a href="https://www.kernel.org/pub/software/scm/git/docs/git-revert.html" target="_blank" rel="external">git-revert(1)</a> 撤销不好的提交。<br>to undo botched commits.</em>   <a href="https://www.kernel.org/pub/software/scm/git/docs/git-push.html" target="_blank" rel="external">git-push(1)</a> 发布最新的内容。<br>to publish the bleeding edge.</li>
</ul>
<h3 id="实例-Examples-2"><a href="#实例-Examples-2" class="headerlink" title="实例 Examples"></a>实例 Examples</h3><p><strong>我典型的GIT一天</strong><br>My typical GIT day.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ git status &lt;1&gt;</div><div class="line">$ git show-branch &lt;2&gt;</div><div class="line">$ mailx &lt;3&gt;</div><div class="line">&amp; s 2 3 4 5 ./+to-apply</div><div class="line">&amp; s 7 8 ./+hold-linus</div><div class="line">&amp; q</div><div class="line">$ git checkout -b topic/one master</div><div class="line">$ git am -3 -i <span class="_">-s</span> -u ./+to-apply &lt;4&gt;</div><div class="line">$ compile/<span class="built_in">test</span></div><div class="line">$ git checkout -b hold/linus &amp;&amp; git am -3 -i <span class="_">-s</span> -u ./+hold-linus &lt;5&gt;</div><div class="line">$ git checkout topic/one &amp;&amp; git rebase master &lt;6&gt;</div><div class="line">$ git checkout pu &amp;&amp; git reset --hard next &lt;7&gt;</div><div class="line">$ git merge topic/one topic/two &amp;&amp; git merge hold/linus &lt;8&gt;</div><div class="line">$ git checkout maint</div><div class="line">$ git cherry-pick master~4 &lt;9&gt;</div><div class="line">$ compile/<span class="built_in">test</span></div><div class="line">$ git tag <span class="_">-s</span> -m <span class="string">"GIT 0.99.9x"</span> v0.99.9x &lt;10&gt;</div><div class="line">$ git fetch ko &amp;&amp; git show-branch master maint <span class="string">'tags/ko-*'</span> &lt;11&gt;</div><div class="line">$ git push ko &lt;12&gt;</div><div class="line">$ git push ko v0.99.9x &lt;13&gt;</div></pre></td></tr></table></figure></p>
<ol>
<li>查看我正在做什么，如果有的话。</li>
<li>查看我拥有的主题分支，并考虑它们的完成度。</li>
<li>读邮件，保存合适的，并且保存那些尚未完成的。</li>
<li>采用它们，交互式地，带着我的签名。</li>
<li>按需创建主题分支，还是由我签名采用。</li>
<li>为内部的还未合并到主分支，也没有作为稳定分支的一部分公开的主题分支重定基线。</li>
<li>从接下来开始，每次都重置<em>pu</em>。</li>
<li>合并仍然在料理中的主题分支</li>
<li>向后移植（backport）极其重要的修正。</li>
<li>创建一个签名的标签。</li>
<li>确保我不会意外将主分支回滚到我已经推出来的内容。简写的<em><code>ko</code></em>指向我在kernel.org上已有的代码库里，看起来像这样：<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ cat .git/remotes/ko</div><div class="line">URL: kernel.org:/pub/scm/git/git.git</div><div class="line">Pull: master:refs/tags/ko-master</div><div class="line">Pull: next:refs/tags/ko-next</div><div class="line">Pull: maint:refs/tags/ko-maint</div><div class="line">Push: master</div><div class="line">Push: next</div><div class="line">Push: +pu</div><div class="line">Push: maint</div></pre></td></tr></table></figure>
</li>
</ol>
<p>在从<em><code>git show-branch</code></em>的输出里，主分支（<em><code>master</code></em>）应该包含<em><code>ko-master</code></em>所有的内容，并且<em><code>next</code></em>应该包含<em><code>ko-next</code></em>所有的内容。<br>12.  推送最新内容<br>13.  推送标签</p>
<h2 id="代码库管理-Repository-Administration"><a href="#代码库管理-Repository-Administration" class="headerlink" title="代码库管理 Repository Administration"></a>代码库管理 Repository Administration</h2><p>代码库管理员使用下列工具来设置及维护开发者对代码库的访问。</p>
<ul>
<li><a href="https://www.kernel.org/pub/software/scm/git/docs/git-daemon.html" target="_blank" rel="external">git-daemon(1)</a> 允许匿名者从代码库下载。<br>to allow anonymous download from repository.*   <a href="https://www.kernel.org/pub/software/scm/git/docs/git-shell.html" target="_blank" rel="external">git-shell(1)</a> 可以被用作为限制登录shell，用于共享中央代码库的用户。<br>can be used as a <em>restricted login shell</em> for shared central repository users.<br><a href="https://www.kernel.org/pub/software/scm/git/docs/howto/update-hook-example.txt" target="_blank" rel="external">update hook howto</a> 有一个很好的管理共享中央代码库的实例。</li>
</ul>
<h3 id="实例-Examples-3"><a href="#实例-Examples-3" class="headerlink" title="实例 Examples"></a>实例 Examples</h3><p><strong>我们假设下面的内容均在/etc/services目录下</strong><br>We assume the following in /etc/services<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ grep 9418 /etc/services</div><div class="line">git             9418/tcp                <span class="comment"># Git Version Control System</span></div></pre></td></tr></table></figure></p>
<p><strong>从inetd中运行git-daemon来服务于/pub/scm</strong><br>Run git-daemon to serve /pub/scm from inetd.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ grep git /etc/inetd.conf</div><div class="line">git     stream  tcp     nowait  nobody \</div><div class="line">  /usr/bin/git-daemon git-daemon --inetd --export-all /pub/scm</div></pre></td></tr></table></figure></p>
<p>实际的配置应该在1行里。</p>
<p><strong>从xinetd运行git-daemon来服务于/pub/scm</strong><br>Run git-daemon to serve /pub/scm from xinetd.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/xinetd.d/git-daemon</div><div class="line"><span class="comment"># default: off</span></div><div class="line"><span class="comment"># description: The git server offers access to git repositories</span></div><div class="line">service git</div><div class="line">&#123;</div><div class="line">        <span class="built_in">disable</span> = no</div><div class="line">        <span class="built_in">type</span>            = UNLISTED</div><div class="line">        port            = 9418</div><div class="line">        socket_type     = stream</div><div class="line">        <span class="built_in">wait</span>            = no</div><div class="line">        user            = nobody</div><div class="line">        server          = /usr/bin/git-daemon</div><div class="line">        server_args     = --inetd --export-all --base-path=/pub/scm</div><div class="line">        log_on_failure  += USERID</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>检查<code>xinetd(8)</code>文档并设置，这个文档来自于Fedora系统。其他也许会不一样。</p>
<p><strong>授予开发者只推/拉访问操作权限</strong><br>Give push/pull only access to developers.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ grep git /etc/passwd &lt;1&gt;</div><div class="line">alice:x:1000:1000::/home/alice:/usr/bin/git-shell</div><div class="line">bob:x:1001:1001::/home/bob:/usr/bin/git-shell</div><div class="line">cindy:x:1002:1002::/home/cindy:/usr/bin/git-shell</div><div class="line">david:x:1003:1003::/home/david:/usr/bin/git-shell</div><div class="line">$ grep git /etc/shells &lt;2&gt;</div><div class="line">/usr/bin/git-shell</div></pre></td></tr></table></figure></p>
<ol>
<li>登录<code>shell</code>被设置到<code>/usr/bin/git-shell</code>, 不允许<em><code>git push</code></em>和<em><code>git pull</code></em>以外的任何操作。用户需要获得一个访问此机器的<code>ssh</code>权限。</li>
<li>在许多发布版本中，<code>/etc/shells</code>需要列出作为一个登录<code>shell</code>所使用的程序。</li>
</ol>
<p><strong>CVS风格的共享代码库</strong><br>CVS-style shared repository.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">$ grep git /etc/group &lt;1&gt;</div><div class="line">git:x:9418:alice,bob,cindy,david</div><div class="line">$ <span class="built_in">cd</span> /home/devo.git</div><div class="line">$ ls <span class="_">-l</span> &lt;2&gt;</div><div class="line">  lrwxrwxrwx   1 david git    17 Dec  4 22:40 HEAD -&gt; refs/heads/master</div><div class="line">  drwxrwsr-x   2 david git  4096 Dec  4 22:40 branches</div><div class="line">  -rw-rw-r--   1 david git    84 Dec  4 22:40 config</div><div class="line">  -rw-rw-r--   1 david git    58 Dec  4 22:40 description</div><div class="line">  drwxrwsr-x   2 david git  4096 Dec  4 22:40 hooks</div><div class="line">  -rw-rw-r--   1 david git 37504 Dec  4 22:40 index</div><div class="line">  drwxrwsr-x   2 david git  4096 Dec  4 22:40 info</div><div class="line">  drwxrwsr-x   4 david git  4096 Dec  4 22:40 objects</div><div class="line">  drwxrwsr-x   4 david git  4096 Nov  7 14:58 refs</div><div class="line">  drwxrwsr-x   2 david git  4096 Dec  4 22:40 remotes</div><div class="line">$ ls <span class="_">-l</span> hooks/update &lt;3&gt;</div><div class="line">  -r-xr-xr-x   1 david git  3536 Dec  4 22:40 update</div><div class="line">$ cat info/allowed-users &lt;4&gt;</div><div class="line">refs/heads/master       alice\|cindy</div><div class="line">refs/heads/doc-update   bob</div><div class="line">refs/tags/v[0-9]*       david</div></pre></td></tr></table></figure></p>
<ol>
<li>把开发者置于同一<code>git</code>组中。</li>
<li>将共享代码库配为组可写。</li>
<li>使用 Documentation/howto/ 中Carl的<code>update-hook</code>实例作为分支策略控制。</li>
<li>alice和cindy可以推送到主分支（master），只有bob可以推送进<code>doc-update</code>。david是发布经理，并且是唯一可以创建并推送版本标签的人。</li>
</ol>
<p><strong>支持dumb协议传送的HTTP服务器</strong><br>HTTP server to support dumb protocol transfer.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dev$ git update-server-info &lt;1&gt;</div><div class="line">dev$ ftp user@isp.example.com &lt;2&gt;</div><div class="line">ftp&gt; cp -r .git /home/user/myproject.git</div></pre></td></tr></table></figure></p>
<ol>
<li>确保你的 <code>info/refs</code> 和 <code>objects/info/packs</code> 是最新的。</li>
<li>上传到由你的ISP托管的公共HTTP服务器。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用git保存空目录]]></title>
      <url>http://jarsonfang.github.io/etesting/Tools/VCS/git-save-empty-dir/</url>
      <content type="html"><![CDATA[<p>git 和 svn 不同，仅仅跟踪文件的变动，不跟踪目录。Perforce 也是如此。所以，一个空目录，如果里面没有文件，即便 git add 这个目录，另外在别处 check out 的时候，是没有这个空目录的。</p>
<p>只跟踪文件变化，不跟踪目录，这么设计是有原因的。但这会带来一些小麻烦。有时候，确实需要在代码仓库中保留某个空目录。比如测试时需要用到的空目录。</p>
<p>变通的解决办法是在空目录下存一个 <code>.gitignore</code> 文件。然后 <code>git add</code> 此目录后，相当于跟踪了 <code>.gitignore</code> 文件，产生的“副作用”就是这个“空”目录也纳入“跟踪”，最终的效果是可以 check out 出一个看起来空空的目录。如果有许多这样的空目录，可以用下面的命令自动补充 <code>.gitignore</code> 文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ find . \( -type d -empty \) -and \( -not -regex ./\.git.* \) -exec touch &#123;&#125;/.gitignore \;</div></pre></td></tr></table></figure></p>
<p>递归找寻当前目录下，类型为目录，且为空，也没有 <code>.git</code> 开头的文件，在其中用 touch 新建一个空的 <code>.gitignore</code> 文件。然后 <code>git add .</code> 之后即可。</p>
<p>如果这些特殊文件会对测试带来干扰，那就只好在测试程序运行具体测试项目之前，先跑一段初始化目录结构的代码。另外可能还需要编写负责清理的代码。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[git常用命令]]></title>
      <url>http://jarsonfang.github.io/etesting/Tools/VCS/git-in-common/</url>
      <content type="html"><![CDATA[<p>原文：<a href="http://www.cnblogs.com/1-2-3/archive/2010/07/18/git-commands.html" target="_blank" rel="external">http://www.cnblogs.com/1-2-3/archive/2010/07/18/git-commands.html</a></p>
<p>Git 是一个很强大的分布式版本控制系统。它不但适用于管理大型开源软件的源代码，管理私人的文档和源代码也有很多优势。</p>
<img src="/etesting/Tools/VCS/git-in-common/git_commands.png" alt="git_commands.png" title="">
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[KVM]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/virtualization/kvm/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Xen]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/virtualization/xen/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OpenStack]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/virtualization/openstack/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Docker]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/virtualization/docker/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LXC]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/virtualization/lxc/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[QEMU]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/virtualization/qemu/</url>
      <content type="html"><![CDATA[<p><strong>ToDo …</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[FTP on Centos 7]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Server/ftp-on-centos/</url>
      <content type="html"><![CDATA[<p>In this article, we will learn how to configure FTP server on CentOs 7 using <code>vsftpd</code>. <code>vsftpd</code> (Very Secure File Transport Protocol Daemon) is a secure and very fast FTP server on Linux systems.</p>
<h2 id="Install-vsftpd"><a href="#Install-vsftpd" class="headerlink" title="Install vsftpd"></a>Install vsftpd</h2><p>All commands should be run with <code>root</code> user. Run the following command in terminal to install <code>vsftpd</code> package:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install vsftpd ftp -y</div></pre></td></tr></table></figure></p>
<h2 id="Configure-vsftpd"><a href="#Configure-vsftpd" class="headerlink" title="Configure vsftpd"></a>Configure vsftpd</h2><p>We needed to edit the configuration file <code>/etc/vsftpd/vsftpd.conf</code> for securing the FTP server since, by default it will allow anonymous users to login and use the server.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cp /etc/vsftpd/vsftpd.conf&#123;,.bak&#125;</div><div class="line">vi /etc/vsftpd/vsftpd.conf</div></pre></td></tr></table></figure></p>
<p>We have to disallow anonymous, unidentified users to access files via FTP; change the anonymous_enable setting to NO:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">anonymous_enable=NO</div></pre></td></tr></table></figure></p>
<p>Allow local users to login by changing the local_enable setting to YES:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">local_enable=YES</div></pre></td></tr></table></figure></p>
<p>If you want to allow the local users to be able to write to a directory, then change the write_enable setting in the configuration file to YES:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">write_enable=YES</div></pre></td></tr></table></figure></p>
<p>Local users will be ‘chroot jailed’ and they will be denied access the local users to any other part of the server; change the chroot_local_user setting in the configuration file to YES:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chroot_local_user=YES</div></pre></td></tr></table></figure></p>
<p>Below is the simple configuration file for your reference:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">anonymous_enable=NO</div><div class="line">local_enable=YES</div><div class="line">write_enable=YES</div><div class="line">local_umask=022</div><div class="line">chroot_local_user=YES</div><div class="line">dirmessage_enable=YES</div><div class="line">xferlog_enable=YES</div><div class="line">connect_from_port_20=YES</div><div class="line">xferlog_std_format=YES</div><div class="line">listen=YES</div><div class="line">#listen_ipv6=YES</div><div class="line">pam_service_name=vsftpd</div><div class="line">userlist_enable=YES</div><div class="line">tcp_wrappers=YES</div></pre></td></tr></table></figure></p>
<h2 id="Enable-and-restart-the-vsftpd-service"><a href="#Enable-and-restart-the-vsftpd-service" class="headerlink" title="Enable and restart  the vsftpd service"></a>Enable and restart  the vsftpd service</h2><p>We needed to restart the <code>vsftpd</code> services so that the configuration changes has applied.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl restart vsftpd</div></pre></td></tr></table></figure></p>
<p>We will set the <code>vsftpd</code> service to start at boot time, below is the command to enable the <code>vsftpd</code> to start.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl <span class="built_in">enable</span> vsftpd</div></pre></td></tr></table></figure></p>
<h2 id="Allowing-the-vsftpd-Through-the-Firewall"><a href="#Allowing-the-vsftpd-Through-the-Firewall" class="headerlink" title="Allowing the vsftpd Through the Firewall"></a>Allowing the vsftpd Through the Firewall</h2><p>Allow the ftp service and port <strong>21</strong> via firewall.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">firewall-cmd --permanent --add-port=21/tcp</div><div class="line">firewall-cmd --permanent --add-service=ftp</div></pre></td></tr></table></figure></p>
<p>Restart firewall:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">firewall-cmd --reload</div></pre></td></tr></table></figure></p>
<h2 id="Create-FTP-users"><a href="#Create-FTP-users" class="headerlink" title="Create FTP users"></a>Create FTP users</h2><p>By default, root user is not allowed to login to ftp server for security purpose. So, let us create a normal testing user called “<code>ftpuser</code>” with password “centos”.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">useradd ftpuser</div><div class="line">passwd ftpuser</div></pre></td></tr></table></figure></p>
<h2 id="Connecting-to-FTP-server"><a href="#Connecting-to-FTP-server" class="headerlink" title="Connecting to FTP server"></a>Connecting to FTP server</h2><p>Now, try to connect to FTP server itself with user “<code>ftpuser</code>”:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ftp 192.168.3.157</div></pre></td></tr></table></figure></p>
<p>Enter the ftp user name and password.<br>Note: change <code>192.168.3.157</code> with your own FTP server address.</p>
<p>Sample Output:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">onnected to 192.168.3.157.</div><div class="line">220 (vsFTPd 3.0.2)</div><div class="line">Name (192.168.3.157:jarson): ftpuser</div><div class="line">331 Please specify the password.</div><div class="line">Password:</div><div class="line">230 Login successful.</div><div class="line">Remote system <span class="built_in">type</span> is UNIX.</div><div class="line">Using binary mode to transfer files.</div><div class="line">ftp&gt;</div></pre></td></tr></table></figure></p>
<p>Congratulations! you will be able to login to FTP server without any problems.</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1]: <a href="http://www.tutorialspoint.com/articles/how-to-install-and-configuration-ftp-server-in-centos-7" target="_blank" rel="external">http://www.tutorialspoint.com/articles/how-to-install-and-configuration-ftp-server-in-centos-7</a><br>[2]: <a href="https://www.unixmen.com/install-configure-ftp-server-centos-7/" target="_blank" rel="external">https://www.unixmen.com/install-configure-ftp-server-centos-7/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Samba on Centos 7]]></title>
      <url>http://jarsonfang.github.io/etesting/Estuary/Server/samba-on-centos/</url>
      <content type="html"><![CDATA[<h2 id="Installation"><a href="#Installation" class="headerlink" title="Installation"></a>Installation</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install samba samba-client</div></pre></td></tr></table></figure>
<h2 id="Configuration"><a href="#Configuration" class="headerlink" title="Configuration"></a>Configuration</h2><p>Now to configure samba, make the backup of original file as <code>/etc/samba/smb.conf.bak</code> before editing the file <code>/etc/samba/smb.conf</code>.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cp /etc/samba/smb.conf&#123;,.bak&#125;</div></pre></td></tr></table></figure>
<h3 id="Anonymous-samba-sharing"><a href="#Anonymous-samba-sharing" class="headerlink" title="Anonymous samba sharing"></a>Anonymous samba sharing</h3><p>Further give the entries like this:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt;&gt; /etc/samba/smb.conf</div><div class="line">[share]</div><div class="line">    comment = Anonymous share</div><div class="line">    path = /srv/samba/share</div><div class="line">    public = yes</div><div class="line">    browsable =yes</div><div class="line">    writable = yes</div><div class="line">    guest ok = yes</div><div class="line">    <span class="built_in">read</span> only = no</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>Create the folder with the name <code>share</code> in the <code>/srv/samba</code> and give the permissions like this:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir -p /srv/samba/share</div><div class="line"><span class="built_in">cd</span> /srv/samba</div><div class="line">chmod -R 0755 share/</div><div class="line">chown -R nobody:nobody share/</div></pre></td></tr></table></figure></p>
<p>Restart samba service:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">systemctl <span class="built_in">enable</span> smb.service</div><div class="line">systemctl restart smb.service</div></pre></td></tr></table></figure></p>
<p>Further, CentOS 7.0 Firewall-cmd will block the samba access, to get rid of that we will run:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">firewall-cmd --permanent --zone=public --add-service=samba</div><div class="line">firewall-cmd --reload</div></pre></td></tr></table></figure></p>
<h3 id="Secured-samba-server"><a href="#Secured-samba-server" class="headerlink" title="Secured samba server"></a>Secured samba server</h3><p>Therefore, create a group <code>smbgrp</code> &amp; user <code>smb</code> to access the samba server with proper authentication.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">groupadd smbgrp</div><div class="line">useradd smb -G smbgrp</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@cent-est samba]<span class="comment"># smbpasswd -a smb</span></div><div class="line">New SMB password:&lt;--yoursambapassword</div><div class="line">Retype new SMB password:&lt;--yoursambapassword</div><div class="line">Added user smb.</div><div class="line">[root@cent-est samba]<span class="comment">#</span></div></pre></td></tr></table></figure>
<p>Now create the folder with the name <code>secured</code> in the <code>/samba</code> folder and give permissions like this:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mkdir -p /srv/samba/secured</div><div class="line"><span class="built_in">cd</span> /srv/samba</div><div class="line">chmod -R 0777 secured/</div><div class="line">chown -R smb:smbgrp secured/</div></pre></td></tr></table></figure></p>
<p>Again edit the configuration file as:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">cat &lt;&lt; EOF &gt;&gt; /etc/samba/smb.conf</div><div class="line">[secured]</div><div class="line">    comment = Secured share</div><div class="line">    path = /srv/samba/secured</div><div class="line">    valid users = @smbgrp</div><div class="line">    guest ok = no</div><div class="line">    writable = yes</div><div class="line">    browsable = yes</div><div class="line">EOF</div></pre></td></tr></table></figure></p>
<p>Restart samba service:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl restart smb.service</div></pre></td></tr></table></figure></p>
<h3 id="Check-the-settings-as-follows"><a href="#Check-the-settings-as-follows" class="headerlink" title="Check the settings as follows:"></a>Check the settings as follows:</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">[root@cent-est ~]<span class="comment"># testparm</span></div><div class="line">Load smb config files from /etc/samba/smb.conf</div><div class="line">rlimit_max: increasing rlimit_max (1024) to minimum Windows <span class="built_in">limit</span> (16384)</div><div class="line">Processing section <span class="string">"[homes]"</span></div><div class="line">Processing section <span class="string">"[printers]"</span></div><div class="line">Processing section <span class="string">"[share]"</span></div><div class="line">Processing section <span class="string">"[secured]"</span></div><div class="line">Loaded services file OK.</div><div class="line">Server role: ROLE_STANDALONE</div><div class="line"></div><div class="line">Press enter to see a dump of your service definitions</div><div class="line"></div><div class="line"><span class="comment"># Global parameters</span></div><div class="line">[global]</div><div class="line">        workgroup = MYGROUP</div><div class="line">        server string = Samba Server Version %v</div><div class="line">        security = USER</div><div class="line">        <span class="built_in">log</span> file = /var/<span class="built_in">log</span>/samba/log.%m</div><div class="line">        max <span class="built_in">log</span> size = 50</div><div class="line">        idmap config * : backend = tdb</div><div class="line">        cups options = raw</div><div class="line"></div><div class="line"></div><div class="line">[homes]</div><div class="line">        comment = Home Directories</div><div class="line">        <span class="built_in">read</span> only = No</div><div class="line">        browseable = No</div><div class="line"></div><div class="line"></div><div class="line">[printers]</div><div class="line">        comment = All Printers</div><div class="line">        path = /var/spool/samba</div><div class="line">        printable = Yes</div><div class="line">        <span class="built_in">print</span> ok = Yes</div><div class="line">        browseable = No</div><div class="line"></div><div class="line"></div><div class="line">[share]</div><div class="line">        comment = Anonymous share</div><div class="line">        path = /srv/samba/share</div><div class="line">        <span class="built_in">read</span> only = No</div><div class="line">        guest ok = Yes</div><div class="line"></div><div class="line"></div><div class="line">[secured]</div><div class="line">        comment = Secured share</div><div class="line">        path = /srv/samba/secured</div><div class="line">        valid users = @smbgrp</div><div class="line">        <span class="built_in">read</span> only = No</div><div class="line">[root@cent-est ~]<span class="comment">#</span></div></pre></td></tr></table></figure>
<h2 id="Test-with-smbclient"><a href="#Test-with-smbclient" class="headerlink" title="Test with smbclient"></a>Test with smbclient</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">[root@cent-est ~]# smbclient //localhost/share -U user</div><div class="line">Enter user&apos;s password:&lt;--Enter</div><div class="line">Anonymous login successful</div><div class="line">Domain=[MYGROUP] OS=[Windows 6.1] Server=[Samba 4.2.10]</div><div class="line">smb: \&gt; ls</div><div class="line">  .                                   D        0  Thu Sep 29 15:06:51 2016</div><div class="line">  ..                                  D        0  Thu Sep 29 14:25:32 2016</div><div class="line">  hello.txt                           N        0  Thu Sep 29 15:06:51 2016</div><div class="line"></div><div class="line">                51475068 blocks of size 1024. 37599412 blocks available</div><div class="line">smb: \&gt; exit</div><div class="line">[root@cent-est ~]#</div><div class="line">[root@cent-est ~]# smbclient //localhost/secured -U user</div><div class="line">Enter user&apos;s password:&lt;--Enter</div><div class="line">Anonymous login successful</div><div class="line">Domain=[MYGROUP] OS=[Windows 6.1] Server=[Samba 4.2.10]</div><div class="line">tree connect failed: NT_STATUS_ACCESS_DENIED</div><div class="line">[root@cent-est ~]#</div><div class="line">[root@cent-est ~]# smbclient //localhost/secured -U smb</div><div class="line">Enter smb&apos;s password:</div><div class="line">Domain=[MYGROUP] OS=[Windows 6.1] Server=[Samba 4.2.10]</div><div class="line">smb: \&gt; ls</div><div class="line">  .                                   D        0  Thu Sep 29 15:06:42 2016</div><div class="line">  ..                                  D        0  Thu Sep 29 14:25:32 2016</div><div class="line">  file.txt                            N        0  Thu Sep 29 15:06:42 2016</div><div class="line"></div><div class="line">                51475068 blocks of size 1024. 37599408 blocks available</div><div class="line">smb: \&gt; exit</div><div class="line">[root@cent-est ~]#</div></pre></td></tr></table></figure>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>[1]: <a href="https://www.howtoforge.com/samba-server-installation-and-configuration-on-centos-7" target="_blank" rel="external">https://www.howtoforge.com/samba-server-installation-and-configuration-on-centos-7</a><br>[2]: <a href="https://www.samba.org/samba/docs/man/Samba-HOWTO-Collection/" target="_blank" rel="external">https://www.samba.org/samba/docs/man/Samba-HOWTO-Collection/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://jarsonfang.github.io/etesting/Tools/Hexo/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
